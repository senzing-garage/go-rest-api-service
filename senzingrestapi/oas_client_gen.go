// Code generated by ogen, DO NOT EDIT.

package senzingrestapi

import (
	"context"
	"net/url"
	"strings"
	"time"

	"github.com/go-faster/errors"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/trace"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
)

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	baseClient
}

var _ Handler = struct {
	*Client
}{}

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// AddDataSources invokes addDataSources operation.
//
// Obtains the current default configuration, adds the specified data
// sources and sets the modified configuration as the new default
// configuration -- returning the set of all configured data sources.
// **NOTE:** This operation may not be allowed.  Some conditions that
// might cause this operation to be forbidden are:
// 1. The server does not have administrative functions enabled.
// 2. The server is running in "read-only" mode.
// 3. The server is started with a file-based configuration specified
// by `G2CONFIGFILE` property in the initialziation parameters.
// 4. The server is started with a specific configuration ID and
// therefore cannot modify the configuration and change to a new
// configuration.
//
// POST /data-sources
func (c *Client) AddDataSources(ctx context.Context, request AddDataSourcesReq, params AddDataSourcesParams) (AddDataSourcesRes, error) {
	res, err := c.sendAddDataSources(ctx, request, params)
	_ = res
	return res, err
}

func (c *Client) sendAddDataSources(ctx context.Context, request AddDataSourcesReq, params AddDataSourcesParams) (res AddDataSourcesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addDataSources"),
	}
	// Validate request before sending.
	switch request := request.(type) {
	case *AddDataSourcesReqEmptyBody:
		// Validation is not needed for the empty body type.
	case *AddDataSourcesReqApplicationJSON:
		if err := func() error {
			if err := request.Validate(); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "validate")
		}
	case *AddDataSourcesReqTextPlain:
		// Validation is not required for this type.
	default:
		return res, errors.Errorf("unexpected request type: %T", request)
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddDataSources",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/data-sources"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "dataSource" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "dataSource",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.DataSource {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withRaw" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithRaw.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddDataSourcesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddDataSourcesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddRecord invokes addRecord operation.
//
// This operation loads a single record using the data source identified by
// the data source code in the request path.  The record will be identified
// uniquely within the data source by the record ID provided in the request
// path.  The provided record in the request body is described in JSON
// using the [Senzing Generic Entity Specification](https://senzing.zendesk.
// com/hc/en-us/articles/231925448-Generic-Entity-Specification).
// The provided JSON record may omit the `RECORD_ID`, but if it contains a
// `RECORD_ID` then it **must** match the record ID provided on the request
// path.  The record ID is returned as part of the response.
// **NOTE:** The `withInfo` parameter will return the entity resolution
// info pertaining to the load.  This can be used to update a search index
// or external data mart.   Additionally, Senzing API Server provides a
// means to have the "raw" entity resolution info (from the underlying
// native Senzing API) automatically sent to a messaging service such as
// those provided by Amazon SQS, Rabbit MQ or Kafka regardless of the
// `withInfo` query parameter value.
//
// PUT /data-sources/{dataSourceCode}/records/{recordId}
func (c *Client) AddRecord(ctx context.Context, request AddRecordReq, params AddRecordParams) (AddRecordRes, error) {
	res, err := c.sendAddRecord(ctx, request, params)
	_ = res
	return res, err
}

func (c *Client) sendAddRecord(ctx context.Context, request AddRecordReq, params AddRecordParams) (res AddRecordRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addRecord"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddRecord",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/data-sources/"
	{
		// Encode "dataSourceCode" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "dataSourceCode",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DataSourceCode))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/records/"
	{
		// Encode "recordId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "recordId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RecordId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "loadId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "loadId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.LoadId.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withInfo" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withInfo",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithInfo.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withRaw" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithRaw.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddRecordRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddRecordResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddRecordWithReturnedRecordId invokes addRecordWithReturnedRecordId operation.
//
// This operation loads a single record using the data source identified by
// the data source code in the request path.  The provided record in the
// request body is described in JSON using the
// [Senzing Generic Entity Specification](https://senzing.zendesk.
// com/hc/en-us/articles/231925448-Generic-Entity-Specification).
// The provided record may contain a `RECORD_ID` to identify it uniquely
// among other records in the same data source, but if it does not then a
// record ID will be automatically generated.  The record ID is returned
// as part of the response.
// **NOTE:** The `withInfo` parameter will return the entity resolution
// info pertaining to the load.  This can be used to update a search index
// or external data mart.   Additionally, Senzing API Server provides a
// means to have the "raw" entity resolution info (from the underlying
// native Senzing API) automatically sent to a messaging service such as
// those provided by Amazon SQS, Rabbit MQ or Kafka regardless of the
// `withInfo` query parameter value.
//
// POST /data-sources/{dataSourceCode}/records
func (c *Client) AddRecordWithReturnedRecordId(ctx context.Context, request AddRecordWithReturnedRecordIdReq, params AddRecordWithReturnedRecordIdParams) (AddRecordWithReturnedRecordIdRes, error) {
	res, err := c.sendAddRecordWithReturnedRecordId(ctx, request, params)
	_ = res
	return res, err
}

func (c *Client) sendAddRecordWithReturnedRecordId(ctx context.Context, request AddRecordWithReturnedRecordIdReq, params AddRecordWithReturnedRecordIdParams) (res AddRecordWithReturnedRecordIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addRecordWithReturnedRecordId"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AddRecordWithReturnedRecordId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/data-sources/"
	{
		// Encode "dataSourceCode" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "dataSourceCode",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DataSourceCode))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/records"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "loadId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "loadId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.LoadId.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withInfo" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withInfo",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithInfo.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withRaw" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithRaw.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddRecordWithReturnedRecordIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddRecordWithReturnedRecordIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AnalyzeBulkRecords invokes analyzeBulkRecords operation.
//
// Provides a means to analyze a bulk data file of records prior to loading
// it.  The records are encoded as a JSON array of JSON objects, a single
// JSON object per line in JSON-lines file format, or as a CSV with one
// record per row.  The data should be in pre-mapped format using JSON
// property names or CSV column names as described by the
// [Senzing Generic Entity Specification](https://senzing.zendesk.
// com/hc/en-us/articles/231925448-Generic-Entity-Specification).
// **SCALABILITY NOTE:** This operation can be invoked in three ways.  In
// order of increasingly better scalability these are listed below:
// 1. Standard HTTP Request/Response
// 2. HTTP Request with SSE Response (see below)
// 3. HTTP Upgrade Request for Web Sockets (see below)
// Standard HTTP Request/Response (method 1) has the worst scalability
// because a long-running operation will tie up a Web Server thread **and**
// continue until complete even if the client aborts the operation since
// no data is written back to the client until complete and therefore the
// terminated connection will not be detected.  SSE (method 2) mitigates
// the problem of detecting when a client has aborted the operation
// because periodic progress responses are written to the client and
// therefore a terminated connection will be detected.  However, the best
// way to invoke this operation is via Web Sockets (method 3) which not
// only can detect disconnection of the client, but it also upgrades the
// request to use its own thread outside the Web Server thread pool.
// **SSE NOTE:** This end-point supports "Server-sent Events" (SSE) via the
// `text/event-stream` media type.  This support is activated by adding the
// `Accept: text/event-stream` header to a request to override the
// default `application/json` media type.  Further, the end-point will behave
// similarly to its standard operation but will produce `progress` events
// at regular intervals that are equivalent to its `200` response schema.
// Upon success, the final event will be `completed` with the same response
// schema as a `200` response.  Upon failure, the final event will be
// `failed` with same `SzErrorResponse` schema as the `4xx` or `5xx`.
// **WEB SOCKETS NOTE**: If invoking via Web Sockets then the client may
// send text or binary chunks of the JSON, JSON-Lines or CSV bulk data file
// as messages.  In Web Sockets, text messages are *always* sent as UTF-8.
// If the file's character encoding is unknown then the client should send
// binary messages and the server will attempt to auto-detect the character
// encoding.  Each message should adhere to the maximum message size
// specified by the `webSocketsMessageMaxSize` property returned by the
// `GET /server-info` end-point.  The end of file is detected when the
// number of seconds specified by the `eofSendTimeout` query parameter have
// elapsed without a new message being received.
//
// POST /bulk-data/analyze
func (c *Client) AnalyzeBulkRecords(ctx context.Context, request AnalyzeBulkRecordsReq, params AnalyzeBulkRecordsParams) (AnalyzeBulkRecordsRes, error) {
	res, err := c.sendAnalyzeBulkRecords(ctx, request, params)
	_ = res
	return res, err
}

func (c *Client) sendAnalyzeBulkRecords(ctx context.Context, request AnalyzeBulkRecordsReq, params AnalyzeBulkRecordsParams) (res AnalyzeBulkRecordsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("analyzeBulkRecords"),
	}
	// Validate request before sending.
	switch request := request.(type) {
	case *AnalyzeBulkRecordsReqApplicationJSON:
		// Validation is not required for this type.
	case *AnalyzeBulkRecordsReqApplicationXJsonlines:
		// Validation is not required for this type.
	case *AnalyzeBulkRecordsReqMultipartFormData:
		// Validation is not required for this type.
	case *AnalyzeBulkRecordsReqTextCsv:
		// Validation is not required for this type.
	case *AnalyzeBulkRecordsReqTextPlain:
		// Validation is not required for this type.
	default:
		return res, errors.Errorf("unexpected request type: %T", request)
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AnalyzeBulkRecords",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/bulk-data/analyze"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "progressPeriod" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "progressPeriod",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ProgressPeriod.Get(); ok {
				return e.EncodeValue(conv.Int64ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "eofSendTimeout" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "eofSendTimeout",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EofSendTimeout.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAnalyzeBulkRecordsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAnalyzeBulkRecordsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteRecord invokes deleteRecord operation.
//
// This operation deletes a single record identified by the data source
// code and record ID in the request path.
// **NOTE:** The `withInfo` parameter will return the entity resolution
// info pertaining to the delete.  This can be used to update a search
// index or external data mart.   Additionally, Senzing API Server provides
// a means to have the "raw" entity resolution info (from the underlying
// native Senzing API) automatically sent to a messaging service such as
// those provided by Amazon SQS, Rabbit MQ or Kafka regardless of the
// `withInfo` query parameter value.
//
// DELETE /data-sources/{dataSourceCode}/records/{recordId}
func (c *Client) DeleteRecord(ctx context.Context, params DeleteRecordParams) (DeleteRecordRes, error) {
	res, err := c.sendDeleteRecord(ctx, params)
	_ = res
	return res, err
}

func (c *Client) sendDeleteRecord(ctx context.Context, params DeleteRecordParams) (res DeleteRecordRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteRecord"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteRecord",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/data-sources/"
	{
		// Encode "dataSourceCode" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "dataSourceCode",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DataSourceCode))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/records/"
	{
		// Encode "recordId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "recordId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RecordId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "loadId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "loadId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.LoadId.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withInfo" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withInfo",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithInfo.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withRaw" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithRaw.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteRecordResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FindEntityNetwork invokes findEntityNetwork operation.
//
// This operation finds the entity network around one or more entities.
// This attempts to find paths between the specified entities.  If no
// paths exist, then island networks are returned with each island network
// containing up to a specified number of related entities.  The entities
// are identified by their entity IDs or by data source code and record ID
// pairs for constituent records of those entities.
// **NOTE:** If the first entity is identified by entity ID then the
// subsequent entities must also be identified entity ID.  Similarly, if
// the first entity is identified by the data source code and record ID
// of a consistuent record then the subsequent entities must also be
// identified by the data source code and record ID of constituent records.
// **ALSO NOTE:** Bear in mind that entity ID's are transient and may be
// recycled or repurposed as new records are loaded and entities resolve,
// unresolve and re-resolve.
//
// GET /entity-networks
func (c *Client) FindEntityNetwork(ctx context.Context, params FindEntityNetworkParams) (FindEntityNetworkRes, error) {
	res, err := c.sendFindEntityNetwork(ctx, params)
	_ = res
	return res, err
}

func (c *Client) sendFindEntityNetwork(ctx context.Context, params FindEntityNetworkParams) (res FindEntityNetworkRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("findEntityNetwork"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "FindEntityNetwork",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/entity-networks"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "maxDegrees" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "maxDegrees",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.MaxDegrees.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "buildOut" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "buildOut",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.BuildOut.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "maxEntities" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "maxEntities",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.MaxEntities.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "detailLevel" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "detailLevel",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DetailLevel.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "featureMode" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "featureMode",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FeatureMode.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withFeatureStats" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withFeatureStats",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithFeatureStats.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withInternalFeatures" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withInternalFeatures",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithInternalFeatures.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "forceMinimal" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "forceMinimal",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ForceMinimal.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withRaw" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithRaw.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeFindEntityNetworkResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FindEntityPath invokes findEntityPath operation.
//
// This operation finds the path between two entities and returns a
// description of that entity path (if any) or a response indicating that
// there is no path between the entities.  The subject entities are either
// identfieid by entity ID or by data source code and record ID pairs for
// constituent records of those entities.
// **NOTE:** If the first entity is identified by entity ID then the second
// must also be identified an entity ID.  Similarly, if the first entity is
// identified by data source code and record ID then the second must also
// be identified by data source code and record ID.
// **ALSO NOTE:** Bear in mind that entity ID's are transient and may be
// recycled or repurposed as new records are loaded and entities resolve,
// unresolve and re-resolve.
//
// GET /entity-paths
func (c *Client) FindEntityPath(ctx context.Context, params FindEntityPathParams) (FindEntityPathRes, error) {
	res, err := c.sendFindEntityPath(ctx, params)
	_ = res
	return res, err
}

func (c *Client) sendFindEntityPath(ctx context.Context, params FindEntityPathParams) (res FindEntityPathRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("findEntityPath"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "FindEntityPath",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/entity-paths"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "maxDegrees" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "maxDegrees",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.MaxDegrees.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "forbidAvoided" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "forbidAvoided",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ForbidAvoided.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "s" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "s",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.S {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "detailLevel" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "detailLevel",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DetailLevel.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "featureMode" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "featureMode",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FeatureMode.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withFeatureStats" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withFeatureStats",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithFeatureStats.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withInternalFeatures" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withInternalFeatures",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithInternalFeatures.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "forceMinimal" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "forceMinimal",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ForceMinimal.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withRaw" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithRaw.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeFindEntityPathResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetActiveConfig invokes getActiveConfig operation.
//
// This operation returns the JSON configuration that is currently being
// used by the native Senzing API initialized by the running server.  No
// processing or interpretation is performed on the JSON.  This may differ
// from the registered "default configuration" which the server would
// use if no other configuration were provided.
//
// GET /configs/active
func (c *Client) GetActiveConfig(ctx context.Context) (GetActiveConfigRes, error) {
	res, err := c.sendGetActiveConfig(ctx)
	_ = res
	return res, err
}

func (c *Client) sendGetActiveConfig(ctx context.Context) (res GetActiveConfigRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getActiveConfig"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetActiveConfig",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/configs/active"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetActiveConfigResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAttributeType invokes getAttributeType operation.
//
// This operation will provide a description of a single attribute type for
// the specified attribute type code.
//
// GET /attribute-types/{attributeCode}
func (c *Client) GetAttributeType(ctx context.Context, params GetAttributeTypeParams) (GetAttributeTypeRes, error) {
	res, err := c.sendGetAttributeType(ctx, params)
	_ = res
	return res, err
}

func (c *Client) sendGetAttributeType(ctx context.Context, params GetAttributeTypeParams) (res GetAttributeTypeRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAttributeType"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetAttributeType",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/attribute-types/"
	{
		// Encode "attributeCode" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "attributeCode",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AttributeCode))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "withRaw" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithRaw.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAttributeTypeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAttributeTypes invokes getAttributeTypes operation.
//
// This operation will provide a list of attribute types that are
// configured.  The client can filter the returned list of attribute types
// using various query parameters.
//
// GET /attribute-types
func (c *Client) GetAttributeTypes(ctx context.Context, params GetAttributeTypesParams) (GetAttributeTypesRes, error) {
	res, err := c.sendGetAttributeTypes(ctx, params)
	_ = res
	return res, err
}

func (c *Client) sendGetAttributeTypes(ctx context.Context, params GetAttributeTypesParams) (res GetAttributeTypesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAttributeTypes"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetAttributeTypes",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/attribute-types"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "withInternal" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withInternal",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithInternal.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "attributeClass" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "attributeClass",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.AttributeClass.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "featureType" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "featureType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FeatureType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withRaw" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithRaw.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAttributeTypesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDataSource invokes getDataSource operation.
//
// This operation provides details on a specific data source identified
// by the data source code in the requested path.
//
// GET /data-sources/{dataSourceCode}
func (c *Client) GetDataSource(ctx context.Context, params GetDataSourceParams) (GetDataSourceRes, error) {
	res, err := c.sendGetDataSource(ctx, params)
	_ = res
	return res, err
}

func (c *Client) sendGetDataSource(ctx context.Context, params GetDataSourceParams) (res GetDataSourceRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getDataSource"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetDataSource",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/data-sources/"
	{
		// Encode "dataSourceCode" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "dataSourceCode",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DataSourceCode))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "withRaw" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithRaw.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetDataSourceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDataSources invokes getDataSources operation.
//
// This operation will provide a list of data source codes as well as a
// list of detailed descriptions of each data source.
//
// GET /data-sources
func (c *Client) GetDataSources(ctx context.Context, params GetDataSourcesParams) (GetDataSourcesRes, error) {
	res, err := c.sendGetDataSources(ctx, params)
	_ = res
	return res, err
}

func (c *Client) sendGetDataSources(ctx context.Context, params GetDataSourcesParams) (res GetDataSourcesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getDataSources"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetDataSources",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/data-sources"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "withRaw" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithRaw.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetDataSourcesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetEntityByEntityId invokes getEntityByEntityId operation.
//
// Gets the details on a resolved entity that is identified by the entity
// ID specified in the request path.
// **NOTE:** Bear in mind that entity ID's are transient and may be
// recycled or repurposed as new records are loaded and entities resolve,
// unresolve and re-resolve.  An alternative way to identify an entity is
// by one of its constituent records using
// `GET /data-sources/{dataSourceCode}/records/{recordId}/entity`.
//
// GET /entities/{entityId}
func (c *Client) GetEntityByEntityId(ctx context.Context, params GetEntityByEntityIdParams) (GetEntityByEntityIdRes, error) {
	res, err := c.sendGetEntityByEntityId(ctx, params)
	_ = res
	return res, err
}

func (c *Client) sendGetEntityByEntityId(ctx context.Context, params GetEntityByEntityIdParams) (res GetEntityByEntityIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getEntityByEntityId"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetEntityByEntityId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/entities/"
	{
		// Encode "entityId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "entityId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int64ToString(params.EntityId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "detailLevel" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "detailLevel",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DetailLevel.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "featureMode" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "featureMode",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FeatureMode.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withFeatureStats" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withFeatureStats",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithFeatureStats.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withInternalFeatures" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withInternalFeatures",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithInternalFeatures.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "forceMinimal" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "forceMinimal",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ForceMinimal.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withRelated" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withRelated",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithRelated.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withRaw" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithRaw.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetEntityByEntityIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetEntityByRecordId invokes getEntityByRecordId operation.
//
// Gets the details on a resolved entity that contains the record
// identified by the data source code and record ID in the specified
// request path.
//
// GET /data-sources/{dataSourceCode}/records/{recordId}/entity
func (c *Client) GetEntityByRecordId(ctx context.Context, params GetEntityByRecordIdParams) (GetEntityByRecordIdRes, error) {
	res, err := c.sendGetEntityByRecordId(ctx, params)
	_ = res
	return res, err
}

func (c *Client) sendGetEntityByRecordId(ctx context.Context, params GetEntityByRecordIdParams) (res GetEntityByRecordIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getEntityByRecordId"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetEntityByRecordId",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/data-sources/"
	{
		// Encode "dataSourceCode" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "dataSourceCode",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DataSourceCode))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/records/"
	{
		// Encode "recordId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "recordId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RecordId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/entity"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "detailLevel" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "detailLevel",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DetailLevel.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "featureMode" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "featureMode",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FeatureMode.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withFeatureStats" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withFeatureStats",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithFeatureStats.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withInternalFeatures" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withInternalFeatures",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithInternalFeatures.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "forceMinimal" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "forceMinimal",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ForceMinimal.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withRelated" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withRelated",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithRelated.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withRaw" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithRaw.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetEntityByRecordIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetRecord invokes getRecord operation.
//
// Gets details on a specific entity record identified by the data source
// code and record ID specified in the request path.
//
// GET /data-sources/{dataSourceCode}/records/{recordId}
func (c *Client) GetRecord(ctx context.Context, params GetRecordParams) (GetRecordRes, error) {
	res, err := c.sendGetRecord(ctx, params)
	_ = res
	return res, err
}

func (c *Client) sendGetRecord(ctx context.Context, params GetRecordParams) (res GetRecordRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getRecord"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetRecord",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/data-sources/"
	{
		// Encode "dataSourceCode" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "dataSourceCode",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DataSourceCode))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/records/"
	{
		// Encode "recordId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "recordId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RecordId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "withRaw" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithRaw.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetRecordResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetServerInfo invokes getServerInfo operation.
//
// This operation will provides server information describing the options
// with which the server was started.  This can be used to determine if
// the admin operations are enabled or if only read operations may be
// invoked.  This also allows the client to know the maximum message size
// for Web Sockets communication.
//
// GET /server-info
func (c *Client) GetServerInfo(ctx context.Context) (GetServerInfoRes, error) {
	res, err := c.sendGetServerInfo(ctx)
	_ = res
	return res, err
}

func (c *Client) sendGetServerInfo(ctx context.Context) (res GetServerInfoRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getServerInfo"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetServerInfo",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/server-info"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetServerInfoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTemplateConfig invokes getTemplateConfig operation.
//
// This operation returns a template base JSON configuration that can be
// modified or customized by the caller.  The returned template is
// according to the underlying native Senzing API and may change between
// version upgrades to Senzing.  No processing or interpretation is
// performed on the JSON.  This will likely differ from the registered
// "default configuration" or currently "active configuration" being used
// by the running API server.
//
// GET /configs/template
func (c *Client) GetTemplateConfig(ctx context.Context) (GetTemplateConfigRes, error) {
	res, err := c.sendGetTemplateConfig(ctx)
	_ = res
	return res, err
}

func (c *Client) sendGetTemplateConfig(ctx context.Context) (res GetTemplateConfigRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getTemplateConfig"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetTemplateConfig",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/configs/template"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetTemplateConfigResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVirtualEntityByRecordIds invokes getVirtualEntityByRecordIds operation.
//
// This operation simulates the resolution of the one or more specified
// records into a single entity and returns the simulated "virtual"
// entity.  The subject records are identified by data source code and
// record ID pairs.
//
// GET /virtual-entities
func (c *Client) GetVirtualEntityByRecordIds(ctx context.Context, params GetVirtualEntityByRecordIdsParams) (GetVirtualEntityByRecordIdsRes, error) {
	res, err := c.sendGetVirtualEntityByRecordIds(ctx, params)
	_ = res
	return res, err
}

func (c *Client) sendGetVirtualEntityByRecordIds(ctx context.Context, params GetVirtualEntityByRecordIdsParams) (res GetVirtualEntityByRecordIdsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getVirtualEntityByRecordIds"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetVirtualEntityByRecordIds",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/virtual-entities"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "detailLevel" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "detailLevel",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DetailLevel.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "featureMode" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "featureMode",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FeatureMode.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withFeatureStats" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withFeatureStats",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithFeatureStats.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withInternalFeatures" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withInternalFeatures",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithInternalFeatures.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "forceMinimal" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "forceMinimal",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ForceMinimal.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withRaw" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithRaw.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetVirtualEntityByRecordIdsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// Heartbeat invokes heartbeat operation.
//
// The heartbeat operation can be used to ensure that the HTTP server is
// indeed running, but this operation does not call upon the underlying
// native Senzing API and therefore does not ensure the Senzing
// initialization or configuration is valid.
//
// GET /heartbeat
func (c *Client) Heartbeat(ctx context.Context) (*SzBaseResponse, error) {
	res, err := c.sendHeartbeat(ctx)
	_ = res
	return res, err
}

func (c *Client) sendHeartbeat(ctx context.Context) (res *SzBaseResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("heartbeat"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "Heartbeat",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/heartbeat"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeHeartbeatResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HowEntityByEntityID invokes howEntityByEntityID operation.
//
// This operation provides an anlysis of how the records in an entity
// resolved.  The subject entity is identified by the entity ID in the
// request path.
// **NOTE:** Bear in mind that entity ID's are transient and may be
// recycled or repurposed as new records are loaded and entities resolve,
// unresolve and re-resolve.  An alternative way to identify an entity is
// by one of its constituent records using
// `GET /data-sources/{dataSourceCode}/records/{recordId}/entity/how`.
//
// GET /entities/{entityId}/how
func (c *Client) HowEntityByEntityID(ctx context.Context, params HowEntityByEntityIDParams) (HowEntityByEntityIDRes, error) {
	res, err := c.sendHowEntityByEntityID(ctx, params)
	_ = res
	return res, err
}

func (c *Client) sendHowEntityByEntityID(ctx context.Context, params HowEntityByEntityIDParams) (res HowEntityByEntityIDRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("howEntityByEntityID"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "HowEntityByEntityID",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/entities/"
	{
		// Encode "entityId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "entityId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int64ToString(params.EntityId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/how"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "withRaw" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithRaw.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeHowEntityByEntityIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HowEntityByRecordID invokes howEntityByRecordID operation.
//
// This operation provides an anlysis of how the records in an entity
// resolved.  The subject entity is the one containing the record
// identified by the data source code and record ID in the request path.
//
// GET /data-sources/{dataSourceCode}/records/{recordId}/entity/how
func (c *Client) HowEntityByRecordID(ctx context.Context, params HowEntityByRecordIDParams) (HowEntityByRecordIDRes, error) {
	res, err := c.sendHowEntityByRecordID(ctx, params)
	_ = res
	return res, err
}

func (c *Client) sendHowEntityByRecordID(ctx context.Context, params HowEntityByRecordIDParams) (res HowEntityByRecordIDRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("howEntityByRecordID"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "HowEntityByRecordID",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/data-sources/"
	{
		// Encode "dataSourceCode" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "dataSourceCode",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DataSourceCode))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/records/"
	{
		// Encode "recordId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "recordId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RecordId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/entity/how"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "withRaw" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithRaw.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeHowEntityByRecordIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// License invokes license operation.
//
// This operation will obtain license information for the underlying
// native Senzing API.
//
// GET /license
func (c *Client) License(ctx context.Context, params LicenseParams) (LicenseRes, error) {
	res, err := c.sendLicense(ctx, params)
	_ = res
	return res, err
}

func (c *Client) sendLicense(ctx context.Context, params LicenseParams) (res LicenseRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("license"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "License",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/license"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "withRaw" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithRaw.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeLicenseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LoadBulkRecords invokes loadBulkRecords operation.
//
// Provides a means to load a bulk data file of records.  The records are
// encoded as a JSON array of JSON objects, a single JSON object per line
// in JSON-lines file format, or as a CSV with one record per row.  The
// data should be in pre-mapped format using JSON property names or CSV
// column names as described by the
// [Senzing Generic Entity Specification](https://senzing.zendesk.
// com/hc/en-us/articles/231925448-Generic-Entity-Specification).
// **SCALABILITY NOTE:** This operation can be invoked in three ways.  In
// order of increasingly better scalability these are listed below:
// 1. Standard HTTP Request/Response
// 2. HTTP Request with SSE Response (see below)
// 3. HTTP Upgrade Request for Web Sockets (see below)
// Standard HTTP Request/Response (method 1) has the worst scalability
// because a long-running operation will tie up a Web Server thread **and**
// continue until complete even if the client aborts the operation since
// no data is written back to the client until complete and therefore the
// terminated connection will not be detected.  SSE (method 2) mitigates
// the problem of detecting when a client has aborted the operation
// because periodic progress responses are written to the client and
// therefore a terminated connection will be detected.  However, the best
// way to invoke this operation is via Web Sockets (method 3) which not
// only can detect disconnection of the client, but it also upgrades the
// request to use its own thread outside the Web Server thread pool.
// **SSE NOTE:** This end-point supports "Server-sent Events" (SSE) via the
// `text/event-stream` media type.  This support is activated by adding the
// `Accept: text/event-stream` header to a request to override the
// default `application/json` media type.  Further, the end-point will behave
// similarly to its standard operation but will produce `progress` events
// at regular intervals that are equivalent to its `200` response schema.
// Upon success, the final event will be `completed` with the same response
// schema as a `200` response.  Upon failure, the final event will be
// `failed` with same `SzErrorResponse` schema as the `4xx` or `5xx`.
// **WEB SOCKETS NOTE**: If invoking via Web Sockets then the client may
// send text or binary chunks of the JSON, JSON-Lines or CSV bulk data file
// as messages.  In Web Sockets, text messages are *always* sent as UTF-8.
// If the file's character encoding is unknown then the client should send
// binary messages and the server will attempt to auto-detect the character
// encoding.  Each message should adhere to the maximum message size
// specified by the `webSocketsMessageMaxSize` property returned by the
// `GET /server-info` end-point.  The end of file is detected when the
// number of seconds specified by the `eofSendTimeout` query parameter have
// elapsed without a new message being received.
//
// POST /bulk-data/load
func (c *Client) LoadBulkRecords(ctx context.Context, request LoadBulkRecordsReq, params LoadBulkRecordsParams) (LoadBulkRecordsRes, error) {
	res, err := c.sendLoadBulkRecords(ctx, request, params)
	_ = res
	return res, err
}

func (c *Client) sendLoadBulkRecords(ctx context.Context, request LoadBulkRecordsReq, params LoadBulkRecordsParams) (res LoadBulkRecordsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("loadBulkRecords"),
	}
	// Validate request before sending.
	switch request := request.(type) {
	case *LoadBulkRecordsReqApplicationJSON:
		// Validation is not required for this type.
	case *LoadBulkRecordsReqApplicationXJsonlines:
		// Validation is not required for this type.
	case *LoadBulkRecordsReqMultipartFormData:
		// Validation is not required for this type.
	case *LoadBulkRecordsReqTextCsv:
		// Validation is not required for this type.
	case *LoadBulkRecordsReqTextPlain:
		// Validation is not required for this type.
	default:
		return res, errors.Errorf("unexpected request type: %T", request)
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "LoadBulkRecords",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/bulk-data/load"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "dataSource" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "dataSource",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DataSource.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "mapDataSources" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "mapDataSources",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.MapDataSources.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "mapDataSource" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "mapDataSource",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.MapDataSource {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "maxFailures" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "maxFailures",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.MaxFailures.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "progressPeriod" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "progressPeriod",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ProgressPeriod.Get(); ok {
				return e.EncodeValue(conv.Int64ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "eofSendTimeout" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "eofSendTimeout",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EofSendTimeout.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeLoadBulkRecordsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeLoadBulkRecordsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OpenApiSpecification invokes openApiSpecification operation.
//
// This operation can be used to obtain the Open API specification in JSON
// format.  The specification can either be the `data` field of a standard
// response (i.e.: a response with a `meta`, `links` and `data` field) or
// as raw format where the root JSON document is the Open API specification
// JSON.
//
// GET /specifications/open-api
func (c *Client) OpenApiSpecification(ctx context.Context) (OpenApiSpecificationOKDefault, error) {
	res, err := c.sendOpenApiSpecification(ctx)
	_ = res
	return res, err
}

func (c *Client) sendOpenApiSpecification(ctx context.Context) (res OpenApiSpecificationOKDefault, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("openApiSpecification"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OpenApiSpecification",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/specifications/open-api"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOpenApiSpecificationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReevaluateEntity invokes reevaluateEntity operation.
//
// Reevaluates an entity identified by the entity ID specified via the
// `entityId` query parameter.
// **NOTE:** The `withInfo` parameter will return the entity resolution
// info pertaining to the reevaluation.  This can be used to update a
// search index or external data mart.   Additionally, Senzing API Server
// provides a means to have the "raw" entity resolution info (from the
// underlying native Senzing API) automatically sent to a messaging service
// such as those provided by Amazon SQS, Rabbit MQ or Kafka regardless of
// the `withInfo` query parameter value.
// **ALSO NOTE:** Bear in mind that entity ID's are transient and may be
// recycled or repurposed as new records are loaded and entities resolve,
// unresolve and re-resolve.
//
// POST /reevaluate-entity
func (c *Client) ReevaluateEntity(ctx context.Context, params ReevaluateEntityParams) (ReevaluateEntityRes, error) {
	res, err := c.sendReevaluateEntity(ctx, params)
	_ = res
	return res, err
}

func (c *Client) sendReevaluateEntity(ctx context.Context, params ReevaluateEntityParams) (res ReevaluateEntityRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reevaluateEntity"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReevaluateEntity",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/reevaluate-entity"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "entityId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "entityId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.Int64ToString(params.EntityId))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withInfo" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withInfo",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithInfo.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withRaw" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithRaw.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReevaluateEntityResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReevaluateRecord invokes reevaluateRecord operation.
//
// This operation reevaluates a single record identified by the data source
// code and record ID in the request path.
// **NOTE:** The `withInfo` parameter will return the entity resolution
// info pertaining to the reevaluation.  This can be used to update a
// search index or external data mart.   Additionally, Senzing API Server
// provides a means to have the "raw" entity resolution info (from the
// underlying native Senzing API) automatically sent to a messaging service
// such as those provided by Amazon SQS, Rabbit MQ or Kafka regardless of
// the `withInfo` query parameter value.
//
// POST /data-sources/{dataSourceCode}/records/{recordId}/reevaluate
func (c *Client) ReevaluateRecord(ctx context.Context, params ReevaluateRecordParams) (ReevaluateRecordRes, error) {
	res, err := c.sendReevaluateRecord(ctx, params)
	_ = res
	return res, err
}

func (c *Client) sendReevaluateRecord(ctx context.Context, params ReevaluateRecordParams) (res ReevaluateRecordRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reevaluateRecord"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ReevaluateRecord",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/data-sources/"
	{
		// Encode "dataSourceCode" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "dataSourceCode",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DataSourceCode))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/records/"
	{
		// Encode "recordId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "recordId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RecordId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/reevaluate"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "withInfo" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withInfo",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithInfo.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withRaw" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithRaw.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReevaluateRecordResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// Root invokes root operation.
//
// The root operation can be used to ensure that the HTTP server is
// indeed running, but this operation does not call upon the underlying
// native Senzing API and therefore does not ensure the Senzing
// initialization or configuration is valid.
//
// GET /
func (c *Client) Root(ctx context.Context) (*SzBaseResponse, error) {
	res, err := c.sendRoot(ctx)
	_ = res
	return res, err
}

func (c *Client) sendRoot(ctx context.Context) (res *SzBaseResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("root"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "Root",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRootResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SearchEntitiesByGet invokes searchEntitiesByGet operation.
//
// This operation finds all entities that would resolve or relate to the
// search candidate features specified by the `attr` and/or `attrs` query
// parameters.  The search candidate features are treated as if they
// belonged to an inbound record being loaded, thus the attribute names are
// given by the [Senzing Generic Entity Specification](https://senzing.zendesk.
// com/hc/en-us/articles/231925448-Generic-Entity-Specification).
// If including the search candidate features as query parameters presents
// privacy concerns due to sensitivity of the data, they can alternately
// be sent in the request body using the `POST /search-entities` endpoint.
// **NOTE:** This operation differs from a keyword search in that it uses
// deterministic entity resolution rules to determine the result set.  This
// means that features that are considered "generic" (i.e.: overly common)
// will be ignored just as they are during entity resolution and will not
// yield search results.  For example, searching on a gender by itself will
// return no results rather than half of all entities.  Similarly, a phone
// number such as `555-1212` may yield no results.
//
// GET /entities
func (c *Client) SearchEntitiesByGet(ctx context.Context, params SearchEntitiesByGetParams) (SearchEntitiesByGetRes, error) {
	res, err := c.sendSearchEntitiesByGet(ctx, params)
	_ = res
	return res, err
}

func (c *Client) sendSearchEntitiesByGet(ctx context.Context, params SearchEntitiesByGetParams) (res SearchEntitiesByGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("searchEntitiesByGet"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "SearchEntitiesByGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/entities"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "attrs" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "attrs",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Attrs.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "attr" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "attr",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Attr {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "includeOnly" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "includeOnly",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.IncludeOnly {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "detailLevel" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "detailLevel",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DetailLevel.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "featureMode" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "featureMode",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FeatureMode.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withFeatureStats" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withFeatureStats",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithFeatureStats.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withInternalFeatures" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withInternalFeatures",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithInternalFeatures.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "forceMinimal" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "forceMinimal",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ForceMinimal.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withRelationships" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withRelationships",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithRelationships.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withRaw" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithRaw.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSearchEntitiesByGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SearchEntitiesByPost invokes searchEntitiesByPost operation.
//
// This operation finds all entities that would resolve or relate to the
// search candidate features specified in JSON request body.  The search
// candidate features are treated as if they belonged to an inbound record
// being loaded.  The JSON format of the request body is defined by the
// [Senzing Generic Entity Specification](https://senzing.zendesk.
// com/hc/en-us/articles/231925448-Generic-Entity-Specification).
// This operation is similar to the `GET /entities` endpoint in function
// except that it provides a means to avoid specifying potentially
// sensitive data in query parameters, but instead in the request body.
// **NOTE:** This operation differs from a keyword search in that it uses
// deterministic entity resolution rules to determine the result set.  This
// means that features that are considered "generic" (i.e.: overly common)
// will be ignored just as they are during entity resolution and will not
// yield search results.  For example, searching on a gender by itself will
// return no results rather than half of all entities.  Similarly, a phone
// number such as `555-1212` may yield no results.
//
// POST /search-entities
func (c *Client) SearchEntitiesByPost(ctx context.Context, request SearchEntitiesByPostReq, params SearchEntitiesByPostParams) (SearchEntitiesByPostRes, error) {
	res, err := c.sendSearchEntitiesByPost(ctx, request, params)
	_ = res
	return res, err
}

func (c *Client) sendSearchEntitiesByPost(ctx context.Context, request SearchEntitiesByPostReq, params SearchEntitiesByPostParams) (res SearchEntitiesByPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("searchEntitiesByPost"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "SearchEntitiesByPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/search-entities"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "includeOnly" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "includeOnly",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.IncludeOnly {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "detailLevel" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "detailLevel",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DetailLevel.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "featureMode" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "featureMode",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FeatureMode.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withFeatureStats" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withFeatureStats",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithFeatureStats.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withInternalFeatures" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withInternalFeatures",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithInternalFeatures.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "forceMinimal" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "forceMinimal",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ForceMinimal.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withRelationships" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withRelationships",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithRelationships.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withRaw" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithRaw.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSearchEntitiesByPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSearchEntitiesByPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// Version invokes version operation.
//
// This operation will obtain the full version information for the server.
// Much of the same information is available in the `meta` segment of
// every JSON response.
//
// GET /version
func (c *Client) Version(ctx context.Context, params VersionParams) (VersionRes, error) {
	res, err := c.sendVersion(ctx, params)
	_ = res
	return res, err
}

func (c *Client) sendVersion(ctx context.Context, params VersionParams) (res VersionRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("version"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "Version",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/version"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "withRaw" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithRaw.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeVersionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// WhyEntities invokes whyEntities operation.
//
// This operation provides an anlysis of why two entities related, did not
// relate or did not resolve.  The entities are identified either by
// entity ID's or by data source code and record ID pairs for constituent
// records of those entities.
// **NOTE:** If the first entity is identified by entity ID then the second
// must also be identified an entity ID.  Similarly, if the first entity is
// identified by data source code and record ID then the second must also
// be identified by data source code and record ID.
// **ALSO NOTE:** Bear in mind that entity ID's are transient and may be
// recycled or repurposed as new records are loaded and entities resolve,
// unresolve and re-resolve.
//
// GET /why/entities
func (c *Client) WhyEntities(ctx context.Context, params WhyEntitiesParams) (WhyEntitiesRes, error) {
	res, err := c.sendWhyEntities(ctx, params)
	_ = res
	return res, err
}

func (c *Client) sendWhyEntities(ctx context.Context, params WhyEntitiesParams) (res WhyEntitiesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("whyEntities"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "WhyEntities",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/why/entities"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "entity1" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "entity1",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Entity1))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "entity2" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "entity2",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Entity2))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withRelationships" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withRelationships",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithRelationships.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withFeatureStats" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withFeatureStats",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithFeatureStats.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withInternalFeatures" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withInternalFeatures",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithInternalFeatures.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "detailLevel" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "detailLevel",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DetailLevel.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "featureMode" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "featureMode",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FeatureMode.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "forceMinimal" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "forceMinimal",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ForceMinimal.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withRaw" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithRaw.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeWhyEntitiesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// WhyEntityByEntityID invokes whyEntityByEntityID operation.
//
// This operation provides an anlysis of why the records in an entity
// resolved.  The subject entity is identified by the entity ID in the
// request path.
// **NOTE:** Bear in mind that entity ID's are transient and may be
// recycled or repurposed as new records are loaded and entities resolve,
// unresolve and re-resolve.  An alternative way to identify an entity is
// by one of its constituent records using
// `GET /data-sources/{dataSourceCode}/records/{recordId}/entity/why`.
//
// GET /entities/{entityId}/why
func (c *Client) WhyEntityByEntityID(ctx context.Context, params WhyEntityByEntityIDParams) (WhyEntityByEntityIDRes, error) {
	res, err := c.sendWhyEntityByEntityID(ctx, params)
	_ = res
	return res, err
}

func (c *Client) sendWhyEntityByEntityID(ctx context.Context, params WhyEntityByEntityIDParams) (res WhyEntityByEntityIDRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("whyEntityByEntityID"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "WhyEntityByEntityID",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/entities/"
	{
		// Encode "entityId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "entityId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int64ToString(params.EntityId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/why"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "withRelationships" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withRelationships",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithRelationships.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withFeatureStats" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withFeatureStats",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithFeatureStats.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withInternalFeatures" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withInternalFeatures",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithInternalFeatures.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "detailLevel" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "detailLevel",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DetailLevel.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "featureMode" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "featureMode",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FeatureMode.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "forceMinimal" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "forceMinimal",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ForceMinimal.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withRaw" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithRaw.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeWhyEntityByEntityIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// WhyEntityByRecordID invokes whyEntityByRecordID operation.
//
// This operation provides an anlysis of why the records in an entity
// resolved.  The subject entity is the one containing the record
// identified by the data source code and record ID in the request path.
//
// GET /data-sources/{dataSourceCode}/records/{recordId}/entity/why
func (c *Client) WhyEntityByRecordID(ctx context.Context, params WhyEntityByRecordIDParams) (WhyEntityByRecordIDRes, error) {
	res, err := c.sendWhyEntityByRecordID(ctx, params)
	_ = res
	return res, err
}

func (c *Client) sendWhyEntityByRecordID(ctx context.Context, params WhyEntityByRecordIDParams) (res WhyEntityByRecordIDRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("whyEntityByRecordID"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "WhyEntityByRecordID",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/data-sources/"
	{
		// Encode "dataSourceCode" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "dataSourceCode",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DataSourceCode))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/records/"
	{
		// Encode "recordId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "recordId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RecordId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/entity/why"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "withRelationships" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withRelationships",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithRelationships.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withFeatureStats" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withFeatureStats",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithFeatureStats.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withInternalFeatures" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withInternalFeatures",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithInternalFeatures.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "detailLevel" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "detailLevel",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DetailLevel.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "featureMode" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "featureMode",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FeatureMode.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "forceMinimal" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "forceMinimal",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ForceMinimal.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withRaw" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithRaw.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeWhyEntityByRecordIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// WhyRecords invokes whyRecords operation.
//
// This operation provides an anlysis of two records identified by data
// source code and record ID in respective qeury parameters resolved or
// did not resolve.
//
// GET /why/records
func (c *Client) WhyRecords(ctx context.Context, params WhyRecordsParams) (WhyRecordsRes, error) {
	res, err := c.sendWhyRecords(ctx, params)
	_ = res
	return res, err
}

func (c *Client) sendWhyRecords(ctx context.Context, params WhyRecordsParams) (res WhyRecordsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("whyRecords"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "WhyRecords",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/why/records"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "dataSource1" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "dataSource1",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.DataSource1))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "recordId1" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "recordId1",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.RecordId1))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "dataSource2" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "dataSource2",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.DataSource2))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "recordId2" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "recordId2",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.RecordId2))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withRelationships" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withRelationships",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithRelationships.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withFeatureStats" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withFeatureStats",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithFeatureStats.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withInternalFeatures" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withInternalFeatures",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithInternalFeatures.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "detailLevel" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "detailLevel",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DetailLevel.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "featureMode" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "featureMode",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FeatureMode.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "forceMinimal" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "forceMinimal",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ForceMinimal.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withRaw" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithRaw.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeWhyRecordsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
