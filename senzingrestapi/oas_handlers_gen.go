// Code generated by ogen, DO NOT EDIT.

package senzingrestapi

import (
	"context"
	"net/http"
	"time"

	"github.com/go-faster/errors"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.19.0"
	"go.opentelemetry.io/otel/trace"

	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/middleware"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/otelogen"
)

// handleAddDataSourcesRequest handles addDataSources operation.
//
// Obtains the current default configuration, adds the specified data
// sources and sets the modified configuration as the new default
// configuration -- returning the set of all configured data sources.
// **NOTE:** This operation may not be allowed.  Some conditions that
// might cause this operation to be forbidden are:
// 1. The server does not have administrative functions enabled.
// 2. The server is running in "read-only" mode.
// 3. The server is started with a file-based configuration specified
// by `G2CONFIGFILE` property in the initialziation parameters.
// 4. The server is started with a specific configuration ID and
// therefore cannot modify the configuration and change to a new
// configuration.
//
// POST /data-sources
func (s *Server) handleAddDataSourcesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addDataSources"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/data-sources"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AddDataSources",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AddDataSources",
			ID:   "addDataSources",
		}
	)
	params, err := decodeAddDataSourcesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAddDataSourcesRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response AddDataSourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AddDataSources",
			OperationSummary: "Adds one or more new data sources to the current default configuration and reinitializes with the newly modified configuration.",
			OperationID:      "addDataSources",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "dataSource",
					In:   "query",
				}: params.DataSource,
				{
					Name: "withRaw",
					In:   "query",
				}: params.WithRaw,
			},
			Raw: r,
		}

		type (
			Request  = AddDataSourcesReq
			Params   = AddDataSourcesParams
			Response = AddDataSourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAddDataSourcesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AddDataSources(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AddDataSources(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAddDataSourcesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAddRecordRequest handles addRecord operation.
//
// This operation loads a single record using the data source identified by
// the data source code in the request path.  The record will be identified
// uniquely within the data source by the record ID provided in the request
// path.  The provided record in the request body is described in JSON
// using the [Senzing Generic Entity Specification](https://senzing.zendesk.
// com/hc/en-us/articles/231925448-Generic-Entity-Specification).
// The provided JSON record may omit the `RECORD_ID`, but if it contains a
// `RECORD_ID` then it **must** match the record ID provided on the request
// path.  The record ID is returned as part of the response.
// **NOTE:** The `withInfo` parameter will return the entity resolution
// info pertaining to the load.  This can be used to update a search index
// or external data mart.   Additionally, Senzing API Server provides a
// means to have the "raw" entity resolution info (from the underlying
// native Senzing API) automatically sent to a messaging service such as
// those provided by Amazon SQS, Rabbit MQ or Kafka regardless of the
// `withInfo` query parameter value.
//
// PUT /data-sources/{dataSourceCode}/records/{recordId}
func (s *Server) handleAddRecordRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addRecord"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/data-sources/{dataSourceCode}/records/{recordId}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AddRecord",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AddRecord",
			ID:   "addRecord",
		}
	)
	params, err := decodeAddRecordParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAddRecordRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response AddRecordRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AddRecord",
			OperationSummary: "Load a new record or replace a record in a data source with a specific record ID.",
			OperationID:      "addRecord",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "dataSourceCode",
					In:   "path",
				}: params.DataSourceCode,
				{
					Name: "recordId",
					In:   "path",
				}: params.RecordId,
				{
					Name: "loadId",
					In:   "query",
				}: params.LoadId,
				{
					Name: "withInfo",
					In:   "query",
				}: params.WithInfo,
				{
					Name: "withRaw",
					In:   "query",
				}: params.WithRaw,
			},
			Raw: r,
		}

		type (
			Request  = AddRecordReq
			Params   = AddRecordParams
			Response = AddRecordRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAddRecordParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AddRecord(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AddRecord(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAddRecordResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAddRecordWithReturnedRecordIdRequest handles addRecordWithReturnedRecordId operation.
//
// This operation loads a single record using the data source identified by
// the data source code in the request path.  The provided record in the
// request body is described in JSON using the
// [Senzing Generic Entity Specification](https://senzing.zendesk.
// com/hc/en-us/articles/231925448-Generic-Entity-Specification).
// The provided record may contain a `RECORD_ID` to identify it uniquely
// among other records in the same data source, but if it does not then a
// record ID will be automatically generated.  The record ID is returned
// as part of the response.
// **NOTE:** The `withInfo` parameter will return the entity resolution
// info pertaining to the load.  This can be used to update a search index
// or external data mart.   Additionally, Senzing API Server provides a
// means to have the "raw" entity resolution info (from the underlying
// native Senzing API) automatically sent to a messaging service such as
// those provided by Amazon SQS, Rabbit MQ or Kafka regardless of the
// `withInfo` query parameter value.
//
// POST /data-sources/{dataSourceCode}/records
func (s *Server) handleAddRecordWithReturnedRecordIdRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addRecordWithReturnedRecordId"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/data-sources/{dataSourceCode}/records"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AddRecordWithReturnedRecordId",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AddRecordWithReturnedRecordId",
			ID:   "addRecordWithReturnedRecordId",
		}
	)
	params, err := decodeAddRecordWithReturnedRecordIdParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAddRecordWithReturnedRecordIdRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response AddRecordWithReturnedRecordIdRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AddRecordWithReturnedRecordId",
			OperationSummary: "Load a new record specified in a data source with either an auto-generated record ID or a `RECORD_ID` specified in the payload.",
			OperationID:      "addRecordWithReturnedRecordId",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "dataSourceCode",
					In:   "path",
				}: params.DataSourceCode,
				{
					Name: "loadId",
					In:   "query",
				}: params.LoadId,
				{
					Name: "withInfo",
					In:   "query",
				}: params.WithInfo,
				{
					Name: "withRaw",
					In:   "query",
				}: params.WithRaw,
			},
			Raw: r,
		}

		type (
			Request  = AddRecordWithReturnedRecordIdReq
			Params   = AddRecordWithReturnedRecordIdParams
			Response = AddRecordWithReturnedRecordIdRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAddRecordWithReturnedRecordIdParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AddRecordWithReturnedRecordId(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AddRecordWithReturnedRecordId(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAddRecordWithReturnedRecordIdResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAnalyzeBulkRecordsRequest handles analyzeBulkRecords operation.
//
// Provides a means to analyze a bulk data file of records prior to loading
// it.  The records are encoded as a JSON array of JSON objects, a single
// JSON object per line in JSON-lines file format, or as a CSV with one
// record per row.  The data should be in pre-mapped format using JSON
// property names or CSV column names as described by the
// [Senzing Generic Entity Specification](https://senzing.zendesk.
// com/hc/en-us/articles/231925448-Generic-Entity-Specification).
// **SCALABILITY NOTE:** This operation can be invoked in three ways.  In
// order of increasingly better scalability these are listed below:
// 1. Standard HTTP Request/Response
// 2. HTTP Request with SSE Response (see below)
// 3. HTTP Upgrade Request for Web Sockets (see below)
// Standard HTTP Request/Response (method 1) has the worst scalability
// because a long-running operation will tie up a Web Server thread **and**
// continue until complete even if the client aborts the operation since
// no data is written back to the client until complete and therefore the
// terminated connection will not be detected.  SSE (method 2) mitigates
// the problem of detecting when a client has aborted the operation
// because periodic progress responses are written to the client and
// therefore a terminated connection will be detected.  However, the best
// way to invoke this operation is via Web Sockets (method 3) which not
// only can detect disconnection of the client, but it also upgrades the
// request to use its own thread outside the Web Server thread pool.
// **SSE NOTE:** This end-point supports "Server-sent Events" (SSE) via the
// `text/event-stream` media type.  This support is activated by adding the
// `Accept: text/event-stream` header to a request to override the
// default `application/json` media type.  Further, the end-point will behave
// similarly to its standard operation but will produce `progress` events
// at regular intervals that are equivalent to its `200` response schema.
// Upon success, the final event will be `completed` with the same response
// schema as a `200` response.  Upon failure, the final event will be
// `failed` with same `SzErrorResponse` schema as the `4xx` or `5xx`.
// **WEB SOCKETS NOTE**: If invoking via Web Sockets then the client may
// send text or binary chunks of the JSON, JSON-Lines or CSV bulk data file
// as messages.  In Web Sockets, text messages are *always* sent as UTF-8.
// If the file's character encoding is unknown then the client should send
// binary messages and the server will attempt to auto-detect the character
// encoding.  Each message should adhere to the maximum message size
// specified by the `webSocketsMessageMaxSize` property returned by the
// `GET /server-info` end-point.  The end of file is detected when the
// number of seconds specified by the `eofSendTimeout` query parameter have
// elapsed without a new message being received.
//
// POST /bulk-data/analyze
func (s *Server) handleAnalyzeBulkRecordsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("analyzeBulkRecords"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/bulk-data/analyze"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AnalyzeBulkRecords",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AnalyzeBulkRecords",
			ID:   "analyzeBulkRecords",
		}
	)
	params, err := decodeAnalyzeBulkRecordsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAnalyzeBulkRecordsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response AnalyzeBulkRecordsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AnalyzeBulkRecords",
			OperationSummary: "Analyze a bulk data set of records. (Supports SSE / Supports Web Sockets)",
			OperationID:      "analyzeBulkRecords",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "progressPeriod",
					In:   "query",
				}: params.ProgressPeriod,
				{
					Name: "eofSendTimeout",
					In:   "query",
				}: params.EofSendTimeout,
			},
			Raw: r,
		}

		type (
			Request  = AnalyzeBulkRecordsReq
			Params   = AnalyzeBulkRecordsParams
			Response = AnalyzeBulkRecordsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAnalyzeBulkRecordsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AnalyzeBulkRecords(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AnalyzeBulkRecords(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAnalyzeBulkRecordsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleDeleteRecordRequest handles deleteRecord operation.
//
// This operation deletes a single record identified by the data source
// code and record ID in the request path.
// **NOTE:** The `withInfo` parameter will return the entity resolution
// info pertaining to the delete.  This can be used to update a search
// index or external data mart.   Additionally, Senzing API Server provides
// a means to have the "raw" entity resolution info (from the underlying
// native Senzing API) automatically sent to a messaging service such as
// those provided by Amazon SQS, Rabbit MQ or Kafka regardless of the
// `withInfo` query parameter value.
//
// DELETE /data-sources/{dataSourceCode}/records/{recordId}
func (s *Server) handleDeleteRecordRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteRecord"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/data-sources/{dataSourceCode}/records/{recordId}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "DeleteRecord",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "DeleteRecord",
			ID:   "deleteRecord",
		}
	)
	params, err := decodeDeleteRecordParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response DeleteRecordRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "DeleteRecord",
			OperationSummary: "Delete a record given its data source and record ID.",
			OperationID:      "deleteRecord",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "dataSourceCode",
					In:   "path",
				}: params.DataSourceCode,
				{
					Name: "recordId",
					In:   "path",
				}: params.RecordId,
				{
					Name: "loadId",
					In:   "query",
				}: params.LoadId,
				{
					Name: "withInfo",
					In:   "query",
				}: params.WithInfo,
				{
					Name: "withRaw",
					In:   "query",
				}: params.WithRaw,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = DeleteRecordParams
			Response = DeleteRecordRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackDeleteRecordParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.DeleteRecord(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.DeleteRecord(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeDeleteRecordResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleFindEntityNetworkRequest handles findEntityNetwork operation.
//
// This operation finds the entity network around one or more entities.
// This attempts to find paths between the specified entities.  If no
// paths exist, then island networks are returned with each island network
// containing up to a specified number of related entities.  The entities
// are identified by their entity IDs or by data source code and record ID
// pairs for constituent records of those entities.
// **NOTE:** If the first entity is identified by entity ID then the
// subsequent entities must also be identified entity ID.  Similarly, if
// the first entity is identified by the data source code and record ID
// of a consistuent record then the subsequent entities must also be
// identified by the data source code and record ID of constituent records.
// **ALSO NOTE:** Bear in mind that entity ID's are transient and may be
// recycled or repurposed as new records are loaded and entities resolve,
// unresolve and re-resolve.
//
// GET /entity-networks
func (s *Server) handleFindEntityNetworkRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("findEntityNetwork"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/entity-networks"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "FindEntityNetwork",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "FindEntityNetwork",
			ID:   "findEntityNetwork",
		}
	)
	params, err := decodeFindEntityNetworkParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response FindEntityNetworkRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "FindEntityNetwork",
			OperationSummary: "Finds the entity network around one or more entities.",
			OperationID:      "findEntityNetwork",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "maxDegrees",
					In:   "query",
				}: params.MaxDegrees,
				{
					Name: "buildOut",
					In:   "query",
				}: params.BuildOut,
				{
					Name: "maxEntities",
					In:   "query",
				}: params.MaxEntities,
				{
					Name: "detailLevel",
					In:   "query",
				}: params.DetailLevel,
				{
					Name: "featureMode",
					In:   "query",
				}: params.FeatureMode,
				{
					Name: "withFeatureStats",
					In:   "query",
				}: params.WithFeatureStats,
				{
					Name: "withInternalFeatures",
					In:   "query",
				}: params.WithInternalFeatures,
				{
					Name: "forceMinimal",
					In:   "query",
				}: params.ForceMinimal,
				{
					Name: "withRaw",
					In:   "query",
				}: params.WithRaw,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = FindEntityNetworkParams
			Response = FindEntityNetworkRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackFindEntityNetworkParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.FindEntityNetwork(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.FindEntityNetwork(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeFindEntityNetworkResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleFindEntityPathRequest handles findEntityPath operation.
//
// This operation finds the path between two entities and returns a
// description of that entity path (if any) or a response indicating that
// there is no path between the entities.  The subject entities are either
// identfieid by entity ID or by data source code and record ID pairs for
// constituent records of those entities.
// **NOTE:** If the first entity is identified by entity ID then the second
// must also be identified an entity ID.  Similarly, if the first entity is
// identified by data source code and record ID then the second must also
// be identified by data source code and record ID.
// **ALSO NOTE:** Bear in mind that entity ID's are transient and may be
// recycled or repurposed as new records are loaded and entities resolve,
// unresolve and re-resolve.
//
// GET /entity-paths
func (s *Server) handleFindEntityPathRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("findEntityPath"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/entity-paths"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "FindEntityPath",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "FindEntityPath",
			ID:   "findEntityPath",
		}
	)
	params, err := decodeFindEntityPathParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response FindEntityPathRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "FindEntityPath",
			OperationSummary: "Finds a path between two entities identified by entity ID or by data sources and record IDs of constituent records.",
			OperationID:      "findEntityPath",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "maxDegrees",
					In:   "query",
				}: params.MaxDegrees,
				{
					Name: "forbidAvoided",
					In:   "query",
				}: params.ForbidAvoided,
				{
					Name: "s",
					In:   "query",
				}: params.S,
				{
					Name: "detailLevel",
					In:   "query",
				}: params.DetailLevel,
				{
					Name: "featureMode",
					In:   "query",
				}: params.FeatureMode,
				{
					Name: "withFeatureStats",
					In:   "query",
				}: params.WithFeatureStats,
				{
					Name: "withInternalFeatures",
					In:   "query",
				}: params.WithInternalFeatures,
				{
					Name: "forceMinimal",
					In:   "query",
				}: params.ForceMinimal,
				{
					Name: "withRaw",
					In:   "query",
				}: params.WithRaw,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = FindEntityPathParams
			Response = FindEntityPathRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackFindEntityPathParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.FindEntityPath(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.FindEntityPath(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeFindEntityPathResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetActiveConfigRequest handles getActiveConfig operation.
//
// This operation returns the JSON configuration that is currently being
// used by the native Senzing API initialized by the running server.  No
// processing or interpretation is performed on the JSON.  This may differ
// from the registered "default configuration" which the server would
// use if no other configuration were provided.
//
// GET /configs/active
func (s *Server) handleGetActiveConfigRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getActiveConfig"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/configs/active"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetActiveConfig",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err error
	)

	var response GetActiveConfigRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetActiveConfig",
			OperationSummary: "Gets the current active configuration as raw JSON, no interpretation.",
			OperationID:      "getActiveConfig",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetActiveConfigRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetActiveConfig(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetActiveConfig(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetActiveConfigResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAttributeTypeRequest handles getAttributeType operation.
//
// This operation will provide a description of a single attribute type for
// the specified attribute type code.
//
// GET /attribute-types/{attributeCode}
func (s *Server) handleGetAttributeTypeRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAttributeType"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/attribute-types/{attributeCode}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAttributeType",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAttributeType",
			ID:   "getAttributeType",
		}
	)
	params, err := decodeGetAttributeTypeParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetAttributeTypeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAttributeType",
			OperationSummary: "Get the attribute type identified by the attribute code.",
			OperationID:      "getAttributeType",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "attributeCode",
					In:   "path",
				}: params.AttributeCode,
				{
					Name: "withRaw",
					In:   "query",
				}: params.WithRaw,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetAttributeTypeParams
			Response = GetAttributeTypeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetAttributeTypeParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAttributeType(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAttributeType(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetAttributeTypeResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAttributeTypesRequest handles getAttributeTypes operation.
//
// This operation will provide a list of attribute types that are
// configured.  The client can filter the returned list of attribute types
// using various query parameters.
//
// GET /attribute-types
func (s *Server) handleGetAttributeTypesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAttributeTypes"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/attribute-types"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAttributeTypes",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAttributeTypes",
			ID:   "getAttributeTypes",
		}
	)
	params, err := decodeGetAttributeTypesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetAttributeTypesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAttributeTypes",
			OperationSummary: "Get a list of configured attribute types.",
			OperationID:      "getAttributeTypes",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "withInternal",
					In:   "query",
				}: params.WithInternal,
				{
					Name: "attributeClass",
					In:   "query",
				}: params.AttributeClass,
				{
					Name: "featureType",
					In:   "query",
				}: params.FeatureType,
				{
					Name: "withRaw",
					In:   "query",
				}: params.WithRaw,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetAttributeTypesParams
			Response = GetAttributeTypesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetAttributeTypesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAttributeTypes(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAttributeTypes(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetAttributeTypesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetDataSourceRequest handles getDataSource operation.
//
// This operation provides details on a specific data source identified
// by the data source code in the requested path.
//
// GET /data-sources/{dataSourceCode}
func (s *Server) handleGetDataSourceRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getDataSource"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/data-sources/{dataSourceCode}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetDataSource",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetDataSource",
			ID:   "getDataSource",
		}
	)
	params, err := decodeGetDataSourceParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetDataSourceRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetDataSource",
			OperationSummary: "Gets the details on the specified data source.",
			OperationID:      "getDataSource",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "dataSourceCode",
					In:   "path",
				}: params.DataSourceCode,
				{
					Name: "withRaw",
					In:   "query",
				}: params.WithRaw,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetDataSourceParams
			Response = GetDataSourceRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetDataSourceParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetDataSource(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetDataSource(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetDataSourceResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetDataSourcesRequest handles getDataSources operation.
//
// This operation will provide a list of data source codes as well as a
// list of detailed descriptions of each data source.
//
// GET /data-sources
func (s *Server) handleGetDataSourcesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getDataSources"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/data-sources"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetDataSources",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetDataSources",
			ID:   "getDataSources",
		}
	)
	params, err := decodeGetDataSourcesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetDataSourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetDataSources",
			OperationSummary: "Get a list of configured data sources.",
			OperationID:      "getDataSources",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "withRaw",
					In:   "query",
				}: params.WithRaw,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetDataSourcesParams
			Response = GetDataSourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetDataSourcesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetDataSources(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetDataSources(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetDataSourcesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetEntityByEntityIdRequest handles getEntityByEntityId operation.
//
// Gets the details on a resolved entity that is identified by the entity
// ID specified in the request path.
// **NOTE:** Bear in mind that entity ID's are transient and may be
// recycled or repurposed as new records are loaded and entities resolve,
// unresolve and re-resolve.  An alternative way to identify an entity is
// by one of its constituent records using
// `GET /data-sources/{dataSourceCode}/records/{recordId}/entity`.
//
// GET /entities/{entityId}
func (s *Server) handleGetEntityByEntityIdRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getEntityByEntityId"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/entities/{entityId}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetEntityByEntityId",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetEntityByEntityId",
			ID:   "getEntityByEntityId",
		}
	)
	params, err := decodeGetEntityByEntityIdParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetEntityByEntityIdRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetEntityByEntityId",
			OperationSummary: "Get a resolved entity by entity ID.",
			OperationID:      "getEntityByEntityId",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "entityId",
					In:   "path",
				}: params.EntityId,
				{
					Name: "detailLevel",
					In:   "query",
				}: params.DetailLevel,
				{
					Name: "featureMode",
					In:   "query",
				}: params.FeatureMode,
				{
					Name: "withFeatureStats",
					In:   "query",
				}: params.WithFeatureStats,
				{
					Name: "withInternalFeatures",
					In:   "query",
				}: params.WithInternalFeatures,
				{
					Name: "forceMinimal",
					In:   "query",
				}: params.ForceMinimal,
				{
					Name: "withRelated",
					In:   "query",
				}: params.WithRelated,
				{
					Name: "withRaw",
					In:   "query",
				}: params.WithRaw,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetEntityByEntityIdParams
			Response = GetEntityByEntityIdRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetEntityByEntityIdParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetEntityByEntityId(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetEntityByEntityId(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetEntityByEntityIdResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetEntityByRecordIdRequest handles getEntityByRecordId operation.
//
// Gets the details on a resolved entity that contains the record
// identified by the data source code and record ID in the specified
// request path.
//
// GET /data-sources/{dataSourceCode}/records/{recordId}/entity
func (s *Server) handleGetEntityByRecordIdRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getEntityByRecordId"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/data-sources/{dataSourceCode}/records/{recordId}/entity"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetEntityByRecordId",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetEntityByRecordId",
			ID:   "getEntityByRecordId",
		}
	)
	params, err := decodeGetEntityByRecordIdParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetEntityByRecordIdRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetEntityByRecordId",
			OperationSummary: "Get a resolved entity by data source and record ID.",
			OperationID:      "getEntityByRecordId",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "dataSourceCode",
					In:   "path",
				}: params.DataSourceCode,
				{
					Name: "recordId",
					In:   "path",
				}: params.RecordId,
				{
					Name: "detailLevel",
					In:   "query",
				}: params.DetailLevel,
				{
					Name: "featureMode",
					In:   "query",
				}: params.FeatureMode,
				{
					Name: "withFeatureStats",
					In:   "query",
				}: params.WithFeatureStats,
				{
					Name: "withInternalFeatures",
					In:   "query",
				}: params.WithInternalFeatures,
				{
					Name: "forceMinimal",
					In:   "query",
				}: params.ForceMinimal,
				{
					Name: "withRelated",
					In:   "query",
				}: params.WithRelated,
				{
					Name: "withRaw",
					In:   "query",
				}: params.WithRaw,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetEntityByRecordIdParams
			Response = GetEntityByRecordIdRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetEntityByRecordIdParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetEntityByRecordId(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetEntityByRecordId(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetEntityByRecordIdResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetRecordRequest handles getRecord operation.
//
// Gets details on a specific entity record identified by the data source
// code and record ID specified in the request path.
//
// GET /data-sources/{dataSourceCode}/records/{recordId}
func (s *Server) handleGetRecordRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getRecord"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/data-sources/{dataSourceCode}/records/{recordId}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetRecord",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetRecord",
			ID:   "getRecord",
		}
	)
	params, err := decodeGetRecordParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetRecordRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetRecord",
			OperationSummary: "Get an entity record by data source and record ID.",
			OperationID:      "getRecord",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "dataSourceCode",
					In:   "path",
				}: params.DataSourceCode,
				{
					Name: "recordId",
					In:   "path",
				}: params.RecordId,
				{
					Name: "withRaw",
					In:   "query",
				}: params.WithRaw,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetRecordParams
			Response = GetRecordRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetRecordParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetRecord(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetRecord(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetRecordResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetServerInfoRequest handles getServerInfo operation.
//
// This operation will provides server information describing the options
// with which the server was started.  This can be used to determine if
// the admin operations are enabled or if only read operations may be
// invoked.  This also allows the client to know the maximum message size
// for Web Sockets communication.
//
// GET /server-info
func (s *Server) handleGetServerInfoRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getServerInfo"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/server-info"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetServerInfo",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err error
	)

	var response GetServerInfoRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetServerInfo",
			OperationSummary: "Get info regarding the server's state and supported features.",
			OperationID:      "getServerInfo",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetServerInfoRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetServerInfo(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetServerInfo(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetServerInfoResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetTemplateConfigRequest handles getTemplateConfig operation.
//
// This operation returns a template base JSON configuration that can be
// modified or customized by the caller.  The returned template is
// according to the underlying native Senzing API and may change between
// version upgrades to Senzing.  No processing or interpretation is
// performed on the JSON.  This will likely differ from the registered
// "default configuration" or currently "active configuration" being used
// by the running API server.
//
// GET /configs/template
func (s *Server) handleGetTemplateConfigRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getTemplateConfig"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/configs/template"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetTemplateConfig",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err error
	)

	var response GetTemplateConfigRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetTemplateConfig",
			OperationSummary: "Gets the base template configuration as raw JSON, no interpretation. This is the initial configuration for a new repository.",
			OperationID:      "getTemplateConfig",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetTemplateConfigRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetTemplateConfig(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetTemplateConfig(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetTemplateConfigResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetVirtualEntityByRecordIdsRequest handles getVirtualEntityByRecordIds operation.
//
// This operation simulates the resolution of the one or more specified
// records into a single entity and returns the simulated "virtual"
// entity.  The subject records are identified by data source code and
// record ID pairs.
//
// GET /virtual-entities
func (s *Server) handleGetVirtualEntityByRecordIdsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getVirtualEntityByRecordIds"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/virtual-entities"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetVirtualEntityByRecordIds",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetVirtualEntityByRecordIds",
			ID:   "getVirtualEntityByRecordIds",
		}
	)
	params, err := decodeGetVirtualEntityByRecordIdsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetVirtualEntityByRecordIdsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetVirtualEntityByRecordIds",
			OperationSummary: "Builds a virtual entity by simulating the resolution of the records identified by the specified record ID parameters.",
			OperationID:      "getVirtualEntityByRecordIds",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "detailLevel",
					In:   "query",
				}: params.DetailLevel,
				{
					Name: "featureMode",
					In:   "query",
				}: params.FeatureMode,
				{
					Name: "withFeatureStats",
					In:   "query",
				}: params.WithFeatureStats,
				{
					Name: "withInternalFeatures",
					In:   "query",
				}: params.WithInternalFeatures,
				{
					Name: "forceMinimal",
					In:   "query",
				}: params.ForceMinimal,
				{
					Name: "withRaw",
					In:   "query",
				}: params.WithRaw,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetVirtualEntityByRecordIdsParams
			Response = GetVirtualEntityByRecordIdsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetVirtualEntityByRecordIdsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetVirtualEntityByRecordIds(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetVirtualEntityByRecordIds(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetVirtualEntityByRecordIdsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHeartbeatRequest handles heartbeat operation.
//
// The heartbeat operation can be used to ensure that the HTTP server is
// indeed running, but this operation does not call upon the underlying
// native Senzing API and therefore does not ensure the Senzing
// initialization or configuration is valid.
//
// GET /heartbeat
func (s *Server) handleHeartbeatRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("heartbeat"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/heartbeat"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "Heartbeat",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err error
	)

	var response *SzBaseResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "Heartbeat",
			OperationSummary: "Gets a heartbeat from the server to make sure it is up and running.  The response will include the current timestamp.",
			OperationID:      "heartbeat",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *SzBaseResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.Heartbeat(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.Heartbeat(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHeartbeatResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHowEntityByEntityIDRequest handles howEntityByEntityID operation.
//
// This operation provides an anlysis of how the records in an entity
// resolved.  The subject entity is identified by the entity ID in the
// request path.
// **NOTE:** Bear in mind that entity ID's are transient and may be
// recycled or repurposed as new records are loaded and entities resolve,
// unresolve and re-resolve.  An alternative way to identify an entity is
// by one of its constituent records using
// `GET /data-sources/{dataSourceCode}/records/{recordId}/entity/how`.
//
// GET /entities/{entityId}/how
func (s *Server) handleHowEntityByEntityIDRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("howEntityByEntityID"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/entities/{entityId}/how"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "HowEntityByEntityID",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HowEntityByEntityID",
			ID:   "howEntityByEntityID",
		}
	)
	params, err := decodeHowEntityByEntityIDParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HowEntityByEntityIDRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HowEntityByEntityID",
			OperationSummary: "Returns an analysis of how the entity for the respective entity ID resolved.",
			OperationID:      "howEntityByEntityID",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "entityId",
					In:   "path",
				}: params.EntityId,
				{
					Name: "withRaw",
					In:   "query",
				}: params.WithRaw,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HowEntityByEntityIDParams
			Response = HowEntityByEntityIDRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHowEntityByEntityIDParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HowEntityByEntityID(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HowEntityByEntityID(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHowEntityByEntityIDResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHowEntityByRecordIDRequest handles howEntityByRecordID operation.
//
// This operation provides an anlysis of how the records in an entity
// resolved.  The subject entity is the one containing the record
// identified by the data source code and record ID in the request path.
//
// GET /data-sources/{dataSourceCode}/records/{recordId}/entity/how
func (s *Server) handleHowEntityByRecordIDRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("howEntityByRecordID"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/data-sources/{dataSourceCode}/records/{recordId}/entity/how"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "HowEntityByRecordID",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HowEntityByRecordID",
			ID:   "howEntityByRecordID",
		}
	)
	params, err := decodeHowEntityByRecordIDParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HowEntityByRecordIDRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HowEntityByRecordID",
			OperationSummary: "Returns an analysis of how the entity for the record with the respective data source code and record ID resolved.",
			OperationID:      "howEntityByRecordID",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "dataSourceCode",
					In:   "path",
				}: params.DataSourceCode,
				{
					Name: "recordId",
					In:   "path",
				}: params.RecordId,
				{
					Name: "withRaw",
					In:   "query",
				}: params.WithRaw,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HowEntityByRecordIDParams
			Response = HowEntityByRecordIDRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHowEntityByRecordIDParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HowEntityByRecordID(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HowEntityByRecordID(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHowEntityByRecordIDResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleLicenseRequest handles license operation.
//
// This operation will obtain license information for the underlying
// native Senzing API.
//
// GET /license
func (s *Server) handleLicenseRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("license"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/license"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "License",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "License",
			ID:   "license",
		}
	)
	params, err := decodeLicenseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response LicenseRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "License",
			OperationSummary: "Get the license information.",
			OperationID:      "license",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "withRaw",
					In:   "query",
				}: params.WithRaw,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = LicenseParams
			Response = LicenseRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackLicenseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.License(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.License(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeLicenseResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleLoadBulkRecordsRequest handles loadBulkRecords operation.
//
// Provides a means to load a bulk data file of records.  The records are
// encoded as a JSON array of JSON objects, a single JSON object per line
// in JSON-lines file format, or as a CSV with one record per row.  The
// data should be in pre-mapped format using JSON property names or CSV
// column names as described by the
// [Senzing Generic Entity Specification](https://senzing.zendesk.
// com/hc/en-us/articles/231925448-Generic-Entity-Specification).
// **SCALABILITY NOTE:** This operation can be invoked in three ways.  In
// order of increasingly better scalability these are listed below:
// 1. Standard HTTP Request/Response
// 2. HTTP Request with SSE Response (see below)
// 3. HTTP Upgrade Request for Web Sockets (see below)
// Standard HTTP Request/Response (method 1) has the worst scalability
// because a long-running operation will tie up a Web Server thread **and**
// continue until complete even if the client aborts the operation since
// no data is written back to the client until complete and therefore the
// terminated connection will not be detected.  SSE (method 2) mitigates
// the problem of detecting when a client has aborted the operation
// because periodic progress responses are written to the client and
// therefore a terminated connection will be detected.  However, the best
// way to invoke this operation is via Web Sockets (method 3) which not
// only can detect disconnection of the client, but it also upgrades the
// request to use its own thread outside the Web Server thread pool.
// **SSE NOTE:** This end-point supports "Server-sent Events" (SSE) via the
// `text/event-stream` media type.  This support is activated by adding the
// `Accept: text/event-stream` header to a request to override the
// default `application/json` media type.  Further, the end-point will behave
// similarly to its standard operation but will produce `progress` events
// at regular intervals that are equivalent to its `200` response schema.
// Upon success, the final event will be `completed` with the same response
// schema as a `200` response.  Upon failure, the final event will be
// `failed` with same `SzErrorResponse` schema as the `4xx` or `5xx`.
// **WEB SOCKETS NOTE**: If invoking via Web Sockets then the client may
// send text or binary chunks of the JSON, JSON-Lines or CSV bulk data file
// as messages.  In Web Sockets, text messages are *always* sent as UTF-8.
// If the file's character encoding is unknown then the client should send
// binary messages and the server will attempt to auto-detect the character
// encoding.  Each message should adhere to the maximum message size
// specified by the `webSocketsMessageMaxSize` property returned by the
// `GET /server-info` end-point.  The end of file is detected when the
// number of seconds specified by the `eofSendTimeout` query parameter have
// elapsed without a new message being received.
//
// POST /bulk-data/load
func (s *Server) handleLoadBulkRecordsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("loadBulkRecords"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/bulk-data/load"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "LoadBulkRecords",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "LoadBulkRecords",
			ID:   "loadBulkRecords",
		}
	)
	params, err := decodeLoadBulkRecordsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeLoadBulkRecordsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response LoadBulkRecordsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "LoadBulkRecords",
			OperationSummary: "Load the records in the provided bulk data set. (Supports SSE / Supports Web Sockets)",
			OperationID:      "loadBulkRecords",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "dataSource",
					In:   "query",
				}: params.DataSource,
				{
					Name: "mapDataSources",
					In:   "query",
				}: params.MapDataSources,
				{
					Name: "mapDataSource",
					In:   "query",
				}: params.MapDataSource,
				{
					Name: "maxFailures",
					In:   "query",
				}: params.MaxFailures,
				{
					Name: "progressPeriod",
					In:   "query",
				}: params.ProgressPeriod,
				{
					Name: "eofSendTimeout",
					In:   "query",
				}: params.EofSendTimeout,
			},
			Raw: r,
		}

		type (
			Request  = LoadBulkRecordsReq
			Params   = LoadBulkRecordsParams
			Response = LoadBulkRecordsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackLoadBulkRecordsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.LoadBulkRecords(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.LoadBulkRecords(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeLoadBulkRecordsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOpenAPISpecificationRequest handles openAPISpecification operation.
//
// This operation can be used to obtain the Open API specification in JSON
// format.  The specification can either be the `data` field of a standard
// response (i.e.: a response with a `meta`, `links` and `data` field) or
// as raw format where the root JSON document is the Open API specification
// JSON.
//
// GET /specifications/open-api
func (s *Server) handleOpenAPISpecificationRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("openAPISpecification"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/specifications/open-api"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OpenAPISpecification",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err error
	)

	var response OpenAPISpecificationOKDefault
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "OpenAPISpecification",
			OperationSummary: "Gets this Open API specification to describe the API.",
			OperationID:      "openAPISpecification",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = OpenAPISpecificationOKDefault
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OpenAPISpecification(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.OpenAPISpecification(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOpenAPISpecificationResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReevaluateEntityRequest handles reevaluateEntity operation.
//
// Reevaluates an entity identified by the entity ID specified via the
// `entityId` query parameter.
// **NOTE:** The `withInfo` parameter will return the entity resolution
// info pertaining to the reevaluation.  This can be used to update a
// search index or external data mart.   Additionally, Senzing API Server
// provides a means to have the "raw" entity resolution info (from the
// underlying native Senzing API) automatically sent to a messaging service
// such as those provided by Amazon SQS, Rabbit MQ or Kafka regardless of
// the `withInfo` query parameter value.
// **ALSO NOTE:** Bear in mind that entity ID's are transient and may be
// recycled or repurposed as new records are loaded and entities resolve,
// unresolve and re-resolve.
//
// POST /reevaluate-entity
func (s *Server) handleReevaluateEntityRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reevaluateEntity"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/reevaluate-entity"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReevaluateEntity",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReevaluateEntity",
			ID:   "reevaluateEntity",
		}
	)
	params, err := decodeReevaluateEntityParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReevaluateEntityRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReevaluateEntity",
			OperationSummary: "Reevaluate an entity identified by its entity ID.",
			OperationID:      "reevaluateEntity",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "entityId",
					In:   "query",
				}: params.EntityId,
				{
					Name: "withInfo",
					In:   "query",
				}: params.WithInfo,
				{
					Name: "withRaw",
					In:   "query",
				}: params.WithRaw,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReevaluateEntityParams
			Response = ReevaluateEntityRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReevaluateEntityParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReevaluateEntity(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReevaluateEntity(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReevaluateEntityResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReevaluateRecordRequest handles reevaluateRecord operation.
//
// This operation reevaluates a single record identified by the data source
// code and record ID in the request path.
// **NOTE:** The `withInfo` parameter will return the entity resolution
// info pertaining to the reevaluation.  This can be used to update a
// search index or external data mart.   Additionally, Senzing API Server
// provides a means to have the "raw" entity resolution info (from the
// underlying native Senzing API) automatically sent to a messaging service
// such as those provided by Amazon SQS, Rabbit MQ or Kafka regardless of
// the `withInfo` query parameter value.
//
// POST /data-sources/{dataSourceCode}/records/{recordId}/reevaluate
func (s *Server) handleReevaluateRecordRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reevaluateRecord"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/data-sources/{dataSourceCode}/records/{recordId}/reevaluate"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReevaluateRecord",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ReevaluateRecord",
			ID:   "reevaluateRecord",
		}
	)
	params, err := decodeReevaluateRecordParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ReevaluateRecordRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ReevaluateRecord",
			OperationSummary: "Reevaluate a record identified by a data source and record ID.",
			OperationID:      "reevaluateRecord",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "dataSourceCode",
					In:   "path",
				}: params.DataSourceCode,
				{
					Name: "recordId",
					In:   "path",
				}: params.RecordId,
				{
					Name: "withInfo",
					In:   "query",
				}: params.WithInfo,
				{
					Name: "withRaw",
					In:   "query",
				}: params.WithRaw,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReevaluateRecordParams
			Response = ReevaluateRecordRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReevaluateRecordParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReevaluateRecord(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReevaluateRecord(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReevaluateRecordResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleRootRequest handles root operation.
//
// The root operation can be used to ensure that the HTTP server is
// indeed running, but this operation does not call upon the underlying
// native Senzing API and therefore does not ensure the Senzing
// initialization or configuration is valid.
//
// GET /
func (s *Server) handleRootRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("root"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "Root",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err error
	)

	var response *SzBaseResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "Root",
			OperationSummary: "Gets a root-level response from the server.  This returns the same as the `GET /heartbeat` endpoint for now, but may change in the future to provide additional information.",
			OperationID:      "root",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *SzBaseResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.Root(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.Root(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeRootResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleSearchEntitiesByGetRequest handles searchEntitiesByGet operation.
//
// This operation finds all entities that would resolve or relate to the
// search candidate features specified by the `attr` and/or `attrs` query
// parameters.  The search candidate features are treated as if they
// belonged to an inbound record being loaded, thus the attribute names are
// given by the [Senzing Generic Entity Specification](https://senzing.zendesk.
// com/hc/en-us/articles/231925448-Generic-Entity-Specification).
// If including the search candidate features as query parameters presents
// privacy concerns due to sensitivity of the data, they can alternately
// be sent in the request body using the `POST /search-entities` endpoint.
// **NOTE:** This operation differs from a keyword search in that it uses
// deterministic entity resolution rules to determine the result set.  This
// means that features that are considered "generic" (i.e.: overly common)
// will be ignored just as they are during entity resolution and will not
// yield search results.  For example, searching on a gender by itself will
// return no results rather than half of all entities.  Similarly, a phone
// number such as `555-1212` may yield no results.
//
// GET /entities
func (s *Server) handleSearchEntitiesByGetRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("searchEntitiesByGet"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/entities"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SearchEntitiesByGet",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "SearchEntitiesByGet",
			ID:   "searchEntitiesByGet",
		}
	)
	params, err := decodeSearchEntitiesByGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response SearchEntitiesByGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "SearchEntitiesByGet",
			OperationSummary: "Search for entities that would resolve to or relate to the provided entity features.",
			OperationID:      "searchEntitiesByGet",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "attrs",
					In:   "query",
				}: params.Attrs,
				{
					Name: "attr",
					In:   "query",
				}: params.Attr,
				{
					Name: "includeOnly",
					In:   "query",
				}: params.IncludeOnly,
				{
					Name: "detailLevel",
					In:   "query",
				}: params.DetailLevel,
				{
					Name: "featureMode",
					In:   "query",
				}: params.FeatureMode,
				{
					Name: "withFeatureStats",
					In:   "query",
				}: params.WithFeatureStats,
				{
					Name: "withInternalFeatures",
					In:   "query",
				}: params.WithInternalFeatures,
				{
					Name: "forceMinimal",
					In:   "query",
				}: params.ForceMinimal,
				{
					Name: "withRelationships",
					In:   "query",
				}: params.WithRelationships,
				{
					Name: "withRaw",
					In:   "query",
				}: params.WithRaw,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = SearchEntitiesByGetParams
			Response = SearchEntitiesByGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackSearchEntitiesByGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.SearchEntitiesByGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.SearchEntitiesByGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSearchEntitiesByGetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleSearchEntitiesByPostRequest handles searchEntitiesByPost operation.
//
// This operation finds all entities that would resolve or relate to the
// search candidate features specified in JSON request body.  The search
// candidate features are treated as if they belonged to an inbound record
// being loaded.  The JSON format of the request body is defined by the
// [Senzing Generic Entity Specification](https://senzing.zendesk.
// com/hc/en-us/articles/231925448-Generic-Entity-Specification).
// This operation is similar to the `GET /entities` endpoint in function
// except that it provides a means to avoid specifying potentially
// sensitive data in query parameters, but instead in the request body.
// **NOTE:** This operation differs from a keyword search in that it uses
// deterministic entity resolution rules to determine the result set.  This
// means that features that are considered "generic" (i.e.: overly common)
// will be ignored just as they are during entity resolution and will not
// yield search results.  For example, searching on a gender by itself will
// return no results rather than half of all entities.  Similarly, a phone
// number such as `555-1212` may yield no results.
//
// POST /search-entities
func (s *Server) handleSearchEntitiesByPostRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("searchEntitiesByPost"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/search-entities"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SearchEntitiesByPost",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "SearchEntitiesByPost",
			ID:   "searchEntitiesByPost",
		}
	)
	params, err := decodeSearchEntitiesByPostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeSearchEntitiesByPostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response SearchEntitiesByPostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "SearchEntitiesByPost",
			OperationSummary: "Search for entities that would match or relate to the provided entity features.  This is similar to `GET /entities` except it requires the caller to specify the search criteria as JSON in the request body.",
			OperationID:      "searchEntitiesByPost",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "includeOnly",
					In:   "query",
				}: params.IncludeOnly,
				{
					Name: "detailLevel",
					In:   "query",
				}: params.DetailLevel,
				{
					Name: "featureMode",
					In:   "query",
				}: params.FeatureMode,
				{
					Name: "withFeatureStats",
					In:   "query",
				}: params.WithFeatureStats,
				{
					Name: "withInternalFeatures",
					In:   "query",
				}: params.WithInternalFeatures,
				{
					Name: "forceMinimal",
					In:   "query",
				}: params.ForceMinimal,
				{
					Name: "withRelationships",
					In:   "query",
				}: params.WithRelationships,
				{
					Name: "withRaw",
					In:   "query",
				}: params.WithRaw,
			},
			Raw: r,
		}

		type (
			Request  = SearchEntitiesByPostReq
			Params   = SearchEntitiesByPostParams
			Response = SearchEntitiesByPostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackSearchEntitiesByPostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.SearchEntitiesByPost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.SearchEntitiesByPost(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSearchEntitiesByPostResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleVersionRequest handles version operation.
//
// This operation will obtain the full version information for the server.
// Much of the same information is available in the `meta` segment of
// every JSON response.
//
// GET /version
func (s *Server) handleVersionRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("version"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/version"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "Version",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "Version",
			ID:   "version",
		}
	)
	params, err := decodeVersionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response VersionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "Version",
			OperationSummary: "Get the full version information.",
			OperationID:      "version",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "withRaw",
					In:   "query",
				}: params.WithRaw,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = VersionParams
			Response = VersionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackVersionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.Version(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.Version(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeVersionResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWhyEntitiesRequest handles whyEntities operation.
//
// This operation provides an anlysis of why two entities related, did not
// relate or did not resolve.  The entities are identified either by
// entity ID's or by data source code and record ID pairs for constituent
// records of those entities.
// **NOTE:** If the first entity is identified by entity ID then the second
// must also be identified an entity ID.  Similarly, if the first entity is
// identified by data source code and record ID then the second must also
// be identified by data source code and record ID.
// **ALSO NOTE:** Bear in mind that entity ID's are transient and may be
// recycled or repurposed as new records are loaded and entities resolve,
// unresolve and re-resolve.
//
// GET /why/entities
func (s *Server) handleWhyEntitiesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("whyEntities"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/why/entities"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WhyEntities",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WhyEntities",
			ID:   "whyEntities",
		}
	)
	params, err := decodeWhyEntitiesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WhyEntitiesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WhyEntities",
			OperationSummary: "Returns an analysis of why the two entities related, did not relate, or did not resolve.",
			OperationID:      "whyEntities",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "entity1",
					In:   "query",
				}: params.Entity1,
				{
					Name: "entity2",
					In:   "query",
				}: params.Entity2,
				{
					Name: "withRelationships",
					In:   "query",
				}: params.WithRelationships,
				{
					Name: "withFeatureStats",
					In:   "query",
				}: params.WithFeatureStats,
				{
					Name: "withInternalFeatures",
					In:   "query",
				}: params.WithInternalFeatures,
				{
					Name: "detailLevel",
					In:   "query",
				}: params.DetailLevel,
				{
					Name: "featureMode",
					In:   "query",
				}: params.FeatureMode,
				{
					Name: "forceMinimal",
					In:   "query",
				}: params.ForceMinimal,
				{
					Name: "withRaw",
					In:   "query",
				}: params.WithRaw,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WhyEntitiesParams
			Response = WhyEntitiesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWhyEntitiesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WhyEntities(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WhyEntities(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWhyEntitiesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWhyEntityByEntityIDRequest handles whyEntityByEntityID operation.
//
// This operation provides an anlysis of why the records in an entity
// resolved.  The subject entity is identified by the entity ID in the
// request path.
// **NOTE:** Bear in mind that entity ID's are transient and may be
// recycled or repurposed as new records are loaded and entities resolve,
// unresolve and re-resolve.  An alternative way to identify an entity is
// by one of its constituent records using
// `GET /data-sources/{dataSourceCode}/records/{recordId}/entity/why`.
//
// GET /entities/{entityId}/why
func (s *Server) handleWhyEntityByEntityIDRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("whyEntityByEntityID"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/entities/{entityId}/why"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WhyEntityByEntityID",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WhyEntityByEntityID",
			ID:   "whyEntityByEntityID",
		}
	)
	params, err := decodeWhyEntityByEntityIDParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WhyEntityByEntityIDRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WhyEntityByEntityID",
			OperationSummary: "Returns an analysis of why the entity for the respective entity ID resolved.",
			OperationID:      "whyEntityByEntityID",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "entityId",
					In:   "path",
				}: params.EntityId,
				{
					Name: "withRelationships",
					In:   "query",
				}: params.WithRelationships,
				{
					Name: "withFeatureStats",
					In:   "query",
				}: params.WithFeatureStats,
				{
					Name: "withInternalFeatures",
					In:   "query",
				}: params.WithInternalFeatures,
				{
					Name: "detailLevel",
					In:   "query",
				}: params.DetailLevel,
				{
					Name: "featureMode",
					In:   "query",
				}: params.FeatureMode,
				{
					Name: "forceMinimal",
					In:   "query",
				}: params.ForceMinimal,
				{
					Name: "withRaw",
					In:   "query",
				}: params.WithRaw,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WhyEntityByEntityIDParams
			Response = WhyEntityByEntityIDRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWhyEntityByEntityIDParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WhyEntityByEntityID(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WhyEntityByEntityID(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWhyEntityByEntityIDResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWhyEntityByRecordIDRequest handles whyEntityByRecordID operation.
//
// This operation provides an anlysis of why the records in an entity
// resolved.  The subject entity is the one containing the record
// identified by the data source code and record ID in the request path.
//
// GET /data-sources/{dataSourceCode}/records/{recordId}/entity/why
func (s *Server) handleWhyEntityByRecordIDRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("whyEntityByRecordID"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/data-sources/{dataSourceCode}/records/{recordId}/entity/why"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WhyEntityByRecordID",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WhyEntityByRecordID",
			ID:   "whyEntityByRecordID",
		}
	)
	params, err := decodeWhyEntityByRecordIDParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WhyEntityByRecordIDRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WhyEntityByRecordID",
			OperationSummary: "Returns an analysis of why the entity for the record with the respective data source code and record ID resolved.",
			OperationID:      "whyEntityByRecordID",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "dataSourceCode",
					In:   "path",
				}: params.DataSourceCode,
				{
					Name: "recordId",
					In:   "path",
				}: params.RecordId,
				{
					Name: "withRelationships",
					In:   "query",
				}: params.WithRelationships,
				{
					Name: "withFeatureStats",
					In:   "query",
				}: params.WithFeatureStats,
				{
					Name: "withInternalFeatures",
					In:   "query",
				}: params.WithInternalFeatures,
				{
					Name: "detailLevel",
					In:   "query",
				}: params.DetailLevel,
				{
					Name: "featureMode",
					In:   "query",
				}: params.FeatureMode,
				{
					Name: "forceMinimal",
					In:   "query",
				}: params.ForceMinimal,
				{
					Name: "withRaw",
					In:   "query",
				}: params.WithRaw,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WhyEntityByRecordIDParams
			Response = WhyEntityByRecordIDRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWhyEntityByRecordIDParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WhyEntityByRecordID(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WhyEntityByRecordID(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWhyEntityByRecordIDResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWhyRecordsRequest handles whyRecords operation.
//
// This operation provides an anlysis of two records identified by data
// source code and record ID in respective qeury parameters resolved or
// did not resolve.
//
// GET /why/records
func (s *Server) handleWhyRecordsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("whyRecords"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/why/records"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "WhyRecords",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		attrOpt := metric.WithAttributeSet(labeler.AttributeSet())

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributeSet(labeler.AttributeSet()))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WhyRecords",
			ID:   "whyRecords",
		}
	)
	params, err := decodeWhyRecordsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response WhyRecordsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WhyRecords",
			OperationSummary: "Returns an analysis of why the records identified by the data source and record ID's in the query parameters resolved or did not resolve.",
			OperationID:      "whyRecords",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "dataSource1",
					In:   "query",
				}: params.DataSource1,
				{
					Name: "recordId1",
					In:   "query",
				}: params.RecordId1,
				{
					Name: "dataSource2",
					In:   "query",
				}: params.DataSource2,
				{
					Name: "recordId2",
					In:   "query",
				}: params.RecordId2,
				{
					Name: "withRelationships",
					In:   "query",
				}: params.WithRelationships,
				{
					Name: "withFeatureStats",
					In:   "query",
				}: params.WithFeatureStats,
				{
					Name: "withInternalFeatures",
					In:   "query",
				}: params.WithInternalFeatures,
				{
					Name: "detailLevel",
					In:   "query",
				}: params.DetailLevel,
				{
					Name: "featureMode",
					In:   "query",
				}: params.FeatureMode,
				{
					Name: "forceMinimal",
					In:   "query",
				}: params.ForceMinimal,
				{
					Name: "withRaw",
					In:   "query",
				}: params.WithRaw,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WhyRecordsParams
			Response = WhyRecordsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWhyRecordsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WhyRecords(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WhyRecords(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWhyRecordsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}
