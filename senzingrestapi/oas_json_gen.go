// Code generated by ogen, DO NOT EDIT.

package senzingrestapi

import (
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/json"
)

// Encode encodes AddDataSourcesApplicationJSONForbidden as json.
func (s *AddDataSourcesApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddDataSourcesApplicationJSONForbidden from json.
func (s *AddDataSourcesApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddDataSourcesApplicationJSONForbidden to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddDataSourcesApplicationJSONForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddDataSourcesApplicationJSONForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddDataSourcesApplicationJSONForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddDataSourcesApplicationJSONInternalServerError as json.
func (s *AddDataSourcesApplicationJSONInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddDataSourcesApplicationJSONInternalServerError from json.
func (s *AddDataSourcesApplicationJSONInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddDataSourcesApplicationJSONInternalServerError to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddDataSourcesApplicationJSONInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddDataSourcesApplicationJSONInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddDataSourcesApplicationJSONInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddDataSourcesReqApplicationJSON as json.
func (s AddDataSourcesReqApplicationJSON) Encode(e *jx.Encoder) {
	switch s.Type {
	case SzDataSourceDescriptorArrayAddDataSourcesReqApplicationJSON:
		e.ArrStart()
		for _, elem := range s.SzDataSourceDescriptorArray {
			elem.Encode(e)
		}
		e.ArrEnd()
	case SzDataSourceDescriptorAddDataSourcesReqApplicationJSON:
		s.SzDataSourceDescriptor.Encode(e)
	}
}

// Decode decodes AddDataSourcesReqApplicationJSON from json.
func (s *AddDataSourcesReqApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddDataSourcesReqApplicationJSON to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Array:
		s.SzDataSourceDescriptorArray = make([]SzDataSourceDescriptor, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SzDataSourceDescriptor
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.SzDataSourceDescriptorArray = append(s.SzDataSourceDescriptorArray, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = SzDataSourceDescriptorArrayAddDataSourcesReqApplicationJSON
	case jx.Object, jx.String:
		if err := s.SzDataSourceDescriptor.Decode(d); err != nil {
			return err
		}
		s.Type = SzDataSourceDescriptorAddDataSourcesReqApplicationJSON
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AddDataSourcesReqApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddDataSourcesReqApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddRecordApplicationJSONBadRequest as json.
func (s *AddRecordApplicationJSONBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddRecordApplicationJSONBadRequest from json.
func (s *AddRecordApplicationJSONBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddRecordApplicationJSONBadRequest to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddRecordApplicationJSONBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddRecordApplicationJSONBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddRecordApplicationJSONBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddRecordApplicationJSONForbidden as json.
func (s *AddRecordApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddRecordApplicationJSONForbidden from json.
func (s *AddRecordApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddRecordApplicationJSONForbidden to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddRecordApplicationJSONForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddRecordApplicationJSONForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddRecordApplicationJSONForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddRecordApplicationJSONInternalServerError as json.
func (s *AddRecordApplicationJSONInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddRecordApplicationJSONInternalServerError from json.
func (s *AddRecordApplicationJSONInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddRecordApplicationJSONInternalServerError to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddRecordApplicationJSONInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddRecordApplicationJSONInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddRecordApplicationJSONInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddRecordApplicationJSONNotFound as json.
func (s *AddRecordApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddRecordApplicationJSONNotFound from json.
func (s *AddRecordApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddRecordApplicationJSONNotFound to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddRecordApplicationJSONNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddRecordApplicationJSONNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddRecordApplicationJSONNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s AddRecordReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s AddRecordReq) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes AddRecordReq from json.
func (s *AddRecordReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddRecordReq to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddRecordReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AddRecordReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddRecordReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddRecordWithReturnedRecordIdApplicationJSONBadRequest as json.
func (s *AddRecordWithReturnedRecordIdApplicationJSONBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddRecordWithReturnedRecordIdApplicationJSONBadRequest from json.
func (s *AddRecordWithReturnedRecordIdApplicationJSONBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddRecordWithReturnedRecordIdApplicationJSONBadRequest to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddRecordWithReturnedRecordIdApplicationJSONBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddRecordWithReturnedRecordIdApplicationJSONBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddRecordWithReturnedRecordIdApplicationJSONBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddRecordWithReturnedRecordIdApplicationJSONForbidden as json.
func (s *AddRecordWithReturnedRecordIdApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddRecordWithReturnedRecordIdApplicationJSONForbidden from json.
func (s *AddRecordWithReturnedRecordIdApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddRecordWithReturnedRecordIdApplicationJSONForbidden to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddRecordWithReturnedRecordIdApplicationJSONForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddRecordWithReturnedRecordIdApplicationJSONForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddRecordWithReturnedRecordIdApplicationJSONForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddRecordWithReturnedRecordIdApplicationJSONInternalServerError as json.
func (s *AddRecordWithReturnedRecordIdApplicationJSONInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddRecordWithReturnedRecordIdApplicationJSONInternalServerError from json.
func (s *AddRecordWithReturnedRecordIdApplicationJSONInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddRecordWithReturnedRecordIdApplicationJSONInternalServerError to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddRecordWithReturnedRecordIdApplicationJSONInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddRecordWithReturnedRecordIdApplicationJSONInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddRecordWithReturnedRecordIdApplicationJSONInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddRecordWithReturnedRecordIdApplicationJSONNotFound as json.
func (s *AddRecordWithReturnedRecordIdApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddRecordWithReturnedRecordIdApplicationJSONNotFound from json.
func (s *AddRecordWithReturnedRecordIdApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddRecordWithReturnedRecordIdApplicationJSONNotFound to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddRecordWithReturnedRecordIdApplicationJSONNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddRecordWithReturnedRecordIdApplicationJSONNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddRecordWithReturnedRecordIdApplicationJSONNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s AddRecordWithReturnedRecordIdReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s AddRecordWithReturnedRecordIdReq) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes AddRecordWithReturnedRecordIdReq from json.
func (s *AddRecordWithReturnedRecordIdReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddRecordWithReturnedRecordIdReq to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddRecordWithReturnedRecordIdReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AddRecordWithReturnedRecordIdReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddRecordWithReturnedRecordIdReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AnalyzeBulkRecordsReqApplicationJSON as json.
func (s AnalyzeBulkRecordsReqApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes AnalyzeBulkRecordsReqApplicationJSON from json.
func (s *AnalyzeBulkRecordsReqApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnalyzeBulkRecordsReqApplicationJSON to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AnalyzeBulkRecordsReqApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AnalyzeBulkRecordsReqApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnalyzeBulkRecordsReqApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteRecordApplicationJSONInternalServerError as json.
func (s *DeleteRecordApplicationJSONInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteRecordApplicationJSONInternalServerError from json.
func (s *DeleteRecordApplicationJSONInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteRecordApplicationJSONInternalServerError to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteRecordApplicationJSONInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteRecordApplicationJSONInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteRecordApplicationJSONInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteRecordApplicationJSONNotFound as json.
func (s *DeleteRecordApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteRecordApplicationJSONNotFound from json.
func (s *DeleteRecordApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteRecordApplicationJSONNotFound to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteRecordApplicationJSONNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteRecordApplicationJSONNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteRecordApplicationJSONNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FindEntityNetworkApplicationJSONBadRequest as json.
func (s *FindEntityNetworkApplicationJSONBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes FindEntityNetworkApplicationJSONBadRequest from json.
func (s *FindEntityNetworkApplicationJSONBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FindEntityNetworkApplicationJSONBadRequest to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = FindEntityNetworkApplicationJSONBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FindEntityNetworkApplicationJSONBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FindEntityNetworkApplicationJSONBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FindEntityNetworkApplicationJSONInternalServerError as json.
func (s *FindEntityNetworkApplicationJSONInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes FindEntityNetworkApplicationJSONInternalServerError from json.
func (s *FindEntityNetworkApplicationJSONInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FindEntityNetworkApplicationJSONInternalServerError to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = FindEntityNetworkApplicationJSONInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FindEntityNetworkApplicationJSONInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FindEntityNetworkApplicationJSONInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FindEntityPathApplicationJSONBadRequest as json.
func (s *FindEntityPathApplicationJSONBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes FindEntityPathApplicationJSONBadRequest from json.
func (s *FindEntityPathApplicationJSONBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FindEntityPathApplicationJSONBadRequest to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = FindEntityPathApplicationJSONBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FindEntityPathApplicationJSONBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FindEntityPathApplicationJSONBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FindEntityPathApplicationJSONInternalServerError as json.
func (s *FindEntityPathApplicationJSONInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes FindEntityPathApplicationJSONInternalServerError from json.
func (s *FindEntityPathApplicationJSONInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FindEntityPathApplicationJSONInternalServerError to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = FindEntityPathApplicationJSONInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FindEntityPathApplicationJSONInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FindEntityPathApplicationJSONInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetAttributeTypeApplicationJSONInternalServerError as json.
func (s *GetAttributeTypeApplicationJSONInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetAttributeTypeApplicationJSONInternalServerError from json.
func (s *GetAttributeTypeApplicationJSONInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAttributeTypeApplicationJSONInternalServerError to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetAttributeTypeApplicationJSONInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAttributeTypeApplicationJSONInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAttributeTypeApplicationJSONInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetAttributeTypeApplicationJSONNotFound as json.
func (s *GetAttributeTypeApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetAttributeTypeApplicationJSONNotFound from json.
func (s *GetAttributeTypeApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAttributeTypeApplicationJSONNotFound to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetAttributeTypeApplicationJSONNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAttributeTypeApplicationJSONNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAttributeTypeApplicationJSONNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetEntityByEntityIdApplicationJSONInternalServerError as json.
func (s *GetEntityByEntityIdApplicationJSONInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetEntityByEntityIdApplicationJSONInternalServerError from json.
func (s *GetEntityByEntityIdApplicationJSONInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetEntityByEntityIdApplicationJSONInternalServerError to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetEntityByEntityIdApplicationJSONInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetEntityByEntityIdApplicationJSONInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetEntityByEntityIdApplicationJSONInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetEntityByEntityIdApplicationJSONNotFound as json.
func (s *GetEntityByEntityIdApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetEntityByEntityIdApplicationJSONNotFound from json.
func (s *GetEntityByEntityIdApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetEntityByEntityIdApplicationJSONNotFound to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetEntityByEntityIdApplicationJSONNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetEntityByEntityIdApplicationJSONNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetEntityByEntityIdApplicationJSONNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetEntityByRecordIdApplicationJSONInternalServerError as json.
func (s *GetEntityByRecordIdApplicationJSONInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetEntityByRecordIdApplicationJSONInternalServerError from json.
func (s *GetEntityByRecordIdApplicationJSONInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetEntityByRecordIdApplicationJSONInternalServerError to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetEntityByRecordIdApplicationJSONInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetEntityByRecordIdApplicationJSONInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetEntityByRecordIdApplicationJSONInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetEntityByRecordIdApplicationJSONNotFound as json.
func (s *GetEntityByRecordIdApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetEntityByRecordIdApplicationJSONNotFound from json.
func (s *GetEntityByRecordIdApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetEntityByRecordIdApplicationJSONNotFound to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetEntityByRecordIdApplicationJSONNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetEntityByRecordIdApplicationJSONNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetEntityByRecordIdApplicationJSONNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetRecordApplicationJSONInternalServerError as json.
func (s *GetRecordApplicationJSONInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetRecordApplicationJSONInternalServerError from json.
func (s *GetRecordApplicationJSONInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRecordApplicationJSONInternalServerError to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetRecordApplicationJSONInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRecordApplicationJSONInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRecordApplicationJSONInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetRecordApplicationJSONNotFound as json.
func (s *GetRecordApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetRecordApplicationJSONNotFound from json.
func (s *GetRecordApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRecordApplicationJSONNotFound to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetRecordApplicationJSONNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRecordApplicationJSONNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRecordApplicationJSONNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVirtualEntityByRecordIdsApplicationJSONBadRequest as json.
func (s *GetVirtualEntityByRecordIdsApplicationJSONBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVirtualEntityByRecordIdsApplicationJSONBadRequest from json.
func (s *GetVirtualEntityByRecordIdsApplicationJSONBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVirtualEntityByRecordIdsApplicationJSONBadRequest to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVirtualEntityByRecordIdsApplicationJSONBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVirtualEntityByRecordIdsApplicationJSONBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVirtualEntityByRecordIdsApplicationJSONBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVirtualEntityByRecordIdsApplicationJSONInternalServerError as json.
func (s *GetVirtualEntityByRecordIdsApplicationJSONInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVirtualEntityByRecordIdsApplicationJSONInternalServerError from json.
func (s *GetVirtualEntityByRecordIdsApplicationJSONInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVirtualEntityByRecordIdsApplicationJSONInternalServerError to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVirtualEntityByRecordIdsApplicationJSONInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVirtualEntityByRecordIdsApplicationJSONInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVirtualEntityByRecordIdsApplicationJSONInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HowEntityByEntityIDApplicationJSONInternalServerError as json.
func (s *HowEntityByEntityIDApplicationJSONInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes HowEntityByEntityIDApplicationJSONInternalServerError from json.
func (s *HowEntityByEntityIDApplicationJSONInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HowEntityByEntityIDApplicationJSONInternalServerError to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = HowEntityByEntityIDApplicationJSONInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HowEntityByEntityIDApplicationJSONInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HowEntityByEntityIDApplicationJSONInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HowEntityByEntityIDApplicationJSONNotFound as json.
func (s *HowEntityByEntityIDApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes HowEntityByEntityIDApplicationJSONNotFound from json.
func (s *HowEntityByEntityIDApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HowEntityByEntityIDApplicationJSONNotFound to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = HowEntityByEntityIDApplicationJSONNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HowEntityByEntityIDApplicationJSONNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HowEntityByEntityIDApplicationJSONNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HowEntityByRecordIDApplicationJSONInternalServerError as json.
func (s *HowEntityByRecordIDApplicationJSONInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes HowEntityByRecordIDApplicationJSONInternalServerError from json.
func (s *HowEntityByRecordIDApplicationJSONInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HowEntityByRecordIDApplicationJSONInternalServerError to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = HowEntityByRecordIDApplicationJSONInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HowEntityByRecordIDApplicationJSONInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HowEntityByRecordIDApplicationJSONInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HowEntityByRecordIDApplicationJSONNotFound as json.
func (s *HowEntityByRecordIDApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes HowEntityByRecordIDApplicationJSONNotFound from json.
func (s *HowEntityByRecordIDApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HowEntityByRecordIDApplicationJSONNotFound to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = HowEntityByRecordIDApplicationJSONNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HowEntityByRecordIDApplicationJSONNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HowEntityByRecordIDApplicationJSONNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LoadBulkRecordsApplicationJSONForbidden as json.
func (s *LoadBulkRecordsApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes LoadBulkRecordsApplicationJSONForbidden from json.
func (s *LoadBulkRecordsApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LoadBulkRecordsApplicationJSONForbidden to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = LoadBulkRecordsApplicationJSONForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LoadBulkRecordsApplicationJSONForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LoadBulkRecordsApplicationJSONForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LoadBulkRecordsApplicationJSONInternalServerError as json.
func (s *LoadBulkRecordsApplicationJSONInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes LoadBulkRecordsApplicationJSONInternalServerError from json.
func (s *LoadBulkRecordsApplicationJSONInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LoadBulkRecordsApplicationJSONInternalServerError to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = LoadBulkRecordsApplicationJSONInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LoadBulkRecordsApplicationJSONInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LoadBulkRecordsApplicationJSONInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LoadBulkRecordsReqApplicationJSON as json.
func (s LoadBulkRecordsReqApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes LoadBulkRecordsReqApplicationJSON from json.
func (s *LoadBulkRecordsReqApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LoadBulkRecordsReqApplicationJSON to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = LoadBulkRecordsReqApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LoadBulkRecordsReqApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LoadBulkRecordsReqApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes int16 as json.
func (o OptInt16) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int16(int16(o.Value))
}

// Decode decodes int16 from json.
func (o *OptInt16) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt16 to nil")
	}
	o.Set = true
	v, err := d.Int16()
	if err != nil {
		return err
	}
	o.Value = int16(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt16) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt16) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int32 as json.
func (o OptInt32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes int32 from json.
func (o *OptInt32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt32 to nil")
	}
	o.Set = true
	v, err := d.Int32()
	if err != nil {
		return err
	}
	o.Value = int32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int64 as json.
func (o OptInt64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int64(int64(o.Value))
}

// Decode decodes int64 from json.
func (o *OptInt64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt64 to nil")
	}
	o.Set = true
	v, err := d.Int64()
	if err != nil {
		return err
	}
	o.Value = int64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int8 as json.
func (o OptInt8) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int8(int8(o.Value))
}

// Decode decodes int8 from json.
func (o *OptInt8) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt8 to nil")
	}
	o.Set = true
	v, err := d.Int8()
	if err != nil {
		return err
	}
	o.Value = int8(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt8) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt8) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptNilBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptNilBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilBool to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v bool
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int32 as json.
func (o OptNilInt32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes int32 from json.
func (o *OptNilInt32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilInt32 to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v int32
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Int32()
	if err != nil {
		return err
	}
	o.Value = int32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilInt32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilInt32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []int64 as json.
func (o OptNilInt64Array) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		e.Int64(elem)
	}
	e.ArrEnd()
}

// Decode decodes []int64 from json.
func (o *OptNilInt64Array) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilInt64Array to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []int64
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]int64, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem int64
		v, err := d.Int64()
		elem = int64(v)
		if err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilInt64Array) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilInt64Array) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptNilString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptNilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []string as json.
func (o OptNilStringArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		e.Str(elem)
	}
	e.ArrEnd()
}

// Decode decodes []string from json.
func (o *OptNilStringArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilStringArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]string, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem string
		v, err := d.Str()
		elem = string(v)
		if err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilStringArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilStringArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzAttributeSearchResponseRawData as json.
func (o OptNilSzAttributeSearchResponseRawData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzAttributeSearchResponseRawData from json.
func (o *OptNilSzAttributeSearchResponseRawData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSzAttributeSearchResponseRawData to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SzAttributeSearchResponseRawData
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(SzAttributeSearchResponseRawData)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSzAttributeSearchResponseRawData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSzAttributeSearchResponseRawData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzAttributeSearchResultFeatureScores as json.
func (o OptNilSzAttributeSearchResultFeatureScores) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzAttributeSearchResultFeatureScores from json.
func (o *OptNilSzAttributeSearchResultFeatureScores) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSzAttributeSearchResultFeatureScores to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SzAttributeSearchResultFeatureScores
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(SzAttributeSearchResultFeatureScores)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSzAttributeSearchResultFeatureScores) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSzAttributeSearchResultFeatureScores) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzAttributeTypeResponseRawData as json.
func (o OptNilSzAttributeTypeResponseRawData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzAttributeTypeResponseRawData from json.
func (o *OptNilSzAttributeTypeResponseRawData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSzAttributeTypeResponseRawData to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SzAttributeTypeResponseRawData
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(SzAttributeTypeResponseRawData)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSzAttributeTypeResponseRawData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSzAttributeTypeResponseRawData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzAttributeTypesResponseRawData as json.
func (o OptNilSzAttributeTypesResponseRawData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzAttributeTypesResponseRawData from json.
func (o *OptNilSzAttributeTypesResponseRawData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSzAttributeTypesResponseRawData to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SzAttributeTypesResponseRawData
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(SzAttributeTypesResponseRawData)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSzAttributeTypesResponseRawData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSzAttributeTypesResponseRawData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzConfigResponseRawData as json.
func (o OptNilSzConfigResponseRawData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzConfigResponseRawData from json.
func (o *OptNilSzConfigResponseRawData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSzConfigResponseRawData to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SzConfigResponseRawData
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(SzConfigResponseRawData)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSzConfigResponseRawData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSzConfigResponseRawData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzDataSourceResponseRawData as json.
func (o OptNilSzDataSourceResponseRawData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzDataSourceResponseRawData from json.
func (o *OptNilSzDataSourceResponseRawData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSzDataSourceResponseRawData to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SzDataSourceResponseRawData
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(SzDataSourceResponseRawData)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSzDataSourceResponseRawData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSzDataSourceResponseRawData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzDataSourcesResponseRawData as json.
func (o OptNilSzDataSourcesResponseRawData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzDataSourcesResponseRawData from json.
func (o *OptNilSzDataSourcesResponseRawData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSzDataSourcesResponseRawData to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SzDataSourcesResponseRawData
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(SzDataSourcesResponseRawData)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSzDataSourcesResponseRawData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSzDataSourcesResponseRawData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzDeleteRecordResponseRawData as json.
func (o OptNilSzDeleteRecordResponseRawData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzDeleteRecordResponseRawData from json.
func (o *OptNilSzDeleteRecordResponseRawData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSzDeleteRecordResponseRawData to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SzDeleteRecordResponseRawData
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(SzDeleteRecordResponseRawData)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSzDeleteRecordResponseRawData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSzDeleteRecordResponseRawData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []SzDisclosedRelation as json.
func (o OptNilSzDisclosedRelationArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []SzDisclosedRelation from json.
func (o *OptNilSzDisclosedRelationArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSzDisclosedRelationArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []SzDisclosedRelation
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]SzDisclosedRelation, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem SzDisclosedRelation
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSzDisclosedRelationArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSzDisclosedRelationArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzEntityNetworkResponseRawData as json.
func (o OptNilSzEntityNetworkResponseRawData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzEntityNetworkResponseRawData from json.
func (o *OptNilSzEntityNetworkResponseRawData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSzEntityNetworkResponseRawData to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SzEntityNetworkResponseRawData
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(SzEntityNetworkResponseRawData)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSzEntityNetworkResponseRawData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSzEntityNetworkResponseRawData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzEntityPathResponseRawData as json.
func (o OptNilSzEntityPathResponseRawData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzEntityPathResponseRawData from json.
func (o *OptNilSzEntityPathResponseRawData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSzEntityPathResponseRawData to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SzEntityPathResponseRawData
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(SzEntityPathResponseRawData)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSzEntityPathResponseRawData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSzEntityPathResponseRawData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzEntityResponseRawData as json.
func (o OptNilSzEntityResponseRawData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzEntityResponseRawData from json.
func (o *OptNilSzEntityResponseRawData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSzEntityResponseRawData to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SzEntityResponseRawData
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(SzEntityResponseRawData)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSzEntityResponseRawData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSzEntityResponseRawData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []SzFeatureReference as json.
func (o OptNilSzFeatureReferenceArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []SzFeatureReference from json.
func (o *OptNilSzFeatureReferenceArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSzFeatureReferenceArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []SzFeatureReference
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]SzFeatureReference, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem SzFeatureReference
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSzFeatureReferenceArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSzFeatureReferenceArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzHowEntityResponseRawData as json.
func (o OptNilSzHowEntityResponseRawData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzHowEntityResponseRawData from json.
func (o *OptNilSzHowEntityResponseRawData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSzHowEntityResponseRawData to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SzHowEntityResponseRawData
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(SzHowEntityResponseRawData)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSzHowEntityResponseRawData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSzHowEntityResponseRawData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzHowMatchInfoFeatureScores as json.
func (o OptNilSzHowMatchInfoFeatureScores) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzHowMatchInfoFeatureScores from json.
func (o *OptNilSzHowMatchInfoFeatureScores) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSzHowMatchInfoFeatureScores to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SzHowMatchInfoFeatureScores
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(SzHowMatchInfoFeatureScores)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSzHowMatchInfoFeatureScores) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSzHowMatchInfoFeatureScores) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzLicenseResponseRawData as json.
func (o OptNilSzLicenseResponseRawData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzLicenseResponseRawData from json.
func (o *OptNilSzLicenseResponseRawData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSzLicenseResponseRawData to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SzLicenseResponseRawData
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(SzLicenseResponseRawData)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSzLicenseResponseRawData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSzLicenseResponseRawData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzLoadRecordResponseRawData as json.
func (o OptNilSzLoadRecordResponseRawData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzLoadRecordResponseRawData from json.
func (o *OptNilSzLoadRecordResponseRawData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSzLoadRecordResponseRawData to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SzLoadRecordResponseRawData
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(SzLoadRecordResponseRawData)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSzLoadRecordResponseRawData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSzLoadRecordResponseRawData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzMetaTimings as json.
func (o OptNilSzMetaTimings) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzMetaTimings from json.
func (o *OptNilSzMetaTimings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSzMetaTimings to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SzMetaTimings
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(SzMetaTimings)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSzMetaTimings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSzMetaTimings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzRecordResponseRawData as json.
func (o OptNilSzRecordResponseRawData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzRecordResponseRawData from json.
func (o *OptNilSzRecordResponseRawData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSzRecordResponseRawData to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SzRecordResponseRawData
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(SzRecordResponseRawData)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSzRecordResponseRawData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSzRecordResponseRawData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzReevaluateResponseRawData as json.
func (o OptNilSzReevaluateResponseRawData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzReevaluateResponseRawData from json.
func (o *OptNilSzReevaluateResponseRawData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSzReevaluateResponseRawData to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SzReevaluateResponseRawData
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(SzReevaluateResponseRawData)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSzReevaluateResponseRawData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSzReevaluateResponseRawData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzVersionResponseRawData as json.
func (o OptNilSzVersionResponseRawData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzVersionResponseRawData from json.
func (o *OptNilSzVersionResponseRawData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSzVersionResponseRawData to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SzVersionResponseRawData
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(SzVersionResponseRawData)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSzVersionResponseRawData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSzVersionResponseRawData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzVirtualEntityResponseRawData as json.
func (o OptNilSzVirtualEntityResponseRawData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzVirtualEntityResponseRawData from json.
func (o *OptNilSzVirtualEntityResponseRawData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSzVirtualEntityResponseRawData to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SzVirtualEntityResponseRawData
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(SzVirtualEntityResponseRawData)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSzVirtualEntityResponseRawData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSzVirtualEntityResponseRawData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzWhyEntitiesResponseRawData as json.
func (o OptNilSzWhyEntitiesResponseRawData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzWhyEntitiesResponseRawData from json.
func (o *OptNilSzWhyEntitiesResponseRawData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSzWhyEntitiesResponseRawData to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SzWhyEntitiesResponseRawData
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(SzWhyEntitiesResponseRawData)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSzWhyEntitiesResponseRawData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSzWhyEntitiesResponseRawData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzWhyEntityResponseRawData as json.
func (o OptNilSzWhyEntityResponseRawData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzWhyEntityResponseRawData from json.
func (o *OptNilSzWhyEntityResponseRawData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSzWhyEntityResponseRawData to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SzWhyEntityResponseRawData
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(SzWhyEntityResponseRawData)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSzWhyEntityResponseRawData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSzWhyEntityResponseRawData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzWhyMatchInfoCandidateKeys as json.
func (o OptNilSzWhyMatchInfoCandidateKeys) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzWhyMatchInfoCandidateKeys from json.
func (o *OptNilSzWhyMatchInfoCandidateKeys) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSzWhyMatchInfoCandidateKeys to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SzWhyMatchInfoCandidateKeys
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(SzWhyMatchInfoCandidateKeys)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSzWhyMatchInfoCandidateKeys) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSzWhyMatchInfoCandidateKeys) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzWhyMatchInfoFeatureScores as json.
func (o OptNilSzWhyMatchInfoFeatureScores) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzWhyMatchInfoFeatureScores from json.
func (o *OptNilSzWhyMatchInfoFeatureScores) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSzWhyMatchInfoFeatureScores to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SzWhyMatchInfoFeatureScores
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(SzWhyMatchInfoFeatureScores)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSzWhyMatchInfoFeatureScores) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSzWhyMatchInfoFeatureScores) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzWhyRecordsResponseRawData as json.
func (o OptNilSzWhyRecordsResponseRawData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzWhyRecordsResponseRawData from json.
func (o *OptNilSzWhyRecordsResponseRawData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSzWhyRecordsResponseRawData to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SzWhyRecordsResponseRawData
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(SzWhyRecordsResponseRawData)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSzWhyRecordsResponseRawData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSzWhyRecordsResponseRawData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzAttributeClass as json.
func (o OptSzAttributeClass) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SzAttributeClass from json.
func (o *OptSzAttributeClass) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzAttributeClass to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzAttributeClass) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzAttributeClass) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzAttributeNecessity as json.
func (o OptSzAttributeNecessity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SzAttributeNecessity from json.
func (o *OptSzAttributeNecessity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzAttributeNecessity to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzAttributeNecessity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzAttributeNecessity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzAttributeSearchResponseData as json.
func (o OptSzAttributeSearchResponseData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzAttributeSearchResponseData from json.
func (o *OptSzAttributeSearchResponseData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzAttributeSearchResponseData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzAttributeSearchResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzAttributeSearchResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzAttributeSearchResultFeatures as json.
func (o OptSzAttributeSearchResultFeatures) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzAttributeSearchResultFeatures from json.
func (o *OptSzAttributeSearchResultFeatures) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzAttributeSearchResultFeatures to nil")
	}
	o.Set = true
	o.Value = make(SzAttributeSearchResultFeatures)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzAttributeSearchResultFeatures) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzAttributeSearchResultFeatures) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzAttributeSearchResultType as json.
func (o OptSzAttributeSearchResultType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SzAttributeSearchResultType from json.
func (o *OptSzAttributeSearchResultType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzAttributeSearchResultType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzAttributeSearchResultType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzAttributeSearchResultType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzAttributeType as json.
func (o OptSzAttributeType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzAttributeType from json.
func (o *OptSzAttributeType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzAttributeType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzAttributeType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzAttributeType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzAttributeTypeResponseData as json.
func (o OptSzAttributeTypeResponseData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzAttributeTypeResponseData from json.
func (o *OptSzAttributeTypeResponseData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzAttributeTypeResponseData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzAttributeTypeResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzAttributeTypeResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzAttributeTypesResponseData as json.
func (o OptSzAttributeTypesResponseData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzAttributeTypesResponseData from json.
func (o *OptSzAttributeTypesResponseData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzAttributeTypesResponseData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzAttributeTypesResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzAttributeTypesResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzBulkDataAnalysis as json.
func (o OptSzBulkDataAnalysis) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzBulkDataAnalysis from json.
func (o *OptSzBulkDataAnalysis) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzBulkDataAnalysis to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzBulkDataAnalysis) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzBulkDataAnalysis) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzBulkDataStatus as json.
func (o OptSzBulkDataStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SzBulkDataStatus from json.
func (o *OptSzBulkDataStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzBulkDataStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzBulkDataStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzBulkDataStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzBulkLoadResult as json.
func (o OptSzBulkLoadResult) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzBulkLoadResult from json.
func (o *OptSzBulkLoadResult) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzBulkLoadResult to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzBulkLoadResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzBulkLoadResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzDataSource as json.
func (o OptSzDataSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzDataSource from json.
func (o *OptSzDataSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzDataSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzDataSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzDataSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzDataSourceResponseData as json.
func (o OptSzDataSourceResponseData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzDataSourceResponseData from json.
func (o *OptSzDataSourceResponseData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzDataSourceResponseData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzDataSourceResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzDataSourceResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzDataSourcesResponseData as json.
func (o OptSzDataSourcesResponseData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzDataSourcesResponseData from json.
func (o *OptSzDataSourcesResponseData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzDataSourcesResponseData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzDataSourcesResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzDataSourcesResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzDataSourcesResponseDataDataSourceDetails as json.
func (o OptSzDataSourcesResponseDataDataSourceDetails) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzDataSourcesResponseDataDataSourceDetails from json.
func (o *OptSzDataSourcesResponseDataDataSourceDetails) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzDataSourcesResponseDataDataSourceDetails to nil")
	}
	o.Set = true
	o.Value = make(SzDataSourcesResponseDataDataSourceDetails)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzDataSourcesResponseDataDataSourceDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzDataSourcesResponseDataDataSourceDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzDeleteRecordResponseData as json.
func (o OptSzDeleteRecordResponseData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzDeleteRecordResponseData from json.
func (o *OptSzDeleteRecordResponseData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzDeleteRecordResponseData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzDeleteRecordResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzDeleteRecordResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzEntityData as json.
func (o OptSzEntityData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzEntityData from json.
func (o *OptSzEntityData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzEntityData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzEntityData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzEntityData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzEntityFeatureStatistics as json.
func (o OptSzEntityFeatureStatistics) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzEntityFeatureStatistics from json.
func (o *OptSzEntityFeatureStatistics) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzEntityFeatureStatistics to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzEntityFeatureStatistics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzEntityFeatureStatistics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzEntityNetworkData as json.
func (o OptSzEntityNetworkData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzEntityNetworkData from json.
func (o *OptSzEntityNetworkData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzEntityNetworkData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzEntityNetworkData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzEntityNetworkData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzEntityPath as json.
func (o OptSzEntityPath) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzEntityPath from json.
func (o *OptSzEntityPath) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzEntityPath to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzEntityPath) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzEntityPath) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzEntityPathData as json.
func (o OptSzEntityPathData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzEntityPathData from json.
func (o *OptSzEntityPathData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzEntityPathData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzEntityPathData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzEntityPathData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzEntityRecord as json.
func (o OptSzEntityRecord) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzEntityRecord from json.
func (o *OptSzEntityRecord) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzEntityRecord to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzEntityRecord) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzEntityRecord) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzEntityRecordOriginalSourceData as json.
func (o OptSzEntityRecordOriginalSourceData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzEntityRecordOriginalSourceData from json.
func (o *OptSzEntityRecordOriginalSourceData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzEntityRecordOriginalSourceData to nil")
	}
	o.Set = true
	o.Value = make(SzEntityRecordOriginalSourceData)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzEntityRecordOriginalSourceData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzEntityRecordOriginalSourceData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzError as json.
func (o OptSzError) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzError from json.
func (o *OptSzError) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzError to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzHowEntityResult as json.
func (o OptSzHowEntityResult) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzHowEntityResult from json.
func (o *OptSzHowEntityResult) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzHowEntityResult to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzHowEntityResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzHowEntityResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzHowEntityResultResolutionSteps as json.
func (o OptSzHowEntityResultResolutionSteps) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzHowEntityResultResolutionSteps from json.
func (o *OptSzHowEntityResultResolutionSteps) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzHowEntityResultResolutionSteps to nil")
	}
	o.Set = true
	o.Value = make(SzHowEntityResultResolutionSteps)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzHowEntityResultResolutionSteps) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzHowEntityResultResolutionSteps) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzHowMatchInfo as json.
func (o OptSzHowMatchInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzHowMatchInfo from json.
func (o *OptSzHowMatchInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzHowMatchInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzHowMatchInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzHowMatchInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzHttpMethod as json.
func (o OptSzHttpMethod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SzHttpMethod from json.
func (o *OptSzHttpMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzHttpMethod to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzHttpMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzHttpMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzLicenseInfo as json.
func (o OptSzLicenseInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzLicenseInfo from json.
func (o *OptSzLicenseInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzLicenseInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzLicenseInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzLicenseInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzLicenseResponseData as json.
func (o OptSzLicenseResponseData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzLicenseResponseData from json.
func (o *OptSzLicenseResponseData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzLicenseResponseData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzLicenseResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzLicenseResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzLinks as json.
func (o OptSzLinks) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzLinks from json.
func (o *OptSzLinks) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzLinks to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzLinks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzLinks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzLoadRecordResponseData as json.
func (o OptSzLoadRecordResponseData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzLoadRecordResponseData from json.
func (o *OptSzLoadRecordResponseData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzLoadRecordResponseData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzLoadRecordResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzLoadRecordResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzMatchLevel as json.
func (o OptSzMatchLevel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SzMatchLevel from json.
func (o *OptSzMatchLevel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzMatchLevel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzMatchLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzMatchLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzMatchedRecordOriginalSourceData as json.
func (o OptSzMatchedRecordOriginalSourceData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzMatchedRecordOriginalSourceData from json.
func (o *OptSzMatchedRecordOriginalSourceData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzMatchedRecordOriginalSourceData to nil")
	}
	o.Set = true
	o.Value = make(SzMatchedRecordOriginalSourceData)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzMatchedRecordOriginalSourceData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzMatchedRecordOriginalSourceData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzMeta as json.
func (o OptSzMeta) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzMeta from json.
func (o *OptSzMeta) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzMeta to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzNameScoring as json.
func (o OptSzNameScoring) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzNameScoring from json.
func (o *OptSzNameScoring) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzNameScoring to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzNameScoring) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzNameScoring) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzRecordResponseData as json.
func (o OptSzRecordResponseData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzRecordResponseData from json.
func (o *OptSzRecordResponseData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzRecordResponseData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzRecordResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzRecordResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzReevaluateResponseData as json.
func (o OptSzReevaluateResponseData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzReevaluateResponseData from json.
func (o *OptSzReevaluateResponseData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzReevaluateResponseData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzReevaluateResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzReevaluateResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzRelatedEntityFeatures as json.
func (o OptSzRelatedEntityFeatures) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzRelatedEntityFeatures from json.
func (o *OptSzRelatedEntityFeatures) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzRelatedEntityFeatures to nil")
	}
	o.Set = true
	o.Value = make(SzRelatedEntityFeatures)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzRelatedEntityFeatures) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzRelatedEntityFeatures) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzRelationDirection as json.
func (o OptSzRelationDirection) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SzRelationDirection from json.
func (o *OptSzRelationDirection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzRelationDirection to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzRelationDirection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzRelationDirection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzRelationshipType as json.
func (o OptSzRelationshipType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SzRelationshipType from json.
func (o *OptSzRelationshipType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzRelationshipType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzRelationshipType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzRelationshipType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzResolutionInfo as json.
func (o OptSzResolutionInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzResolutionInfo from json.
func (o *OptSzResolutionInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzResolutionInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzResolutionInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzResolutionInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzResolvedEntity as json.
func (o OptSzResolvedEntity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzResolvedEntity from json.
func (o *OptSzResolvedEntity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzResolvedEntity to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzResolvedEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzResolvedEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzResolvedEntityFeatures as json.
func (o OptSzResolvedEntityFeatures) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzResolvedEntityFeatures from json.
func (o *OptSzResolvedEntityFeatures) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzResolvedEntityFeatures to nil")
	}
	o.Set = true
	o.Value = make(SzResolvedEntityFeatures)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzResolvedEntityFeatures) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzResolvedEntityFeatures) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzScoredFeature as json.
func (o OptSzScoredFeature) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzScoredFeature from json.
func (o *OptSzScoredFeature) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzScoredFeature to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzScoredFeature) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzScoredFeature) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzScoringBehavior as json.
func (o OptSzScoringBehavior) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzScoringBehavior from json.
func (o *OptSzScoringBehavior) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzScoringBehavior to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzScoringBehavior) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzScoringBehavior) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzScoringBucket as json.
func (o OptSzScoringBucket) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SzScoringBucket from json.
func (o *OptSzScoringBucket) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzScoringBucket to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzScoringBucket) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzScoringBucket) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzScoringFrequency as json.
func (o OptSzScoringFrequency) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SzScoringFrequency from json.
func (o *OptSzScoringFrequency) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzScoringFrequency to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzScoringFrequency) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzScoringFrequency) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzServerInfo as json.
func (o OptSzServerInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzServerInfo from json.
func (o *OptSzServerInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzServerInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzServerInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzServerInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzVersionInfo as json.
func (o OptSzVersionInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzVersionInfo from json.
func (o *OptSzVersionInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzVersionInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzVersionInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzVersionInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzVirtualEntity as json.
func (o OptSzVirtualEntity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzVirtualEntity from json.
func (o *OptSzVirtualEntity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzVirtualEntity to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzVirtualEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzVirtualEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzVirtualEntityData as json.
func (o OptSzVirtualEntityData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzVirtualEntityData from json.
func (o *OptSzVirtualEntityData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzVirtualEntityData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzVirtualEntityData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzVirtualEntityData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzWhyEntitiesResponseData as json.
func (o OptSzWhyEntitiesResponseData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzWhyEntitiesResponseData from json.
func (o *OptSzWhyEntitiesResponseData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzWhyEntitiesResponseData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzWhyEntitiesResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzWhyEntitiesResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzWhyEntitiesResult as json.
func (o OptSzWhyEntitiesResult) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzWhyEntitiesResult from json.
func (o *OptSzWhyEntitiesResult) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzWhyEntitiesResult to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzWhyEntitiesResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzWhyEntitiesResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzWhyEntityResponseData as json.
func (o OptSzWhyEntityResponseData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzWhyEntityResponseData from json.
func (o *OptSzWhyEntityResponseData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzWhyEntityResponseData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzWhyEntityResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzWhyEntityResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzWhyMatchInfo as json.
func (o OptSzWhyMatchInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzWhyMatchInfo from json.
func (o *OptSzWhyMatchInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzWhyMatchInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzWhyMatchInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzWhyMatchInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzWhyRecordsResponseData as json.
func (o OptSzWhyRecordsResponseData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzWhyRecordsResponseData from json.
func (o *OptSzWhyRecordsResponseData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzWhyRecordsResponseData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzWhyRecordsResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzWhyRecordsResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzWhyRecordsResult as json.
func (o OptSzWhyRecordsResult) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SzWhyRecordsResult from json.
func (o *OptSzWhyRecordsResult) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSzWhyRecordsResult to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSzWhyRecordsResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSzWhyRecordsResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReevaluateEntityApplicationJSONInternalServerError as json.
func (s *ReevaluateEntityApplicationJSONInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReevaluateEntityApplicationJSONInternalServerError from json.
func (s *ReevaluateEntityApplicationJSONInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReevaluateEntityApplicationJSONInternalServerError to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReevaluateEntityApplicationJSONInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReevaluateEntityApplicationJSONInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReevaluateEntityApplicationJSONInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReevaluateEntityApplicationJSONNotFound as json.
func (s *ReevaluateEntityApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReevaluateEntityApplicationJSONNotFound from json.
func (s *ReevaluateEntityApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReevaluateEntityApplicationJSONNotFound to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReevaluateEntityApplicationJSONNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReevaluateEntityApplicationJSONNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReevaluateEntityApplicationJSONNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReevaluateRecordApplicationJSONInternalServerError as json.
func (s *ReevaluateRecordApplicationJSONInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReevaluateRecordApplicationJSONInternalServerError from json.
func (s *ReevaluateRecordApplicationJSONInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReevaluateRecordApplicationJSONInternalServerError to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReevaluateRecordApplicationJSONInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReevaluateRecordApplicationJSONInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReevaluateRecordApplicationJSONInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReevaluateRecordApplicationJSONNotFound as json.
func (s *ReevaluateRecordApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReevaluateRecordApplicationJSONNotFound from json.
func (s *ReevaluateRecordApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReevaluateRecordApplicationJSONNotFound to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReevaluateRecordApplicationJSONNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReevaluateRecordApplicationJSONNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReevaluateRecordApplicationJSONNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SearchEntitiesByGetApplicationJSONBadRequest as json.
func (s *SearchEntitiesByGetApplicationJSONBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes SearchEntitiesByGetApplicationJSONBadRequest from json.
func (s *SearchEntitiesByGetApplicationJSONBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchEntitiesByGetApplicationJSONBadRequest to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SearchEntitiesByGetApplicationJSONBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchEntitiesByGetApplicationJSONBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchEntitiesByGetApplicationJSONBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SearchEntitiesByGetApplicationJSONInternalServerError as json.
func (s *SearchEntitiesByGetApplicationJSONInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes SearchEntitiesByGetApplicationJSONInternalServerError from json.
func (s *SearchEntitiesByGetApplicationJSONInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchEntitiesByGetApplicationJSONInternalServerError to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SearchEntitiesByGetApplicationJSONInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchEntitiesByGetApplicationJSONInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchEntitiesByGetApplicationJSONInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SearchEntitiesByPostApplicationJSONBadRequest as json.
func (s *SearchEntitiesByPostApplicationJSONBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes SearchEntitiesByPostApplicationJSONBadRequest from json.
func (s *SearchEntitiesByPostApplicationJSONBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchEntitiesByPostApplicationJSONBadRequest to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SearchEntitiesByPostApplicationJSONBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchEntitiesByPostApplicationJSONBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchEntitiesByPostApplicationJSONBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SearchEntitiesByPostApplicationJSONInternalServerError as json.
func (s *SearchEntitiesByPostApplicationJSONInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes SearchEntitiesByPostApplicationJSONInternalServerError from json.
func (s *SearchEntitiesByPostApplicationJSONInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchEntitiesByPostApplicationJSONInternalServerError to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SearchEntitiesByPostApplicationJSONInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchEntitiesByPostApplicationJSONInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchEntitiesByPostApplicationJSONInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SearchEntitiesByPostReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SearchEntitiesByPostReq) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SearchEntitiesByPostReq from json.
func (s *SearchEntitiesByPostReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchEntitiesByPostReq to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchEntitiesByPostReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SearchEntitiesByPostReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchEntitiesByPostReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzAttributeClass as json.
func (s SzAttributeClass) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SzAttributeClass from json.
func (s *SzAttributeClass) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzAttributeClass to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SzAttributeClass(v) {
	case SzAttributeClassADDRESS:
		*s = SzAttributeClassADDRESS
	case SzAttributeClassCHARACTERISTIC:
		*s = SzAttributeClassCHARACTERISTIC
	case SzAttributeClassIDENTIFIER:
		*s = SzAttributeClassIDENTIFIER
	case SzAttributeClassNAME:
		*s = SzAttributeClassNAME
	case SzAttributeClassOBSERVATION:
		*s = SzAttributeClassOBSERVATION
	case SzAttributeClassPHONE:
		*s = SzAttributeClassPHONE
	case SzAttributeClassRELATIONSHIP:
		*s = SzAttributeClassRELATIONSHIP
	case SzAttributeClassOTHER:
		*s = SzAttributeClassOTHER
	default:
		*s = SzAttributeClass(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SzAttributeClass) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzAttributeClass) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzAttributeNecessity as json.
func (s SzAttributeNecessity) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SzAttributeNecessity from json.
func (s *SzAttributeNecessity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzAttributeNecessity to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SzAttributeNecessity(v) {
	case SzAttributeNecessityREQUIRED:
		*s = SzAttributeNecessityREQUIRED
	case SzAttributeNecessitySUFFICIENT:
		*s = SzAttributeNecessitySUFFICIENT
	case SzAttributeNecessityPREFERRED:
		*s = SzAttributeNecessityPREFERRED
	case SzAttributeNecessityOPTIONAL:
		*s = SzAttributeNecessityOPTIONAL
	default:
		*s = SzAttributeNecessity(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SzAttributeNecessity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzAttributeNecessity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzAttributeSearchResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzAttributeSearchResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
	{
		if s.Links.Set {
			e.FieldStart("links")
			s.Links.Encode(e)
		}
	}
	{
		if s.RawData.Set {
			e.FieldStart("rawData")
			s.RawData.Encode(e)
		}
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzAttributeSearchResponse = [4]string{
	0: "meta",
	1: "links",
	2: "rawData",
	3: "data",
}

// Decode decodes SzAttributeSearchResponse from json.
func (s *SzAttributeSearchResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzAttributeSearchResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		case "links":
			if err := func() error {
				s.Links.Reset()
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		case "rawData":
			if err := func() error {
				s.RawData.Reset()
				if err := s.RawData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawData\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzAttributeSearchResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzAttributeSearchResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzAttributeSearchResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzAttributeSearchResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzAttributeSearchResponseData) encodeFields(e *jx.Encoder) {
	{
		if s.SearchResults != nil {
			e.FieldStart("searchResults")
			e.ArrStart()
			for _, elem := range s.SearchResults {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSzAttributeSearchResponseData = [1]string{
	0: "searchResults",
}

// Decode decodes SzAttributeSearchResponseData from json.
func (s *SzAttributeSearchResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzAttributeSearchResponseData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "searchResults":
			if err := func() error {
				s.SearchResults = make([]SzAttributeSearchResult, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SzAttributeSearchResult
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SearchResults = append(s.SearchResults, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"searchResults\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzAttributeSearchResponseData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzAttributeSearchResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzAttributeSearchResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SzAttributeSearchResponseRawData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SzAttributeSearchResponseRawData) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SzAttributeSearchResponseRawData from json.
func (s *SzAttributeSearchResponseRawData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzAttributeSearchResponseRawData to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzAttributeSearchResponseRawData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SzAttributeSearchResponseRawData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzAttributeSearchResponseRawData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzAttributeSearchResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzAttributeSearchResult) encodeFields(e *jx.Encoder) {
	{
		if s.EntityId.Set {
			e.FieldStart("entityId")
			s.EntityId.Encode(e)
		}
	}
	{
		if s.EntityName.Set {
			e.FieldStart("entityName")
			s.EntityName.Encode(e)
		}
	}
	{
		if s.BestName.Set {
			e.FieldStart("bestName")
			s.BestName.Encode(e)
		}
	}
	{
		if s.RecordSummaries != nil {
			e.FieldStart("recordSummaries")
			e.ArrStart()
			for _, elem := range s.RecordSummaries {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NameData != nil {
			e.FieldStart("nameData")
			e.ArrStart()
			for _, elem := range s.NameData {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CharacteristicData != nil {
			e.FieldStart("characteristicData")
			e.ArrStart()
			for _, elem := range s.CharacteristicData {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AddressData != nil {
			e.FieldStart("addressData")
			e.ArrStart()
			for _, elem := range s.AddressData {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PhoneData != nil {
			e.FieldStart("phoneData")
			e.ArrStart()
			for _, elem := range s.PhoneData {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.IdentifierData != nil {
			e.FieldStart("identifierData")
			e.ArrStart()
			for _, elem := range s.IdentifierData {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RelationshipData != nil {
			e.FieldStart("relationshipData")
			e.ArrStart()
			for _, elem := range s.RelationshipData {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.OtherData != nil {
			e.FieldStart("otherData")
			e.ArrStart()
			for _, elem := range s.OtherData {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Records != nil {
			e.FieldStart("records")
			e.ArrStart()
			for _, elem := range s.Records {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Features.Set {
			e.FieldStart("features")
			s.Features.Encode(e)
		}
	}
	{
		if s.Partial.Set {
			e.FieldStart("partial")
			s.Partial.Encode(e)
		}
	}
	{
		if s.LastSeenTimestamp.Set {
			e.FieldStart("lastSeenTimestamp")
			s.LastSeenTimestamp.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.MatchLevel.Set {
			e.FieldStart("matchLevel")
			s.MatchLevel.Encode(e)
		}
	}
	{
		if s.MatchKey.Set {
			e.FieldStart("matchKey")
			s.MatchKey.Encode(e)
		}
	}
	{
		if s.ResolutionRuleCode.Set {
			e.FieldStart("resolutionRuleCode")
			s.ResolutionRuleCode.Encode(e)
		}
	}
	{
		if s.ResultType.Set {
			e.FieldStart("resultType")
			s.ResultType.Encode(e)
		}
	}
	{
		if s.BestNameScore.Set {
			e.FieldStart("bestNameScore")
			s.BestNameScore.Encode(e)
		}
	}
	{
		if s.FeatureScores.Set {
			e.FieldStart("featureScores")
			s.FeatureScores.Encode(e)
		}
	}
	{
		if s.RelatedEntities != nil {
			e.FieldStart("relatedEntities")
			e.ArrStart()
			for _, elem := range s.RelatedEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSzAttributeSearchResult = [22]string{
	0:  "entityId",
	1:  "entityName",
	2:  "bestName",
	3:  "recordSummaries",
	4:  "nameData",
	5:  "characteristicData",
	6:  "addressData",
	7:  "phoneData",
	8:  "identifierData",
	9:  "relationshipData",
	10: "otherData",
	11: "records",
	12: "features",
	13: "partial",
	14: "lastSeenTimestamp",
	15: "matchLevel",
	16: "matchKey",
	17: "resolutionRuleCode",
	18: "resultType",
	19: "bestNameScore",
	20: "featureScores",
	21: "relatedEntities",
}

// Decode decodes SzAttributeSearchResult from json.
func (s *SzAttributeSearchResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzAttributeSearchResult to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "entityId":
			if err := func() error {
				s.EntityId.Reset()
				if err := s.EntityId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entityId\"")
			}
		case "entityName":
			if err := func() error {
				s.EntityName.Reset()
				if err := s.EntityName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entityName\"")
			}
		case "bestName":
			if err := func() error {
				s.BestName.Reset()
				if err := s.BestName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bestName\"")
			}
		case "recordSummaries":
			if err := func() error {
				s.RecordSummaries = make([]SzDataSourceRecordSummary, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SzDataSourceRecordSummary
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RecordSummaries = append(s.RecordSummaries, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recordSummaries\"")
			}
		case "nameData":
			if err := func() error {
				s.NameData = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.NameData = append(s.NameData, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nameData\"")
			}
		case "characteristicData":
			if err := func() error {
				s.CharacteristicData = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.CharacteristicData = append(s.CharacteristicData, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"characteristicData\"")
			}
		case "addressData":
			if err := func() error {
				s.AddressData = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AddressData = append(s.AddressData, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"addressData\"")
			}
		case "phoneData":
			if err := func() error {
				s.PhoneData = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.PhoneData = append(s.PhoneData, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phoneData\"")
			}
		case "identifierData":
			if err := func() error {
				s.IdentifierData = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.IdentifierData = append(s.IdentifierData, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"identifierData\"")
			}
		case "relationshipData":
			if err := func() error {
				s.RelationshipData = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.RelationshipData = append(s.RelationshipData, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"relationshipData\"")
			}
		case "otherData":
			if err := func() error {
				s.OtherData = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.OtherData = append(s.OtherData, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"otherData\"")
			}
		case "records":
			if err := func() error {
				s.Records = make([]SzMatchedRecord, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SzMatchedRecord
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Records = append(s.Records, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"records\"")
			}
		case "features":
			if err := func() error {
				s.Features.Reset()
				if err := s.Features.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"features\"")
			}
		case "partial":
			if err := func() error {
				s.Partial.Reset()
				if err := s.Partial.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"partial\"")
			}
		case "lastSeenTimestamp":
			if err := func() error {
				s.LastSeenTimestamp.Reset()
				if err := s.LastSeenTimestamp.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastSeenTimestamp\"")
			}
		case "matchLevel":
			if err := func() error {
				s.MatchLevel.Reset()
				if err := s.MatchLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchLevel\"")
			}
		case "matchKey":
			if err := func() error {
				s.MatchKey.Reset()
				if err := s.MatchKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchKey\"")
			}
		case "resolutionRuleCode":
			if err := func() error {
				s.ResolutionRuleCode.Reset()
				if err := s.ResolutionRuleCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resolutionRuleCode\"")
			}
		case "resultType":
			if err := func() error {
				s.ResultType.Reset()
				if err := s.ResultType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resultType\"")
			}
		case "bestNameScore":
			if err := func() error {
				s.BestNameScore.Reset()
				if err := s.BestNameScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bestNameScore\"")
			}
		case "featureScores":
			if err := func() error {
				s.FeatureScores.Reset()
				if err := s.FeatureScores.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"featureScores\"")
			}
		case "relatedEntities":
			if err := func() error {
				s.RelatedEntities = make([]SzRelatedEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SzRelatedEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RelatedEntities = append(s.RelatedEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"relatedEntities\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzAttributeSearchResult")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzAttributeSearchResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzAttributeSearchResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SzAttributeSearchResultFeatureScores) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SzAttributeSearchResultFeatureScores) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.ArrStart()
		for _, elem := range elem {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

// Decode decodes SzAttributeSearchResultFeatureScores from json.
func (s *SzAttributeSearchResultFeatureScores) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzAttributeSearchResultFeatureScores to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem []SzSearchFeatureScore
		if err := func() error {
			elem = make([]SzSearchFeatureScore, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elemElem SzSearchFeatureScore
				if err := elemElem.Decode(d); err != nil {
					return err
				}
				elem = append(elem, elemElem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzAttributeSearchResultFeatureScores")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SzAttributeSearchResultFeatureScores) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzAttributeSearchResultFeatureScores) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SzAttributeSearchResultFeatures) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SzAttributeSearchResultFeatures) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.ArrStart()
		for _, elem := range elem {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

// Decode decodes SzAttributeSearchResultFeatures from json.
func (s *SzAttributeSearchResultFeatures) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzAttributeSearchResultFeatures to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem []SzEntityFeature
		if err := func() error {
			elem = make([]SzEntityFeature, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elemElem SzEntityFeature
				if err := elemElem.Decode(d); err != nil {
					return err
				}
				elem = append(elem, elemElem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzAttributeSearchResultFeatures")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SzAttributeSearchResultFeatures) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzAttributeSearchResultFeatures) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzAttributeSearchResultType as json.
func (s SzAttributeSearchResultType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SzAttributeSearchResultType from json.
func (s *SzAttributeSearchResultType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzAttributeSearchResultType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SzAttributeSearchResultType(v) {
	case SzAttributeSearchResultTypeMATCH:
		*s = SzAttributeSearchResultTypeMATCH
	case SzAttributeSearchResultTypePOSSIBLEMATCH:
		*s = SzAttributeSearchResultTypePOSSIBLEMATCH
	case SzAttributeSearchResultTypePOSSIBLERELATION:
		*s = SzAttributeSearchResultTypePOSSIBLERELATION
	case SzAttributeSearchResultTypeNAMEONLYMATCH:
		*s = SzAttributeSearchResultTypeNAMEONLYMATCH
	default:
		*s = SzAttributeSearchResultType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SzAttributeSearchResultType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzAttributeSearchResultType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzAttributeType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzAttributeType) encodeFields(e *jx.Encoder) {
	{
		if s.AttributeCode.Set {
			e.FieldStart("attributeCode")
			s.AttributeCode.Encode(e)
		}
	}
	{
		if s.DefaultValue.Set {
			e.FieldStart("defaultValue")
			s.DefaultValue.Encode(e)
		}
	}
	{
		if s.Necessity.Set {
			e.FieldStart("necessity")
			s.Necessity.Encode(e)
		}
	}
	{
		if s.AttributeClass.Set {
			e.FieldStart("attributeClass")
			s.AttributeClass.Encode(e)
		}
	}
	{
		if s.FeatureType.Set {
			e.FieldStart("featureType")
			s.FeatureType.Encode(e)
		}
	}
	{
		if s.Advanced.Set {
			e.FieldStart("advanced")
			s.Advanced.Encode(e)
		}
	}
	{
		if s.Internal.Set {
			e.FieldStart("internal")
			s.Internal.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzAttributeType = [7]string{
	0: "attributeCode",
	1: "defaultValue",
	2: "necessity",
	3: "attributeClass",
	4: "featureType",
	5: "advanced",
	6: "internal",
}

// Decode decodes SzAttributeType from json.
func (s *SzAttributeType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzAttributeType to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "attributeCode":
			if err := func() error {
				s.AttributeCode.Reset()
				if err := s.AttributeCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attributeCode\"")
			}
		case "defaultValue":
			if err := func() error {
				s.DefaultValue.Reset()
				if err := s.DefaultValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defaultValue\"")
			}
		case "necessity":
			if err := func() error {
				s.Necessity.Reset()
				if err := s.Necessity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"necessity\"")
			}
		case "attributeClass":
			if err := func() error {
				s.AttributeClass.Reset()
				if err := s.AttributeClass.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attributeClass\"")
			}
		case "featureType":
			if err := func() error {
				s.FeatureType.Reset()
				if err := s.FeatureType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"featureType\"")
			}
		case "advanced":
			if err := func() error {
				s.Advanced.Reset()
				if err := s.Advanced.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"advanced\"")
			}
		case "internal":
			if err := func() error {
				s.Internal.Reset()
				if err := s.Internal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"internal\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzAttributeType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzAttributeType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzAttributeType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzAttributeTypeResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzAttributeTypeResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
	{
		if s.Links.Set {
			e.FieldStart("links")
			s.Links.Encode(e)
		}
	}
	{
		if s.RawData.Set {
			e.FieldStart("rawData")
			s.RawData.Encode(e)
		}
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzAttributeTypeResponse = [4]string{
	0: "meta",
	1: "links",
	2: "rawData",
	3: "data",
}

// Decode decodes SzAttributeTypeResponse from json.
func (s *SzAttributeTypeResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzAttributeTypeResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		case "links":
			if err := func() error {
				s.Links.Reset()
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		case "rawData":
			if err := func() error {
				s.RawData.Reset()
				if err := s.RawData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawData\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzAttributeTypeResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzAttributeTypeResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzAttributeTypeResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzAttributeTypeResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzAttributeTypeResponseData) encodeFields(e *jx.Encoder) {
	{
		if s.AttributeType.Set {
			e.FieldStart("attributeType")
			s.AttributeType.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzAttributeTypeResponseData = [1]string{
	0: "attributeType",
}

// Decode decodes SzAttributeTypeResponseData from json.
func (s *SzAttributeTypeResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzAttributeTypeResponseData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "attributeType":
			if err := func() error {
				s.AttributeType.Reset()
				if err := s.AttributeType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attributeType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzAttributeTypeResponseData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzAttributeTypeResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzAttributeTypeResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SzAttributeTypeResponseRawData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SzAttributeTypeResponseRawData) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SzAttributeTypeResponseRawData from json.
func (s *SzAttributeTypeResponseRawData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzAttributeTypeResponseRawData to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzAttributeTypeResponseRawData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SzAttributeTypeResponseRawData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzAttributeTypeResponseRawData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzAttributeTypesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzAttributeTypesResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
	{
		if s.Links.Set {
			e.FieldStart("links")
			s.Links.Encode(e)
		}
	}
	{
		if s.RawData.Set {
			e.FieldStart("rawData")
			s.RawData.Encode(e)
		}
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzAttributeTypesResponse = [4]string{
	0: "meta",
	1: "links",
	2: "rawData",
	3: "data",
}

// Decode decodes SzAttributeTypesResponse from json.
func (s *SzAttributeTypesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzAttributeTypesResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		case "links":
			if err := func() error {
				s.Links.Reset()
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		case "rawData":
			if err := func() error {
				s.RawData.Reset()
				if err := s.RawData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawData\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzAttributeTypesResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzAttributeTypesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzAttributeTypesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzAttributeTypesResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzAttributeTypesResponseData) encodeFields(e *jx.Encoder) {
	{
		if s.AttributeTypes != nil {
			e.FieldStart("attributeTypes")
			e.ArrStart()
			for _, elem := range s.AttributeTypes {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSzAttributeTypesResponseData = [1]string{
	0: "attributeTypes",
}

// Decode decodes SzAttributeTypesResponseData from json.
func (s *SzAttributeTypesResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzAttributeTypesResponseData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "attributeTypes":
			if err := func() error {
				s.AttributeTypes = make([]SzAttributeType, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SzAttributeType
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AttributeTypes = append(s.AttributeTypes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attributeTypes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzAttributeTypesResponseData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzAttributeTypesResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzAttributeTypesResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SzAttributeTypesResponseRawData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SzAttributeTypesResponseRawData) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SzAttributeTypesResponseRawData from json.
func (s *SzAttributeTypesResponseRawData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzAttributeTypesResponseRawData to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzAttributeTypesResponseRawData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SzAttributeTypesResponseRawData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzAttributeTypesResponseRawData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzBaseResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzBaseResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
	{
		if s.Links.Set {
			e.FieldStart("links")
			s.Links.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzBaseResponse = [2]string{
	0: "meta",
	1: "links",
}

// Decode decodes SzBaseResponse from json.
func (s *SzBaseResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzBaseResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		case "links":
			if err := func() error {
				s.Links.Reset()
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzBaseResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzBaseResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzBaseResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzBulkDataAnalysis) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzBulkDataAnalysis) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.CharacterEncoding.Set {
			e.FieldStart("characterEncoding")
			s.CharacterEncoding.Encode(e)
		}
	}
	{
		if s.MediaType.Set {
			e.FieldStart("mediaType")
			s.MediaType.Encode(e)
		}
	}
	{
		if s.RecordCount.Set {
			e.FieldStart("recordCount")
			s.RecordCount.Encode(e)
		}
	}
	{
		if s.RecordsWithRecordIdCount.Set {
			e.FieldStart("recordsWithRecordIdCount")
			s.RecordsWithRecordIdCount.Encode(e)
		}
	}
	{
		if s.RecordsWithDataSourceCount.Set {
			e.FieldStart("recordsWithDataSourceCount")
			s.RecordsWithDataSourceCount.Encode(e)
		}
	}
	{
		if s.AnalysisByDataSource != nil {
			e.FieldStart("analysisByDataSource")
			e.ArrStart()
			for _, elem := range s.AnalysisByDataSource {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSzBulkDataAnalysis = [7]string{
	0: "status",
	1: "characterEncoding",
	2: "mediaType",
	3: "recordCount",
	4: "recordsWithRecordIdCount",
	5: "recordsWithDataSourceCount",
	6: "analysisByDataSource",
}

// Decode decodes SzBulkDataAnalysis from json.
func (s *SzBulkDataAnalysis) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzBulkDataAnalysis to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "characterEncoding":
			if err := func() error {
				s.CharacterEncoding.Reset()
				if err := s.CharacterEncoding.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"characterEncoding\"")
			}
		case "mediaType":
			if err := func() error {
				s.MediaType.Reset()
				if err := s.MediaType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mediaType\"")
			}
		case "recordCount":
			if err := func() error {
				s.RecordCount.Reset()
				if err := s.RecordCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recordCount\"")
			}
		case "recordsWithRecordIdCount":
			if err := func() error {
				s.RecordsWithRecordIdCount.Reset()
				if err := s.RecordsWithRecordIdCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recordsWithRecordIdCount\"")
			}
		case "recordsWithDataSourceCount":
			if err := func() error {
				s.RecordsWithDataSourceCount.Reset()
				if err := s.RecordsWithDataSourceCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recordsWithDataSourceCount\"")
			}
		case "analysisByDataSource":
			if err := func() error {
				s.AnalysisByDataSource = make([]SzDataSourceRecordAnalysis, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SzDataSourceRecordAnalysis
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AnalysisByDataSource = append(s.AnalysisByDataSource, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"analysisByDataSource\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzBulkDataAnalysis")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzBulkDataAnalysis) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzBulkDataAnalysis) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzBulkDataAnalysisResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzBulkDataAnalysisResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
	{
		if s.Links.Set {
			e.FieldStart("links")
			s.Links.Encode(e)
		}
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzBulkDataAnalysisResponse = [3]string{
	0: "meta",
	1: "links",
	2: "data",
}

// Decode decodes SzBulkDataAnalysisResponse from json.
func (s *SzBulkDataAnalysisResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzBulkDataAnalysisResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		case "links":
			if err := func() error {
				s.Links.Reset()
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzBulkDataAnalysisResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzBulkDataAnalysisResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzBulkDataAnalysisResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzBulkDataStatus as json.
func (s SzBulkDataStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SzBulkDataStatus from json.
func (s *SzBulkDataStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzBulkDataStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SzBulkDataStatus(v) {
	case SzBulkDataStatusNOTSTARTED:
		*s = SzBulkDataStatusNOTSTARTED
	case SzBulkDataStatusINPROGRESS:
		*s = SzBulkDataStatusINPROGRESS
	case SzBulkDataStatusABORTED:
		*s = SzBulkDataStatusABORTED
	case SzBulkDataStatusCOMPLETED:
		*s = SzBulkDataStatusCOMPLETED
	default:
		*s = SzBulkDataStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SzBulkDataStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzBulkDataStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzBulkLoadError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzBulkLoadError) encodeFields(e *jx.Encoder) {
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{
		if s.OccurrenceCount.Set {
			e.FieldStart("occurrenceCount")
			s.OccurrenceCount.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzBulkLoadError = [2]string{
	0: "error",
	1: "occurrenceCount",
}

// Decode decodes SzBulkLoadError from json.
func (s *SzBulkLoadError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzBulkLoadError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "occurrenceCount":
			if err := func() error {
				s.OccurrenceCount.Reset()
				if err := s.OccurrenceCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"occurrenceCount\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzBulkLoadError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzBulkLoadError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzBulkLoadError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzBulkLoadResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzBulkLoadResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
	{
		if s.Links.Set {
			e.FieldStart("links")
			s.Links.Encode(e)
		}
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzBulkLoadResponse = [3]string{
	0: "meta",
	1: "links",
	2: "data",
}

// Decode decodes SzBulkLoadResponse from json.
func (s *SzBulkLoadResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzBulkLoadResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		case "links":
			if err := func() error {
				s.Links.Reset()
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzBulkLoadResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzBulkLoadResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzBulkLoadResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzBulkLoadResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzBulkLoadResult) encodeFields(e *jx.Encoder) {
	{
		if s.RecordCount.Set {
			e.FieldStart("recordCount")
			s.RecordCount.Encode(e)
		}
	}
	{
		if s.LoadedRecordCount.Set {
			e.FieldStart("loadedRecordCount")
			s.LoadedRecordCount.Encode(e)
		}
	}
	{
		if s.IncompleteRecordCount.Set {
			e.FieldStart("incompleteRecordCount")
			s.IncompleteRecordCount.Encode(e)
		}
	}
	{
		if s.FailedRecordCount.Set {
			e.FieldStart("failedRecordCount")
			s.FailedRecordCount.Encode(e)
		}
	}
	{
		if s.TopErrors != nil {
			e.FieldStart("topErrors")
			e.ArrStart()
			for _, elem := range s.TopErrors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.CharacterEncoding.Set {
			e.FieldStart("characterEncoding")
			s.CharacterEncoding.Encode(e)
		}
	}
	{
		if s.MediaType.Set {
			e.FieldStart("mediaType")
			s.MediaType.Encode(e)
		}
	}
	{
		if s.MissingDataSourceCount.Set {
			e.FieldStart("missingDataSourceCount")
			s.MissingDataSourceCount.Encode(e)
		}
	}
	{
		if s.ResultsByDataSource != nil {
			e.FieldStart("resultsByDataSource")
			e.ArrStart()
			for _, elem := range s.ResultsByDataSource {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSzBulkLoadResult = [10]string{
	0: "recordCount",
	1: "loadedRecordCount",
	2: "incompleteRecordCount",
	3: "failedRecordCount",
	4: "topErrors",
	5: "status",
	6: "characterEncoding",
	7: "mediaType",
	8: "missingDataSourceCount",
	9: "resultsByDataSource",
}

// Decode decodes SzBulkLoadResult from json.
func (s *SzBulkLoadResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzBulkLoadResult to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "recordCount":
			if err := func() error {
				s.RecordCount.Reset()
				if err := s.RecordCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recordCount\"")
			}
		case "loadedRecordCount":
			if err := func() error {
				s.LoadedRecordCount.Reset()
				if err := s.LoadedRecordCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loadedRecordCount\"")
			}
		case "incompleteRecordCount":
			if err := func() error {
				s.IncompleteRecordCount.Reset()
				if err := s.IncompleteRecordCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"incompleteRecordCount\"")
			}
		case "failedRecordCount":
			if err := func() error {
				s.FailedRecordCount.Reset()
				if err := s.FailedRecordCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failedRecordCount\"")
			}
		case "topErrors":
			if err := func() error {
				s.TopErrors = make([]SzBulkLoadError, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SzBulkLoadError
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.TopErrors = append(s.TopErrors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topErrors\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "characterEncoding":
			if err := func() error {
				s.CharacterEncoding.Reset()
				if err := s.CharacterEncoding.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"characterEncoding\"")
			}
		case "mediaType":
			if err := func() error {
				s.MediaType.Reset()
				if err := s.MediaType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mediaType\"")
			}
		case "missingDataSourceCount":
			if err := func() error {
				s.MissingDataSourceCount.Reset()
				if err := s.MissingDataSourceCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"missingDataSourceCount\"")
			}
		case "resultsByDataSource":
			if err := func() error {
				s.ResultsByDataSource = make([]SzDataSourceBulkLoadResult, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SzDataSourceBulkLoadResult
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ResultsByDataSource = append(s.ResultsByDataSource, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resultsByDataSource\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzBulkLoadResult")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzBulkLoadResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzBulkLoadResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzCandidateKey) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzCandidateKey) encodeFields(e *jx.Encoder) {
	{
		if s.FeatureId.Set {
			e.FieldStart("featureId")
			s.FeatureId.Encode(e)
		}
	}
	{
		if s.FeatureType.Set {
			e.FieldStart("featureType")
			s.FeatureType.Encode(e)
		}
	}
	{
		if s.FeatureValue.Set {
			e.FieldStart("featureValue")
			s.FeatureValue.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzCandidateKey = [3]string{
	0: "featureId",
	1: "featureType",
	2: "featureValue",
}

// Decode decodes SzCandidateKey from json.
func (s *SzCandidateKey) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzCandidateKey to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "featureId":
			if err := func() error {
				s.FeatureId.Reset()
				if err := s.FeatureId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"featureId\"")
			}
		case "featureType":
			if err := func() error {
				s.FeatureType.Reset()
				if err := s.FeatureType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"featureType\"")
			}
		case "featureValue":
			if err := func() error {
				s.FeatureValue.Reset()
				if err := s.FeatureValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"featureValue\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzCandidateKey")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzCandidateKey) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzCandidateKey) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzConfigResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzConfigResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
	{
		if s.Links.Set {
			e.FieldStart("links")
			s.Links.Encode(e)
		}
	}
	{
		if s.RawData.Set {
			e.FieldStart("rawData")
			s.RawData.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzConfigResponse = [3]string{
	0: "meta",
	1: "links",
	2: "rawData",
}

// Decode decodes SzConfigResponse from json.
func (s *SzConfigResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzConfigResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		case "links":
			if err := func() error {
				s.Links.Reset()
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		case "rawData":
			if err := func() error {
				s.RawData.Reset()
				if err := s.RawData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawData\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzConfigResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzConfigResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzConfigResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SzConfigResponseRawData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SzConfigResponseRawData) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SzConfigResponseRawData from json.
func (s *SzConfigResponseRawData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzConfigResponseRawData to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzConfigResponseRawData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SzConfigResponseRawData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzConfigResponseRawData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzDataSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzDataSource) encodeFields(e *jx.Encoder) {
	{
		if s.DataSourceCode.Set {
			e.FieldStart("dataSourceCode")
			s.DataSourceCode.Encode(e)
		}
	}
	{
		if s.DataSourceId.Set {
			e.FieldStart("dataSourceId")
			s.DataSourceId.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzDataSource = [2]string{
	0: "dataSourceCode",
	1: "dataSourceId",
}

// Decode decodes SzDataSource from json.
func (s *SzDataSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzDataSource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dataSourceCode":
			if err := func() error {
				s.DataSourceCode.Reset()
				if err := s.DataSourceCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataSourceCode\"")
			}
		case "dataSourceId":
			if err := func() error {
				s.DataSourceId.Reset()
				if err := s.DataSourceId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataSourceId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzDataSource")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzDataSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzDataSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzDataSourceBulkLoadResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzDataSourceBulkLoadResult) encodeFields(e *jx.Encoder) {
	{
		if s.RecordCount.Set {
			e.FieldStart("recordCount")
			s.RecordCount.Encode(e)
		}
	}
	{
		if s.LoadedRecordCount.Set {
			e.FieldStart("loadedRecordCount")
			s.LoadedRecordCount.Encode(e)
		}
	}
	{
		if s.IncompleteRecordCount.Set {
			e.FieldStart("incompleteRecordCount")
			s.IncompleteRecordCount.Encode(e)
		}
	}
	{
		if s.FailedRecordCount.Set {
			e.FieldStart("failedRecordCount")
			s.FailedRecordCount.Encode(e)
		}
	}
	{
		if s.TopErrors != nil {
			e.FieldStart("topErrors")
			e.ArrStart()
			for _, elem := range s.TopErrors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DataSource.Set {
			e.FieldStart("dataSource")
			s.DataSource.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzDataSourceBulkLoadResult = [6]string{
	0: "recordCount",
	1: "loadedRecordCount",
	2: "incompleteRecordCount",
	3: "failedRecordCount",
	4: "topErrors",
	5: "dataSource",
}

// Decode decodes SzDataSourceBulkLoadResult from json.
func (s *SzDataSourceBulkLoadResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzDataSourceBulkLoadResult to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "recordCount":
			if err := func() error {
				s.RecordCount.Reset()
				if err := s.RecordCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recordCount\"")
			}
		case "loadedRecordCount":
			if err := func() error {
				s.LoadedRecordCount.Reset()
				if err := s.LoadedRecordCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loadedRecordCount\"")
			}
		case "incompleteRecordCount":
			if err := func() error {
				s.IncompleteRecordCount.Reset()
				if err := s.IncompleteRecordCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"incompleteRecordCount\"")
			}
		case "failedRecordCount":
			if err := func() error {
				s.FailedRecordCount.Reset()
				if err := s.FailedRecordCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failedRecordCount\"")
			}
		case "topErrors":
			if err := func() error {
				s.TopErrors = make([]SzBulkLoadError, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SzBulkLoadError
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.TopErrors = append(s.TopErrors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topErrors\"")
			}
		case "dataSource":
			if err := func() error {
				s.DataSource.Reset()
				if err := s.DataSource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataSource\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzDataSourceBulkLoadResult")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzDataSourceBulkLoadResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzDataSourceBulkLoadResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzDataSourceDescriptor as json.
func (s SzDataSourceDescriptor) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringSzDataSourceDescriptor:
		e.Str(s.String)
	case SzDataSourceSzDataSourceDescriptor:
		s.SzDataSource.Encode(e)
	}
}

// Decode decodes SzDataSourceDescriptor from json.
func (s *SzDataSourceDescriptor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzDataSourceDescriptor to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.SzDataSource.Decode(d); err != nil {
			return err
		}
		s.Type = SzDataSourceSzDataSourceDescriptor
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringSzDataSourceDescriptor
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SzDataSourceDescriptor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzDataSourceDescriptor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzDataSourceRecordAnalysis) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzDataSourceRecordAnalysis) encodeFields(e *jx.Encoder) {
	{
		if s.DataSource.Set {
			e.FieldStart("dataSource")
			s.DataSource.Encode(e)
		}
	}
	{
		if s.RecordCount.Set {
			e.FieldStart("recordCount")
			s.RecordCount.Encode(e)
		}
	}
	{
		if s.RecordsWithRecordIdCount.Set {
			e.FieldStart("recordsWithRecordIdCount")
			s.RecordsWithRecordIdCount.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzDataSourceRecordAnalysis = [3]string{
	0: "dataSource",
	1: "recordCount",
	2: "recordsWithRecordIdCount",
}

// Decode decodes SzDataSourceRecordAnalysis from json.
func (s *SzDataSourceRecordAnalysis) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzDataSourceRecordAnalysis to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dataSource":
			if err := func() error {
				s.DataSource.Reset()
				if err := s.DataSource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataSource\"")
			}
		case "recordCount":
			if err := func() error {
				s.RecordCount.Reset()
				if err := s.RecordCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recordCount\"")
			}
		case "recordsWithRecordIdCount":
			if err := func() error {
				s.RecordsWithRecordIdCount.Reset()
				if err := s.RecordsWithRecordIdCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recordsWithRecordIdCount\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzDataSourceRecordAnalysis")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzDataSourceRecordAnalysis) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzDataSourceRecordAnalysis) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzDataSourceRecordSummary) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzDataSourceRecordSummary) encodeFields(e *jx.Encoder) {
	{
		if s.DataSource.Set {
			e.FieldStart("dataSource")
			s.DataSource.Encode(e)
		}
	}
	{
		if s.RecordCount.Set {
			e.FieldStart("recordCount")
			s.RecordCount.Encode(e)
		}
	}
	{
		if s.TopRecordIds.Set {
			e.FieldStart("topRecordIds")
			s.TopRecordIds.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzDataSourceRecordSummary = [3]string{
	0: "dataSource",
	1: "recordCount",
	2: "topRecordIds",
}

// Decode decodes SzDataSourceRecordSummary from json.
func (s *SzDataSourceRecordSummary) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzDataSourceRecordSummary to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dataSource":
			if err := func() error {
				s.DataSource.Reset()
				if err := s.DataSource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataSource\"")
			}
		case "recordCount":
			if err := func() error {
				s.RecordCount.Reset()
				if err := s.RecordCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recordCount\"")
			}
		case "topRecordIds":
			if err := func() error {
				s.TopRecordIds.Reset()
				if err := s.TopRecordIds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topRecordIds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzDataSourceRecordSummary")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzDataSourceRecordSummary) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzDataSourceRecordSummary) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzDataSourceResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzDataSourceResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
	{
		if s.Links.Set {
			e.FieldStart("links")
			s.Links.Encode(e)
		}
	}
	{
		if s.RawData.Set {
			e.FieldStart("rawData")
			s.RawData.Encode(e)
		}
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzDataSourceResponse = [4]string{
	0: "meta",
	1: "links",
	2: "rawData",
	3: "data",
}

// Decode decodes SzDataSourceResponse from json.
func (s *SzDataSourceResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzDataSourceResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		case "links":
			if err := func() error {
				s.Links.Reset()
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		case "rawData":
			if err := func() error {
				s.RawData.Reset()
				if err := s.RawData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawData\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzDataSourceResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzDataSourceResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzDataSourceResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzDataSourceResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzDataSourceResponseData) encodeFields(e *jx.Encoder) {
	{
		if s.DataSource.Set {
			e.FieldStart("dataSource")
			s.DataSource.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzDataSourceResponseData = [1]string{
	0: "dataSource",
}

// Decode decodes SzDataSourceResponseData from json.
func (s *SzDataSourceResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzDataSourceResponseData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dataSource":
			if err := func() error {
				s.DataSource.Reset()
				if err := s.DataSource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataSource\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzDataSourceResponseData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzDataSourceResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzDataSourceResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SzDataSourceResponseRawData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SzDataSourceResponseRawData) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SzDataSourceResponseRawData from json.
func (s *SzDataSourceResponseRawData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzDataSourceResponseRawData to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzDataSourceResponseRawData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SzDataSourceResponseRawData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzDataSourceResponseRawData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzDataSourcesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzDataSourcesResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
	{
		if s.Links.Set {
			e.FieldStart("links")
			s.Links.Encode(e)
		}
	}
	{
		if s.RawData.Set {
			e.FieldStart("rawData")
			s.RawData.Encode(e)
		}
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzDataSourcesResponse = [4]string{
	0: "meta",
	1: "links",
	2: "rawData",
	3: "data",
}

// Decode decodes SzDataSourcesResponse from json.
func (s *SzDataSourcesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzDataSourcesResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		case "links":
			if err := func() error {
				s.Links.Reset()
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		case "rawData":
			if err := func() error {
				s.RawData.Reset()
				if err := s.RawData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawData\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzDataSourcesResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzDataSourcesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzDataSourcesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzDataSourcesResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzDataSourcesResponseData) encodeFields(e *jx.Encoder) {
	{
		if s.DataSources != nil {
			e.FieldStart("dataSources")
			e.ArrStart()
			for _, elem := range s.DataSources {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DataSourceDetails.Set {
			e.FieldStart("dataSourceDetails")
			s.DataSourceDetails.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzDataSourcesResponseData = [2]string{
	0: "dataSources",
	1: "dataSourceDetails",
}

// Decode decodes SzDataSourcesResponseData from json.
func (s *SzDataSourcesResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzDataSourcesResponseData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dataSources":
			if err := func() error {
				s.DataSources = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.DataSources = append(s.DataSources, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataSources\"")
			}
		case "dataSourceDetails":
			if err := func() error {
				s.DataSourceDetails.Reset()
				if err := s.DataSourceDetails.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataSourceDetails\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzDataSourcesResponseData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzDataSourcesResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzDataSourcesResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SzDataSourcesResponseDataDataSourceDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SzDataSourcesResponseDataDataSourceDetails) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes SzDataSourcesResponseDataDataSourceDetails from json.
func (s *SzDataSourcesResponseDataDataSourceDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzDataSourcesResponseDataDataSourceDetails to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem SzDataSource
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzDataSourcesResponseDataDataSourceDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SzDataSourcesResponseDataDataSourceDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzDataSourcesResponseDataDataSourceDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SzDataSourcesResponseRawData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SzDataSourcesResponseRawData) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SzDataSourcesResponseRawData from json.
func (s *SzDataSourcesResponseRawData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzDataSourcesResponseRawData to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzDataSourcesResponseRawData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SzDataSourcesResponseRawData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzDataSourcesResponseRawData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzDeleteRecordResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzDeleteRecordResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
	{
		if s.Links.Set {
			e.FieldStart("links")
			s.Links.Encode(e)
		}
	}
	{
		if s.RawData.Set {
			e.FieldStart("rawData")
			s.RawData.Encode(e)
		}
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzDeleteRecordResponse = [4]string{
	0: "meta",
	1: "links",
	2: "rawData",
	3: "data",
}

// Decode decodes SzDeleteRecordResponse from json.
func (s *SzDeleteRecordResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzDeleteRecordResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		case "links":
			if err := func() error {
				s.Links.Reset()
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		case "rawData":
			if err := func() error {
				s.RawData.Reset()
				if err := s.RawData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawData\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzDeleteRecordResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzDeleteRecordResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzDeleteRecordResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzDeleteRecordResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzDeleteRecordResponseData) encodeFields(e *jx.Encoder) {
	{
		if s.Info.Set {
			e.FieldStart("info")
			s.Info.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzDeleteRecordResponseData = [1]string{
	0: "info",
}

// Decode decodes SzDeleteRecordResponseData from json.
func (s *SzDeleteRecordResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzDeleteRecordResponseData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "info":
			if err := func() error {
				s.Info.Reset()
				if err := s.Info.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"info\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzDeleteRecordResponseData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzDeleteRecordResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzDeleteRecordResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SzDeleteRecordResponseRawData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SzDeleteRecordResponseRawData) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SzDeleteRecordResponseRawData from json.
func (s *SzDeleteRecordResponseRawData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzDeleteRecordResponseRawData to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzDeleteRecordResponseRawData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SzDeleteRecordResponseRawData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzDeleteRecordResponseRawData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzDisclosedRelation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzDisclosedRelation) encodeFields(e *jx.Encoder) {
	{
		if s.Domain.Set {
			e.FieldStart("domain")
			s.Domain.Encode(e)
		}
	}
	{
		if s.Direction.Set {
			e.FieldStart("direction")
			s.Direction.Encode(e)
		}
	}
	{
		if s.Roles1 != nil {
			e.FieldStart("roles1")
			e.ArrStart()
			for _, elem := range s.Roles1 {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Roles2 != nil {
			e.FieldStart("roles2")
			e.ArrStart()
			for _, elem := range s.Roles2 {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RelatedFeatures != nil {
			e.FieldStart("relatedFeatures")
			e.ArrStart()
			for _, elem := range s.RelatedFeatures {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSzDisclosedRelation = [5]string{
	0: "domain",
	1: "direction",
	2: "roles1",
	3: "roles2",
	4: "relatedFeatures",
}

// Decode decodes SzDisclosedRelation from json.
func (s *SzDisclosedRelation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzDisclosedRelation to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "domain":
			if err := func() error {
				s.Domain.Reset()
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "direction":
			if err := func() error {
				s.Direction.Reset()
				if err := s.Direction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"direction\"")
			}
		case "roles1":
			if err := func() error {
				s.Roles1 = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Roles1 = append(s.Roles1, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"roles1\"")
			}
		case "roles2":
			if err := func() error {
				s.Roles2 = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Roles2 = append(s.Roles2, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"roles2\"")
			}
		case "relatedFeatures":
			if err := func() error {
				s.RelatedFeatures = make([]SzRelatedFeatures, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SzRelatedFeatures
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RelatedFeatures = append(s.RelatedFeatures, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"relatedFeatures\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzDisclosedRelation")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzDisclosedRelation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzDisclosedRelation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzEntityData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzEntityData) encodeFields(e *jx.Encoder) {
	{
		if s.ResolvedEntity.Set {
			e.FieldStart("resolvedEntity")
			s.ResolvedEntity.Encode(e)
		}
	}
	{
		if s.RelatedEntities != nil {
			e.FieldStart("relatedEntities")
			e.ArrStart()
			for _, elem := range s.RelatedEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSzEntityData = [2]string{
	0: "resolvedEntity",
	1: "relatedEntities",
}

// Decode decodes SzEntityData from json.
func (s *SzEntityData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzEntityData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resolvedEntity":
			if err := func() error {
				s.ResolvedEntity.Reset()
				if err := s.ResolvedEntity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resolvedEntity\"")
			}
		case "relatedEntities":
			if err := func() error {
				s.RelatedEntities = make([]SzRelatedEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SzRelatedEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RelatedEntities = append(s.RelatedEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"relatedEntities\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzEntityData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzEntityData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzEntityData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzEntityFeature) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzEntityFeature) encodeFields(e *jx.Encoder) {
	{
		if s.PrimaryId.Set {
			e.FieldStart("primaryId")
			s.PrimaryId.Encode(e)
		}
	}
	{
		if s.PrimaryValue.Set {
			e.FieldStart("primaryValue")
			s.PrimaryValue.Encode(e)
		}
	}
	{
		if s.UsageType.Set {
			e.FieldStart("usageType")
			s.UsageType.Encode(e)
		}
	}
	{
		if s.DuplicateValues != nil {
			e.FieldStart("duplicateValues")
			e.ArrStart()
			for _, elem := range s.DuplicateValues {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.FeatureDetails != nil {
			e.FieldStart("featureDetails")
			e.ArrStart()
			for _, elem := range s.FeatureDetails {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSzEntityFeature = [5]string{
	0: "primaryId",
	1: "primaryValue",
	2: "usageType",
	3: "duplicateValues",
	4: "featureDetails",
}

// Decode decodes SzEntityFeature from json.
func (s *SzEntityFeature) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzEntityFeature to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "primaryId":
			if err := func() error {
				s.PrimaryId.Reset()
				if err := s.PrimaryId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"primaryId\"")
			}
		case "primaryValue":
			if err := func() error {
				s.PrimaryValue.Reset()
				if err := s.PrimaryValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"primaryValue\"")
			}
		case "usageType":
			if err := func() error {
				s.UsageType.Reset()
				if err := s.UsageType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usageType\"")
			}
		case "duplicateValues":
			if err := func() error {
				s.DuplicateValues = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.DuplicateValues = append(s.DuplicateValues, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duplicateValues\"")
			}
		case "featureDetails":
			if err := func() error {
				s.FeatureDetails = make([]SzEntityFeatureDetail, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SzEntityFeatureDetail
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.FeatureDetails = append(s.FeatureDetails, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"featureDetails\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzEntityFeature")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzEntityFeature) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzEntityFeature) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzEntityFeatureDetail) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzEntityFeatureDetail) encodeFields(e *jx.Encoder) {
	{
		if s.InternalId.Set {
			e.FieldStart("internalId")
			s.InternalId.Encode(e)
		}
	}
	{
		if s.FeatureValue.Set {
			e.FieldStart("featureValue")
			s.FeatureValue.Encode(e)
		}
	}
	{
		if s.Statistics.Set {
			e.FieldStart("statistics")
			s.Statistics.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzEntityFeatureDetail = [3]string{
	0: "internalId",
	1: "featureValue",
	2: "statistics",
}

// Decode decodes SzEntityFeatureDetail from json.
func (s *SzEntityFeatureDetail) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzEntityFeatureDetail to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "internalId":
			if err := func() error {
				s.InternalId.Reset()
				if err := s.InternalId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"internalId\"")
			}
		case "featureValue":
			if err := func() error {
				s.FeatureValue.Reset()
				if err := s.FeatureValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"featureValue\"")
			}
		case "statistics":
			if err := func() error {
				s.Statistics.Reset()
				if err := s.Statistics.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statistics\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzEntityFeatureDetail")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzEntityFeatureDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzEntityFeatureDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzEntityFeatureStatistics) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzEntityFeatureStatistics) encodeFields(e *jx.Encoder) {
	{
		if s.UsedForCandidates.Set {
			e.FieldStart("usedForCandidates")
			s.UsedForCandidates.Encode(e)
		}
	}
	{
		if s.UsedForScoring.Set {
			e.FieldStart("usedForScoring")
			s.UsedForScoring.Encode(e)
		}
	}
	{
		if s.EntityCount.Set {
			e.FieldStart("entityCount")
			s.EntityCount.Encode(e)
		}
	}
	{
		if s.CandidateCapReached.Set {
			e.FieldStart("candidateCapReached")
			s.CandidateCapReached.Encode(e)
		}
	}
	{
		if s.ScoringCapReached.Set {
			e.FieldStart("scoringCapReached")
			s.ScoringCapReached.Encode(e)
		}
	}
	{
		if s.Suppressed.Set {
			e.FieldStart("suppressed")
			s.Suppressed.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzEntityFeatureStatistics = [6]string{
	0: "usedForCandidates",
	1: "usedForScoring",
	2: "entityCount",
	3: "candidateCapReached",
	4: "scoringCapReached",
	5: "suppressed",
}

// Decode decodes SzEntityFeatureStatistics from json.
func (s *SzEntityFeatureStatistics) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzEntityFeatureStatistics to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "usedForCandidates":
			if err := func() error {
				s.UsedForCandidates.Reset()
				if err := s.UsedForCandidates.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usedForCandidates\"")
			}
		case "usedForScoring":
			if err := func() error {
				s.UsedForScoring.Reset()
				if err := s.UsedForScoring.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usedForScoring\"")
			}
		case "entityCount":
			if err := func() error {
				s.EntityCount.Reset()
				if err := s.EntityCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entityCount\"")
			}
		case "candidateCapReached":
			if err := func() error {
				s.CandidateCapReached.Reset()
				if err := s.CandidateCapReached.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"candidateCapReached\"")
			}
		case "scoringCapReached":
			if err := func() error {
				s.ScoringCapReached.Reset()
				if err := s.ScoringCapReached.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scoringCapReached\"")
			}
		case "suppressed":
			if err := func() error {
				s.Suppressed.Reset()
				if err := s.Suppressed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"suppressed\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzEntityFeatureStatistics")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzEntityFeatureStatistics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzEntityFeatureStatistics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzEntityNetworkData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzEntityNetworkData) encodeFields(e *jx.Encoder) {
	{
		if s.EntityPaths != nil {
			e.FieldStart("entityPaths")
			e.ArrStart()
			for _, elem := range s.EntityPaths {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Entities != nil {
			e.FieldStart("entities")
			e.ArrStart()
			for _, elem := range s.Entities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSzEntityNetworkData = [2]string{
	0: "entityPaths",
	1: "entities",
}

// Decode decodes SzEntityNetworkData from json.
func (s *SzEntityNetworkData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzEntityNetworkData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "entityPaths":
			if err := func() error {
				s.EntityPaths = make([]SzEntityPath, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SzEntityPath
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.EntityPaths = append(s.EntityPaths, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entityPaths\"")
			}
		case "entities":
			if err := func() error {
				s.Entities = make([]SzEntityData, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SzEntityData
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Entities = append(s.Entities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entities\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzEntityNetworkData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzEntityNetworkData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzEntityNetworkData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzEntityNetworkResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzEntityNetworkResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
	{
		if s.Links.Set {
			e.FieldStart("links")
			s.Links.Encode(e)
		}
	}
	{
		if s.RawData.Set {
			e.FieldStart("rawData")
			s.RawData.Encode(e)
		}
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzEntityNetworkResponse = [4]string{
	0: "meta",
	1: "links",
	2: "rawData",
	3: "data",
}

// Decode decodes SzEntityNetworkResponse from json.
func (s *SzEntityNetworkResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzEntityNetworkResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		case "links":
			if err := func() error {
				s.Links.Reset()
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		case "rawData":
			if err := func() error {
				s.RawData.Reset()
				if err := s.RawData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawData\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzEntityNetworkResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzEntityNetworkResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzEntityNetworkResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SzEntityNetworkResponseRawData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SzEntityNetworkResponseRawData) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SzEntityNetworkResponseRawData from json.
func (s *SzEntityNetworkResponseRawData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzEntityNetworkResponseRawData to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzEntityNetworkResponseRawData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SzEntityNetworkResponseRawData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzEntityNetworkResponseRawData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzEntityPath) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzEntityPath) encodeFields(e *jx.Encoder) {
	{
		if s.StartEntityId.Set {
			e.FieldStart("startEntityId")
			s.StartEntityId.Encode(e)
		}
	}
	{
		if s.EndEntityId.Set {
			e.FieldStart("endEntityId")
			s.EndEntityId.Encode(e)
		}
	}
	{
		if s.EntityIds.Set {
			e.FieldStart("entityIds")
			s.EntityIds.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzEntityPath = [3]string{
	0: "startEntityId",
	1: "endEntityId",
	2: "entityIds",
}

// Decode decodes SzEntityPath from json.
func (s *SzEntityPath) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzEntityPath to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "startEntityId":
			if err := func() error {
				s.StartEntityId.Reset()
				if err := s.StartEntityId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startEntityId\"")
			}
		case "endEntityId":
			if err := func() error {
				s.EndEntityId.Reset()
				if err := s.EndEntityId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endEntityId\"")
			}
		case "entityIds":
			if err := func() error {
				s.EntityIds.Reset()
				if err := s.EntityIds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entityIds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzEntityPath")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzEntityPath) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzEntityPath) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzEntityPathData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzEntityPathData) encodeFields(e *jx.Encoder) {
	{
		if s.EntityPath.Set {
			e.FieldStart("entityPath")
			s.EntityPath.Encode(e)
		}
	}
	{
		if s.Entities != nil {
			e.FieldStart("entities")
			e.ArrStart()
			for _, elem := range s.Entities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSzEntityPathData = [2]string{
	0: "entityPath",
	1: "entities",
}

// Decode decodes SzEntityPathData from json.
func (s *SzEntityPathData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzEntityPathData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "entityPath":
			if err := func() error {
				s.EntityPath.Reset()
				if err := s.EntityPath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entityPath\"")
			}
		case "entities":
			if err := func() error {
				s.Entities = make([]SzEntityData, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SzEntityData
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Entities = append(s.Entities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entities\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzEntityPathData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzEntityPathData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzEntityPathData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzEntityPathResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzEntityPathResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
	{
		if s.Links.Set {
			e.FieldStart("links")
			s.Links.Encode(e)
		}
	}
	{
		if s.RawData.Set {
			e.FieldStart("rawData")
			s.RawData.Encode(e)
		}
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzEntityPathResponse = [4]string{
	0: "meta",
	1: "links",
	2: "rawData",
	3: "data",
}

// Decode decodes SzEntityPathResponse from json.
func (s *SzEntityPathResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzEntityPathResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		case "links":
			if err := func() error {
				s.Links.Reset()
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		case "rawData":
			if err := func() error {
				s.RawData.Reset()
				if err := s.RawData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawData\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzEntityPathResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzEntityPathResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzEntityPathResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SzEntityPathResponseRawData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SzEntityPathResponseRawData) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SzEntityPathResponseRawData from json.
func (s *SzEntityPathResponseRawData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzEntityPathResponseRawData to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzEntityPathResponseRawData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SzEntityPathResponseRawData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzEntityPathResponseRawData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzEntityRecord) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzEntityRecord) encodeFields(e *jx.Encoder) {
	{
		if s.DataSource.Set {
			e.FieldStart("dataSource")
			s.DataSource.Encode(e)
		}
	}
	{
		if s.RecordId.Set {
			e.FieldStart("recordId")
			s.RecordId.Encode(e)
		}
	}
	{
		if s.FeatureReferences.Set {
			e.FieldStart("featureReferences")
			s.FeatureReferences.Encode(e)
		}
	}
	{
		if s.LastSeenTimestamp.Set {
			e.FieldStart("lastSeenTimestamp")
			s.LastSeenTimestamp.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.AddressData != nil {
			e.FieldStart("addressData")
			e.ArrStart()
			for _, elem := range s.AddressData {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CharacteristicData != nil {
			e.FieldStart("characteristicData")
			e.ArrStart()
			for _, elem := range s.CharacteristicData {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.IdentifierData != nil {
			e.FieldStart("identifierData")
			e.ArrStart()
			for _, elem := range s.IdentifierData {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NameData != nil {
			e.FieldStart("nameData")
			e.ArrStart()
			for _, elem := range s.NameData {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PhoneData != nil {
			e.FieldStart("phoneData")
			e.ArrStart()
			for _, elem := range s.PhoneData {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RelationshipData != nil {
			e.FieldStart("relationshipData")
			e.ArrStart()
			for _, elem := range s.RelationshipData {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.OtherData != nil {
			e.FieldStart("otherData")
			e.ArrStart()
			for _, elem := range s.OtherData {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.OriginalSourceData.Set {
			e.FieldStart("originalSourceData")
			s.OriginalSourceData.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzEntityRecord = [12]string{
	0:  "dataSource",
	1:  "recordId",
	2:  "featureReferences",
	3:  "lastSeenTimestamp",
	4:  "addressData",
	5:  "characteristicData",
	6:  "identifierData",
	7:  "nameData",
	8:  "phoneData",
	9:  "relationshipData",
	10: "otherData",
	11: "originalSourceData",
}

// Decode decodes SzEntityRecord from json.
func (s *SzEntityRecord) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzEntityRecord to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dataSource":
			if err := func() error {
				s.DataSource.Reset()
				if err := s.DataSource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataSource\"")
			}
		case "recordId":
			if err := func() error {
				s.RecordId.Reset()
				if err := s.RecordId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recordId\"")
			}
		case "featureReferences":
			if err := func() error {
				s.FeatureReferences.Reset()
				if err := s.FeatureReferences.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"featureReferences\"")
			}
		case "lastSeenTimestamp":
			if err := func() error {
				s.LastSeenTimestamp.Reset()
				if err := s.LastSeenTimestamp.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastSeenTimestamp\"")
			}
		case "addressData":
			if err := func() error {
				s.AddressData = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AddressData = append(s.AddressData, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"addressData\"")
			}
		case "characteristicData":
			if err := func() error {
				s.CharacteristicData = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.CharacteristicData = append(s.CharacteristicData, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"characteristicData\"")
			}
		case "identifierData":
			if err := func() error {
				s.IdentifierData = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.IdentifierData = append(s.IdentifierData, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"identifierData\"")
			}
		case "nameData":
			if err := func() error {
				s.NameData = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.NameData = append(s.NameData, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nameData\"")
			}
		case "phoneData":
			if err := func() error {
				s.PhoneData = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.PhoneData = append(s.PhoneData, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phoneData\"")
			}
		case "relationshipData":
			if err := func() error {
				s.RelationshipData = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.RelationshipData = append(s.RelationshipData, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"relationshipData\"")
			}
		case "otherData":
			if err := func() error {
				s.OtherData = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.OtherData = append(s.OtherData, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"otherData\"")
			}
		case "originalSourceData":
			if err := func() error {
				s.OriginalSourceData.Reset()
				if err := s.OriginalSourceData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"originalSourceData\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzEntityRecord")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzEntityRecord) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzEntityRecord) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SzEntityRecordOriginalSourceData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SzEntityRecordOriginalSourceData) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SzEntityRecordOriginalSourceData from json.
func (s *SzEntityRecordOriginalSourceData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzEntityRecordOriginalSourceData to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzEntityRecordOriginalSourceData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SzEntityRecordOriginalSourceData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzEntityRecordOriginalSourceData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzEntityResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzEntityResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
	{
		if s.Links.Set {
			e.FieldStart("links")
			s.Links.Encode(e)
		}
	}
	{
		if s.RawData.Set {
			e.FieldStart("rawData")
			s.RawData.Encode(e)
		}
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzEntityResponse = [4]string{
	0: "meta",
	1: "links",
	2: "rawData",
	3: "data",
}

// Decode decodes SzEntityResponse from json.
func (s *SzEntityResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzEntityResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		case "links":
			if err := func() error {
				s.Links.Reset()
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		case "rawData":
			if err := func() error {
				s.RawData.Reset()
				if err := s.RawData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawData\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzEntityResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzEntityResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzEntityResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SzEntityResponseRawData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SzEntityResponseRawData) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SzEntityResponseRawData from json.
func (s *SzEntityResponseRawData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzEntityResponseRawData to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzEntityResponseRawData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SzEntityResponseRawData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzEntityResponseRawData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzError) encodeFields(e *jx.Encoder) {
	{
		if s.Code.Set {
			e.FieldStart("code")
			s.Code.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzError = [2]string{
	0: "code",
	1: "message",
}

// Decode decodes SzError from json.
func (s *SzError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			if err := func() error {
				s.Code.Reset()
				if err := s.Code.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzErrorResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzErrorResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
	{
		if s.Links.Set {
			e.FieldStart("links")
			s.Links.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSzErrorResponse = [3]string{
	0: "meta",
	1: "links",
	2: "errors",
}

// Decode decodes SzErrorResponse from json.
func (s *SzErrorResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzErrorResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		case "links":
			if err := func() error {
				s.Links.Reset()
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]SzError, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SzError
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzErrorResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzErrorResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzErrorResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzFeatureReference) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzFeatureReference) encodeFields(e *jx.Encoder) {
	{
		if s.InternalId.Set {
			e.FieldStart("internalId")
			s.InternalId.Encode(e)
		}
	}
	{
		if s.UsageType.Set {
			e.FieldStart("usageType")
			s.UsageType.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzFeatureReference = [2]string{
	0: "internalId",
	1: "usageType",
}

// Decode decodes SzFeatureReference from json.
func (s *SzFeatureReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzFeatureReference to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "internalId":
			if err := func() error {
				s.InternalId.Reset()
				if err := s.InternalId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"internalId\"")
			}
		case "usageType":
			if err := func() error {
				s.UsageType.Reset()
				if err := s.UsageType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usageType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzFeatureReference")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzFeatureReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzFeatureReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzFeatureScore) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzFeatureScore) encodeFields(e *jx.Encoder) {
	{
		if s.FeatureType.Set {
			e.FieldStart("featureType")
			s.FeatureType.Encode(e)
		}
	}
	{
		if s.InboundFeature.Set {
			e.FieldStart("inboundFeature")
			s.InboundFeature.Encode(e)
		}
	}
	{
		if s.CandidateFeature.Set {
			e.FieldStart("candidateFeature")
			s.CandidateFeature.Encode(e)
		}
	}
	{
		if s.Score.Set {
			e.FieldStart("score")
			s.Score.Encode(e)
		}
	}
	{
		if s.NameScoringDetails.Set {
			e.FieldStart("nameScoringDetails")
			s.NameScoringDetails.Encode(e)
		}
	}
	{
		if s.ScoringBucket.Set {
			e.FieldStart("scoringBucket")
			s.ScoringBucket.Encode(e)
		}
	}
	{
		if s.ScoringBehavior.Set {
			e.FieldStart("scoringBehavior")
			s.ScoringBehavior.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzFeatureScore = [7]string{
	0: "featureType",
	1: "inboundFeature",
	2: "candidateFeature",
	3: "score",
	4: "nameScoringDetails",
	5: "scoringBucket",
	6: "scoringBehavior",
}

// Decode decodes SzFeatureScore from json.
func (s *SzFeatureScore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzFeatureScore to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "featureType":
			if err := func() error {
				s.FeatureType.Reset()
				if err := s.FeatureType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"featureType\"")
			}
		case "inboundFeature":
			if err := func() error {
				s.InboundFeature.Reset()
				if err := s.InboundFeature.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inboundFeature\"")
			}
		case "candidateFeature":
			if err := func() error {
				s.CandidateFeature.Reset()
				if err := s.CandidateFeature.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"candidateFeature\"")
			}
		case "score":
			if err := func() error {
				s.Score.Reset()
				if err := s.Score.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		case "nameScoringDetails":
			if err := func() error {
				s.NameScoringDetails.Reset()
				if err := s.NameScoringDetails.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nameScoringDetails\"")
			}
		case "scoringBucket":
			if err := func() error {
				s.ScoringBucket.Reset()
				if err := s.ScoringBucket.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scoringBucket\"")
			}
		case "scoringBehavior":
			if err := func() error {
				s.ScoringBehavior.Reset()
				if err := s.ScoringBehavior.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scoringBehavior\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzFeatureScore")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzFeatureScore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzFeatureScore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzFlaggedEntity) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzFlaggedEntity) encodeFields(e *jx.Encoder) {
	{
		if s.EntityId.Set {
			e.FieldStart("entityId")
			s.EntityId.Encode(e)
		}
	}
	{
		if s.Degrees.Set {
			e.FieldStart("degrees")
			s.Degrees.Encode(e)
		}
	}
	{
		if s.Flags != nil {
			e.FieldStart("flags")
			e.ArrStart()
			for _, elem := range s.Flags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SampleRecords != nil {
			e.FieldStart("sampleRecords")
			e.ArrStart()
			for _, elem := range s.SampleRecords {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSzFlaggedEntity = [4]string{
	0: "entityId",
	1: "degrees",
	2: "flags",
	3: "sampleRecords",
}

// Decode decodes SzFlaggedEntity from json.
func (s *SzFlaggedEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzFlaggedEntity to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "entityId":
			if err := func() error {
				s.EntityId.Reset()
				if err := s.EntityId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entityId\"")
			}
		case "degrees":
			if err := func() error {
				s.Degrees.Reset()
				if err := s.Degrees.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"degrees\"")
			}
		case "flags":
			if err := func() error {
				s.Flags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Flags = append(s.Flags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"flags\"")
			}
		case "sampleRecords":
			if err := func() error {
				s.SampleRecords = make([]SzFlaggedRecord, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SzFlaggedRecord
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SampleRecords = append(s.SampleRecords, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sampleRecords\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzFlaggedEntity")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzFlaggedEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzFlaggedEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzFlaggedRecord) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzFlaggedRecord) encodeFields(e *jx.Encoder) {
	{
		if s.DataSource.Set {
			e.FieldStart("dataSource")
			s.DataSource.Encode(e)
		}
	}
	{
		if s.RecordId.Set {
			e.FieldStart("recordId")
			s.RecordId.Encode(e)
		}
	}
	{
		if s.Flags != nil {
			e.FieldStart("flags")
			e.ArrStart()
			for _, elem := range s.Flags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSzFlaggedRecord = [3]string{
	0: "dataSource",
	1: "recordId",
	2: "flags",
}

// Decode decodes SzFlaggedRecord from json.
func (s *SzFlaggedRecord) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzFlaggedRecord to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dataSource":
			if err := func() error {
				s.DataSource.Reset()
				if err := s.DataSource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataSource\"")
			}
		case "recordId":
			if err := func() error {
				s.RecordId.Reset()
				if err := s.RecordId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recordId\"")
			}
		case "flags":
			if err := func() error {
				s.Flags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Flags = append(s.Flags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"flags\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzFlaggedRecord")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzFlaggedRecord) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzFlaggedRecord) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzHowEntityResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzHowEntityResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
	{
		if s.Links.Set {
			e.FieldStart("links")
			s.Links.Encode(e)
		}
	}
	{
		if s.RawData.Set {
			e.FieldStart("rawData")
			s.RawData.Encode(e)
		}
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzHowEntityResponse = [4]string{
	0: "meta",
	1: "links",
	2: "rawData",
	3: "data",
}

// Decode decodes SzHowEntityResponse from json.
func (s *SzHowEntityResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzHowEntityResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		case "links":
			if err := func() error {
				s.Links.Reset()
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		case "rawData":
			if err := func() error {
				s.RawData.Reset()
				if err := s.RawData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawData\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzHowEntityResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzHowEntityResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzHowEntityResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SzHowEntityResponseRawData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SzHowEntityResponseRawData) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SzHowEntityResponseRawData from json.
func (s *SzHowEntityResponseRawData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzHowEntityResponseRawData to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzHowEntityResponseRawData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SzHowEntityResponseRawData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzHowEntityResponseRawData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzHowEntityResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzHowEntityResult) encodeFields(e *jx.Encoder) {
	{
		if s.FinalStates != nil {
			e.FieldStart("finalStates")
			e.ArrStart()
			for _, elem := range s.FinalStates {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ResolutionSteps.Set {
			e.FieldStart("resolutionSteps")
			s.ResolutionSteps.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzHowEntityResult = [2]string{
	0: "finalStates",
	1: "resolutionSteps",
}

// Decode decodes SzHowEntityResult from json.
func (s *SzHowEntityResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzHowEntityResult to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "finalStates":
			if err := func() error {
				s.FinalStates = make([]SzVirtualEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SzVirtualEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.FinalStates = append(s.FinalStates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"finalStates\"")
			}
		case "resolutionSteps":
			if err := func() error {
				s.ResolutionSteps.Reset()
				if err := s.ResolutionSteps.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resolutionSteps\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzHowEntityResult")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzHowEntityResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzHowEntityResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SzHowEntityResultResolutionSteps) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SzHowEntityResultResolutionSteps) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes SzHowEntityResultResolutionSteps from json.
func (s *SzHowEntityResultResolutionSteps) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzHowEntityResultResolutionSteps to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem SzResolutionStep
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzHowEntityResultResolutionSteps")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SzHowEntityResultResolutionSteps) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzHowEntityResultResolutionSteps) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzHowMatchInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzHowMatchInfo) encodeFields(e *jx.Encoder) {
	{
		if s.MatchKey.Set {
			e.FieldStart("matchKey")
			s.MatchKey.Encode(e)
		}
	}
	{
		if s.ResolutionRule.Set {
			e.FieldStart("resolutionRule")
			s.ResolutionRule.Encode(e)
		}
	}
	{
		if s.FeatureScores.Set {
			e.FieldStart("featureScores")
			s.FeatureScores.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzHowMatchInfo = [3]string{
	0: "matchKey",
	1: "resolutionRule",
	2: "featureScores",
}

// Decode decodes SzHowMatchInfo from json.
func (s *SzHowMatchInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzHowMatchInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "matchKey":
			if err := func() error {
				s.MatchKey.Reset()
				if err := s.MatchKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchKey\"")
			}
		case "resolutionRule":
			if err := func() error {
				s.ResolutionRule.Reset()
				if err := s.ResolutionRule.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resolutionRule\"")
			}
		case "featureScores":
			if err := func() error {
				s.FeatureScores.Reset()
				if err := s.FeatureScores.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"featureScores\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzHowMatchInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzHowMatchInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzHowMatchInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SzHowMatchInfoFeatureScores) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SzHowMatchInfoFeatureScores) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.ArrStart()
		for _, elem := range elem {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

// Decode decodes SzHowMatchInfoFeatureScores from json.
func (s *SzHowMatchInfoFeatureScores) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzHowMatchInfoFeatureScores to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem []SzFeatureScore
		if err := func() error {
			elem = make([]SzFeatureScore, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elemElem SzFeatureScore
				if err := elemElem.Decode(d); err != nil {
					return err
				}
				elem = append(elem, elemElem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzHowMatchInfoFeatureScores")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SzHowMatchInfoFeatureScores) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzHowMatchInfoFeatureScores) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzHttpMethod as json.
func (s SzHttpMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SzHttpMethod from json.
func (s *SzHttpMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzHttpMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SzHttpMethod(v) {
	case SzHttpMethodGET:
		*s = SzHttpMethodGET
	case SzHttpMethodPOST:
		*s = SzHttpMethodPOST
	case SzHttpMethodPUT:
		*s = SzHttpMethodPUT
	case SzHttpMethodPATCH:
		*s = SzHttpMethodPATCH
	case SzHttpMethodDELETE:
		*s = SzHttpMethodDELETE
	default:
		*s = SzHttpMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SzHttpMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzHttpMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzLicenseInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzLicenseInfo) encodeFields(e *jx.Encoder) {
	{
		if s.Customer.Set {
			e.FieldStart("customer")
			s.Customer.Encode(e)
		}
	}
	{
		if s.Contract.Set {
			e.FieldStart("contract")
			s.Contract.Encode(e)
		}
	}
	{
		if s.LicenseType.Set {
			e.FieldStart("licenseType")
			s.LicenseType.Encode(e)
		}
	}
	{
		if s.LicenseLevel.Set {
			e.FieldStart("licenseLevel")
			s.LicenseLevel.Encode(e)
		}
	}
	{
		if s.Billing.Set {
			e.FieldStart("billing")
			s.Billing.Encode(e)
		}
	}
	{
		if s.IssuanceDate.Set {
			e.FieldStart("issuanceDate")
			s.IssuanceDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ExpirationDate.Set {
			e.FieldStart("expirationDate")
			s.ExpirationDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.RecordLimit.Set {
			e.FieldStart("recordLimit")
			s.RecordLimit.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzLicenseInfo = [8]string{
	0: "customer",
	1: "contract",
	2: "licenseType",
	3: "licenseLevel",
	4: "billing",
	5: "issuanceDate",
	6: "expirationDate",
	7: "recordLimit",
}

// Decode decodes SzLicenseInfo from json.
func (s *SzLicenseInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzLicenseInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "customer":
			if err := func() error {
				s.Customer.Reset()
				if err := s.Customer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"customer\"")
			}
		case "contract":
			if err := func() error {
				s.Contract.Reset()
				if err := s.Contract.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contract\"")
			}
		case "licenseType":
			if err := func() error {
				s.LicenseType.Reset()
				if err := s.LicenseType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"licenseType\"")
			}
		case "licenseLevel":
			if err := func() error {
				s.LicenseLevel.Reset()
				if err := s.LicenseLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"licenseLevel\"")
			}
		case "billing":
			if err := func() error {
				s.Billing.Reset()
				if err := s.Billing.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billing\"")
			}
		case "issuanceDate":
			if err := func() error {
				s.IssuanceDate.Reset()
				if err := s.IssuanceDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issuanceDate\"")
			}
		case "expirationDate":
			if err := func() error {
				s.ExpirationDate.Reset()
				if err := s.ExpirationDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expirationDate\"")
			}
		case "recordLimit":
			if err := func() error {
				s.RecordLimit.Reset()
				if err := s.RecordLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recordLimit\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzLicenseInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzLicenseInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzLicenseInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzLicenseResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzLicenseResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
	{
		if s.Links.Set {
			e.FieldStart("links")
			s.Links.Encode(e)
		}
	}
	{
		if s.RawData.Set {
			e.FieldStart("rawData")
			s.RawData.Encode(e)
		}
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzLicenseResponse = [4]string{
	0: "meta",
	1: "links",
	2: "rawData",
	3: "data",
}

// Decode decodes SzLicenseResponse from json.
func (s *SzLicenseResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzLicenseResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		case "links":
			if err := func() error {
				s.Links.Reset()
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		case "rawData":
			if err := func() error {
				s.RawData.Reset()
				if err := s.RawData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawData\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzLicenseResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzLicenseResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzLicenseResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzLicenseResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzLicenseResponseData) encodeFields(e *jx.Encoder) {
	{
		if s.License.Set {
			e.FieldStart("license")
			s.License.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzLicenseResponseData = [1]string{
	0: "license",
}

// Decode decodes SzLicenseResponseData from json.
func (s *SzLicenseResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzLicenseResponseData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "license":
			if err := func() error {
				s.License.Reset()
				if err := s.License.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"license\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzLicenseResponseData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzLicenseResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzLicenseResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SzLicenseResponseRawData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SzLicenseResponseRawData) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SzLicenseResponseRawData from json.
func (s *SzLicenseResponseRawData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzLicenseResponseRawData to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzLicenseResponseRawData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SzLicenseResponseRawData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzLicenseResponseRawData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzLinks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzLinks) encodeFields(e *jx.Encoder) {
	{
		if s.Self.Set {
			e.FieldStart("self")
			s.Self.Encode(e)
		}
	}
	{
		if s.OpenApiSpecification.Set {
			e.FieldStart("openApiSpecification")
			s.OpenApiSpecification.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzLinks = [2]string{
	0: "self",
	1: "openApiSpecification",
}

// Decode decodes SzLinks from json.
func (s *SzLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzLinks to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "self":
			if err := func() error {
				s.Self.Reset()
				if err := s.Self.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"self\"")
			}
		case "openApiSpecification":
			if err := func() error {
				s.OpenApiSpecification.Reset()
				if err := s.OpenApiSpecification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"openApiSpecification\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzLinks")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzLinks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzLinks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzLoadRecordResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzLoadRecordResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
	{
		if s.Links.Set {
			e.FieldStart("links")
			s.Links.Encode(e)
		}
	}
	{
		if s.RawData.Set {
			e.FieldStart("rawData")
			s.RawData.Encode(e)
		}
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzLoadRecordResponse = [4]string{
	0: "meta",
	1: "links",
	2: "rawData",
	3: "data",
}

// Decode decodes SzLoadRecordResponse from json.
func (s *SzLoadRecordResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzLoadRecordResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		case "links":
			if err := func() error {
				s.Links.Reset()
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		case "rawData":
			if err := func() error {
				s.RawData.Reset()
				if err := s.RawData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawData\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzLoadRecordResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzLoadRecordResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzLoadRecordResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzLoadRecordResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzLoadRecordResponseData) encodeFields(e *jx.Encoder) {
	{
		if s.RecordId.Set {
			e.FieldStart("recordId")
			s.RecordId.Encode(e)
		}
	}
	{
		if s.Info.Set {
			e.FieldStart("info")
			s.Info.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzLoadRecordResponseData = [2]string{
	0: "recordId",
	1: "info",
}

// Decode decodes SzLoadRecordResponseData from json.
func (s *SzLoadRecordResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzLoadRecordResponseData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "recordId":
			if err := func() error {
				s.RecordId.Reset()
				if err := s.RecordId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recordId\"")
			}
		case "info":
			if err := func() error {
				s.Info.Reset()
				if err := s.Info.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"info\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzLoadRecordResponseData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzLoadRecordResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzLoadRecordResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SzLoadRecordResponseRawData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SzLoadRecordResponseRawData) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SzLoadRecordResponseRawData from json.
func (s *SzLoadRecordResponseRawData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzLoadRecordResponseRawData to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzLoadRecordResponseRawData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SzLoadRecordResponseRawData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzLoadRecordResponseRawData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzMatchLevel as json.
func (s SzMatchLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SzMatchLevel from json.
func (s *SzMatchLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzMatchLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SzMatchLevel(v) {
	case SzMatchLevelNOMATCH:
		*s = SzMatchLevelNOMATCH
	case SzMatchLevelRESOLVED:
		*s = SzMatchLevelRESOLVED
	case SzMatchLevelPOSSIBLYSAME:
		*s = SzMatchLevelPOSSIBLYSAME
	case SzMatchLevelPOSSIBLYRELATED:
		*s = SzMatchLevelPOSSIBLYRELATED
	case SzMatchLevelNAMEONLY:
		*s = SzMatchLevelNAMEONLY
	case SzMatchLevelDISCLOSED:
		*s = SzMatchLevelDISCLOSED
	default:
		*s = SzMatchLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SzMatchLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzMatchLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzMatchedRecord) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzMatchedRecord) encodeFields(e *jx.Encoder) {
	{
		if s.DataSource.Set {
			e.FieldStart("dataSource")
			s.DataSource.Encode(e)
		}
	}
	{
		if s.RecordId.Set {
			e.FieldStart("recordId")
			s.RecordId.Encode(e)
		}
	}
	{
		if s.FeatureReferences.Set {
			e.FieldStart("featureReferences")
			s.FeatureReferences.Encode(e)
		}
	}
	{
		if s.LastSeenTimestamp.Set {
			e.FieldStart("lastSeenTimestamp")
			s.LastSeenTimestamp.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.AddressData != nil {
			e.FieldStart("addressData")
			e.ArrStart()
			for _, elem := range s.AddressData {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CharacteristicData != nil {
			e.FieldStart("characteristicData")
			e.ArrStart()
			for _, elem := range s.CharacteristicData {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.IdentifierData != nil {
			e.FieldStart("identifierData")
			e.ArrStart()
			for _, elem := range s.IdentifierData {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NameData != nil {
			e.FieldStart("nameData")
			e.ArrStart()
			for _, elem := range s.NameData {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PhoneData != nil {
			e.FieldStart("phoneData")
			e.ArrStart()
			for _, elem := range s.PhoneData {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RelationshipData != nil {
			e.FieldStart("relationshipData")
			e.ArrStart()
			for _, elem := range s.RelationshipData {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.OtherData != nil {
			e.FieldStart("otherData")
			e.ArrStart()
			for _, elem := range s.OtherData {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.OriginalSourceData.Set {
			e.FieldStart("originalSourceData")
			s.OriginalSourceData.Encode(e)
		}
	}
	{
		if s.MatchKey.Set {
			e.FieldStart("matchKey")
			s.MatchKey.Encode(e)
		}
	}
	{
		if s.ResolutionRuleCode.Set {
			e.FieldStart("resolutionRuleCode")
			s.ResolutionRuleCode.Encode(e)
		}
	}
	{
		if s.MatchLevel.Set {
			e.FieldStart("matchLevel")
			s.MatchLevel.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzMatchedRecord = [15]string{
	0:  "dataSource",
	1:  "recordId",
	2:  "featureReferences",
	3:  "lastSeenTimestamp",
	4:  "addressData",
	5:  "characteristicData",
	6:  "identifierData",
	7:  "nameData",
	8:  "phoneData",
	9:  "relationshipData",
	10: "otherData",
	11: "originalSourceData",
	12: "matchKey",
	13: "resolutionRuleCode",
	14: "matchLevel",
}

// Decode decodes SzMatchedRecord from json.
func (s *SzMatchedRecord) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzMatchedRecord to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dataSource":
			if err := func() error {
				s.DataSource.Reset()
				if err := s.DataSource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataSource\"")
			}
		case "recordId":
			if err := func() error {
				s.RecordId.Reset()
				if err := s.RecordId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recordId\"")
			}
		case "featureReferences":
			if err := func() error {
				s.FeatureReferences.Reset()
				if err := s.FeatureReferences.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"featureReferences\"")
			}
		case "lastSeenTimestamp":
			if err := func() error {
				s.LastSeenTimestamp.Reset()
				if err := s.LastSeenTimestamp.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastSeenTimestamp\"")
			}
		case "addressData":
			if err := func() error {
				s.AddressData = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AddressData = append(s.AddressData, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"addressData\"")
			}
		case "characteristicData":
			if err := func() error {
				s.CharacteristicData = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.CharacteristicData = append(s.CharacteristicData, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"characteristicData\"")
			}
		case "identifierData":
			if err := func() error {
				s.IdentifierData = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.IdentifierData = append(s.IdentifierData, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"identifierData\"")
			}
		case "nameData":
			if err := func() error {
				s.NameData = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.NameData = append(s.NameData, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nameData\"")
			}
		case "phoneData":
			if err := func() error {
				s.PhoneData = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.PhoneData = append(s.PhoneData, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phoneData\"")
			}
		case "relationshipData":
			if err := func() error {
				s.RelationshipData = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.RelationshipData = append(s.RelationshipData, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"relationshipData\"")
			}
		case "otherData":
			if err := func() error {
				s.OtherData = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.OtherData = append(s.OtherData, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"otherData\"")
			}
		case "originalSourceData":
			if err := func() error {
				s.OriginalSourceData.Reset()
				if err := s.OriginalSourceData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"originalSourceData\"")
			}
		case "matchKey":
			if err := func() error {
				s.MatchKey.Reset()
				if err := s.MatchKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchKey\"")
			}
		case "resolutionRuleCode":
			if err := func() error {
				s.ResolutionRuleCode.Reset()
				if err := s.ResolutionRuleCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resolutionRuleCode\"")
			}
		case "matchLevel":
			if err := func() error {
				s.MatchLevel.Reset()
				if err := s.MatchLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchLevel\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzMatchedRecord")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzMatchedRecord) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzMatchedRecord) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SzMatchedRecordOriginalSourceData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SzMatchedRecordOriginalSourceData) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SzMatchedRecordOriginalSourceData from json.
func (s *SzMatchedRecordOriginalSourceData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzMatchedRecordOriginalSourceData to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzMatchedRecordOriginalSourceData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SzMatchedRecordOriginalSourceData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzMatchedRecordOriginalSourceData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzMeta) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzMeta) encodeFields(e *jx.Encoder) {
	{
		if s.Server.Set {
			e.FieldStart("server")
			s.Server.Encode(e)
		}
	}
	{
		if s.HttpMethod.Set {
			e.FieldStart("httpMethod")
			s.HttpMethod.Encode(e)
		}
	}
	{
		if s.HttpStatusCode.Set {
			e.FieldStart("httpStatusCode")
			s.HttpStatusCode.Encode(e)
		}
	}
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.RestApiVersion.Set {
			e.FieldStart("restApiVersion")
			s.RestApiVersion.Encode(e)
		}
	}
	{
		if s.NativeApiVersion.Set {
			e.FieldStart("nativeApiVersion")
			s.NativeApiVersion.Encode(e)
		}
	}
	{
		if s.NativeApiBuildVersion.Set {
			e.FieldStart("nativeApiBuildVersion")
			s.NativeApiBuildVersion.Encode(e)
		}
	}
	{
		if s.NativeApiBuildNumber.Set {
			e.FieldStart("nativeApiBuildNumber")
			s.NativeApiBuildNumber.Encode(e)
		}
	}
	{
		if s.NativeApiBuildDate.Set {
			e.FieldStart("nativeApiBuildDate")
			s.NativeApiBuildDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ConfigCompatibilityVersion.Set {
			e.FieldStart("configCompatibilityVersion")
			s.ConfigCompatibilityVersion.Encode(e)
		}
	}
	{
		if s.Timings.Set {
			e.FieldStart("timings")
			s.Timings.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzMeta = [12]string{
	0:  "server",
	1:  "httpMethod",
	2:  "httpStatusCode",
	3:  "timestamp",
	4:  "version",
	5:  "restApiVersion",
	6:  "nativeApiVersion",
	7:  "nativeApiBuildVersion",
	8:  "nativeApiBuildNumber",
	9:  "nativeApiBuildDate",
	10: "configCompatibilityVersion",
	11: "timings",
}

// Decode decodes SzMeta from json.
func (s *SzMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzMeta to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "server":
			if err := func() error {
				s.Server.Reset()
				if err := s.Server.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"server\"")
			}
		case "httpMethod":
			if err := func() error {
				s.HttpMethod.Reset()
				if err := s.HttpMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"httpMethod\"")
			}
		case "httpStatusCode":
			if err := func() error {
				s.HttpStatusCode.Reset()
				if err := s.HttpStatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"httpStatusCode\"")
			}
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "restApiVersion":
			if err := func() error {
				s.RestApiVersion.Reset()
				if err := s.RestApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"restApiVersion\"")
			}
		case "nativeApiVersion":
			if err := func() error {
				s.NativeApiVersion.Reset()
				if err := s.NativeApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nativeApiVersion\"")
			}
		case "nativeApiBuildVersion":
			if err := func() error {
				s.NativeApiBuildVersion.Reset()
				if err := s.NativeApiBuildVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nativeApiBuildVersion\"")
			}
		case "nativeApiBuildNumber":
			if err := func() error {
				s.NativeApiBuildNumber.Reset()
				if err := s.NativeApiBuildNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nativeApiBuildNumber\"")
			}
		case "nativeApiBuildDate":
			if err := func() error {
				s.NativeApiBuildDate.Reset()
				if err := s.NativeApiBuildDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nativeApiBuildDate\"")
			}
		case "configCompatibilityVersion":
			if err := func() error {
				s.ConfigCompatibilityVersion.Reset()
				if err := s.ConfigCompatibilityVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configCompatibilityVersion\"")
			}
		case "timings":
			if err := func() error {
				s.Timings.Reset()
				if err := s.Timings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzMeta")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SzMetaTimings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SzMetaTimings) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Int64(elem)
	}
}

// Decode decodes SzMetaTimings from json.
func (s *SzMetaTimings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzMetaTimings to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem int64
		if err := func() error {
			v, err := d.Int64()
			elem = int64(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzMetaTimings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SzMetaTimings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzMetaTimings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzNameScoring) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzNameScoring) encodeFields(e *jx.Encoder) {
	{
		if s.FullNameScore.Set {
			e.FieldStart("fullNameScore")
			s.FullNameScore.Encode(e)
		}
	}
	{
		if s.SurnameScore.Set {
			e.FieldStart("surnameScore")
			s.SurnameScore.Encode(e)
		}
	}
	{
		if s.GivenNameScore.Set {
			e.FieldStart("givenNameScore")
			s.GivenNameScore.Encode(e)
		}
	}
	{
		if s.GenerationScore.Set {
			e.FieldStart("generationScore")
			s.GenerationScore.Encode(e)
		}
	}
	{
		if s.OrgNameScore.Set {
			e.FieldStart("orgNameScore")
			s.OrgNameScore.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzNameScoring = [5]string{
	0: "fullNameScore",
	1: "surnameScore",
	2: "givenNameScore",
	3: "generationScore",
	4: "orgNameScore",
}

// Decode decodes SzNameScoring from json.
func (s *SzNameScoring) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzNameScoring to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fullNameScore":
			if err := func() error {
				s.FullNameScore.Reset()
				if err := s.FullNameScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fullNameScore\"")
			}
		case "surnameScore":
			if err := func() error {
				s.SurnameScore.Reset()
				if err := s.SurnameScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"surnameScore\"")
			}
		case "givenNameScore":
			if err := func() error {
				s.GivenNameScore.Reset()
				if err := s.GivenNameScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"givenNameScore\"")
			}
		case "generationScore":
			if err := func() error {
				s.GenerationScore.Reset()
				if err := s.GenerationScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"generationScore\"")
			}
		case "orgNameScore":
			if err := func() error {
				s.OrgNameScore.Reset()
				if err := s.OrgNameScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"orgNameScore\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzNameScoring")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzNameScoring) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzNameScoring) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzRecordResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzRecordResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
	{
		if s.Links.Set {
			e.FieldStart("links")
			s.Links.Encode(e)
		}
	}
	{
		if s.RawData.Set {
			e.FieldStart("rawData")
			s.RawData.Encode(e)
		}
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzRecordResponse = [4]string{
	0: "meta",
	1: "links",
	2: "rawData",
	3: "data",
}

// Decode decodes SzRecordResponse from json.
func (s *SzRecordResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzRecordResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		case "links":
			if err := func() error {
				s.Links.Reset()
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		case "rawData":
			if err := func() error {
				s.RawData.Reset()
				if err := s.RawData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawData\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzRecordResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzRecordResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzRecordResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzRecordResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzRecordResponseData) encodeFields(e *jx.Encoder) {
	{
		if s.Record.Set {
			e.FieldStart("record")
			s.Record.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzRecordResponseData = [1]string{
	0: "record",
}

// Decode decodes SzRecordResponseData from json.
func (s *SzRecordResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzRecordResponseData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "record":
			if err := func() error {
				s.Record.Reset()
				if err := s.Record.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"record\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzRecordResponseData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzRecordResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzRecordResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SzRecordResponseRawData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SzRecordResponseRawData) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SzRecordResponseRawData from json.
func (s *SzRecordResponseRawData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzRecordResponseRawData to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzRecordResponseRawData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SzRecordResponseRawData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzRecordResponseRawData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzReevaluateResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzReevaluateResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
	{
		if s.Links.Set {
			e.FieldStart("links")
			s.Links.Encode(e)
		}
	}
	{
		if s.RawData.Set {
			e.FieldStart("rawData")
			s.RawData.Encode(e)
		}
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzReevaluateResponse = [4]string{
	0: "meta",
	1: "links",
	2: "rawData",
	3: "data",
}

// Decode decodes SzReevaluateResponse from json.
func (s *SzReevaluateResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzReevaluateResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		case "links":
			if err := func() error {
				s.Links.Reset()
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		case "rawData":
			if err := func() error {
				s.RawData.Reset()
				if err := s.RawData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawData\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzReevaluateResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzReevaluateResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzReevaluateResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzReevaluateResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzReevaluateResponseData) encodeFields(e *jx.Encoder) {
	{
		if s.Info.Set {
			e.FieldStart("info")
			s.Info.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzReevaluateResponseData = [1]string{
	0: "info",
}

// Decode decodes SzReevaluateResponseData from json.
func (s *SzReevaluateResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzReevaluateResponseData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "info":
			if err := func() error {
				s.Info.Reset()
				if err := s.Info.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"info\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzReevaluateResponseData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzReevaluateResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzReevaluateResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SzReevaluateResponseRawData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SzReevaluateResponseRawData) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SzReevaluateResponseRawData from json.
func (s *SzReevaluateResponseRawData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzReevaluateResponseRawData to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzReevaluateResponseRawData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SzReevaluateResponseRawData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzReevaluateResponseRawData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzRelatedEntity) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzRelatedEntity) encodeFields(e *jx.Encoder) {
	{
		if s.EntityId.Set {
			e.FieldStart("entityId")
			s.EntityId.Encode(e)
		}
	}
	{
		if s.EntityName.Set {
			e.FieldStart("entityName")
			s.EntityName.Encode(e)
		}
	}
	{
		if s.BestName.Set {
			e.FieldStart("bestName")
			s.BestName.Encode(e)
		}
	}
	{
		if s.RecordSummaries != nil {
			e.FieldStart("recordSummaries")
			e.ArrStart()
			for _, elem := range s.RecordSummaries {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NameData != nil {
			e.FieldStart("nameData")
			e.ArrStart()
			for _, elem := range s.NameData {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CharacteristicData != nil {
			e.FieldStart("characteristicData")
			e.ArrStart()
			for _, elem := range s.CharacteristicData {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AddressData != nil {
			e.FieldStart("addressData")
			e.ArrStart()
			for _, elem := range s.AddressData {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PhoneData != nil {
			e.FieldStart("phoneData")
			e.ArrStart()
			for _, elem := range s.PhoneData {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.IdentifierData != nil {
			e.FieldStart("identifierData")
			e.ArrStart()
			for _, elem := range s.IdentifierData {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RelationshipData != nil {
			e.FieldStart("relationshipData")
			e.ArrStart()
			for _, elem := range s.RelationshipData {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.OtherData != nil {
			e.FieldStart("otherData")
			e.ArrStart()
			for _, elem := range s.OtherData {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Records != nil {
			e.FieldStart("records")
			e.ArrStart()
			for _, elem := range s.Records {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Features.Set {
			e.FieldStart("features")
			s.Features.Encode(e)
		}
	}
	{
		if s.Partial.Set {
			e.FieldStart("partial")
			s.Partial.Encode(e)
		}
	}
	{
		if s.LastSeenTimestamp.Set {
			e.FieldStart("lastSeenTimestamp")
			s.LastSeenTimestamp.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.MatchLevel.Set {
			e.FieldStart("matchLevel")
			s.MatchLevel.Encode(e)
		}
	}
	{
		if s.MatchKey.Set {
			e.FieldStart("matchKey")
			s.MatchKey.Encode(e)
		}
	}
	{
		if s.ResolutionRuleCode.Set {
			e.FieldStart("resolutionRuleCode")
			s.ResolutionRuleCode.Encode(e)
		}
	}
	{
		if s.Disclosed.Set {
			e.FieldStart("disclosed")
			s.Disclosed.Encode(e)
		}
	}
	{
		if s.Ambiguous.Set {
			e.FieldStart("ambiguous")
			s.Ambiguous.Encode(e)
		}
	}
	{
		if s.RelationType.Set {
			e.FieldStart("relationType")
			s.RelationType.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzRelatedEntity = [21]string{
	0:  "entityId",
	1:  "entityName",
	2:  "bestName",
	3:  "recordSummaries",
	4:  "nameData",
	5:  "characteristicData",
	6:  "addressData",
	7:  "phoneData",
	8:  "identifierData",
	9:  "relationshipData",
	10: "otherData",
	11: "records",
	12: "features",
	13: "partial",
	14: "lastSeenTimestamp",
	15: "matchLevel",
	16: "matchKey",
	17: "resolutionRuleCode",
	18: "disclosed",
	19: "ambiguous",
	20: "relationType",
}

// Decode decodes SzRelatedEntity from json.
func (s *SzRelatedEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzRelatedEntity to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "entityId":
			if err := func() error {
				s.EntityId.Reset()
				if err := s.EntityId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entityId\"")
			}
		case "entityName":
			if err := func() error {
				s.EntityName.Reset()
				if err := s.EntityName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entityName\"")
			}
		case "bestName":
			if err := func() error {
				s.BestName.Reset()
				if err := s.BestName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bestName\"")
			}
		case "recordSummaries":
			if err := func() error {
				s.RecordSummaries = make([]SzDataSourceRecordSummary, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SzDataSourceRecordSummary
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RecordSummaries = append(s.RecordSummaries, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recordSummaries\"")
			}
		case "nameData":
			if err := func() error {
				s.NameData = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.NameData = append(s.NameData, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nameData\"")
			}
		case "characteristicData":
			if err := func() error {
				s.CharacteristicData = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.CharacteristicData = append(s.CharacteristicData, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"characteristicData\"")
			}
		case "addressData":
			if err := func() error {
				s.AddressData = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AddressData = append(s.AddressData, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"addressData\"")
			}
		case "phoneData":
			if err := func() error {
				s.PhoneData = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.PhoneData = append(s.PhoneData, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phoneData\"")
			}
		case "identifierData":
			if err := func() error {
				s.IdentifierData = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.IdentifierData = append(s.IdentifierData, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"identifierData\"")
			}
		case "relationshipData":
			if err := func() error {
				s.RelationshipData = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.RelationshipData = append(s.RelationshipData, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"relationshipData\"")
			}
		case "otherData":
			if err := func() error {
				s.OtherData = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.OtherData = append(s.OtherData, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"otherData\"")
			}
		case "records":
			if err := func() error {
				s.Records = make([]SzMatchedRecord, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SzMatchedRecord
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Records = append(s.Records, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"records\"")
			}
		case "features":
			if err := func() error {
				s.Features.Reset()
				if err := s.Features.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"features\"")
			}
		case "partial":
			if err := func() error {
				s.Partial.Reset()
				if err := s.Partial.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"partial\"")
			}
		case "lastSeenTimestamp":
			if err := func() error {
				s.LastSeenTimestamp.Reset()
				if err := s.LastSeenTimestamp.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastSeenTimestamp\"")
			}
		case "matchLevel":
			if err := func() error {
				s.MatchLevel.Reset()
				if err := s.MatchLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchLevel\"")
			}
		case "matchKey":
			if err := func() error {
				s.MatchKey.Reset()
				if err := s.MatchKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchKey\"")
			}
		case "resolutionRuleCode":
			if err := func() error {
				s.ResolutionRuleCode.Reset()
				if err := s.ResolutionRuleCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resolutionRuleCode\"")
			}
		case "disclosed":
			if err := func() error {
				s.Disclosed.Reset()
				if err := s.Disclosed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disclosed\"")
			}
		case "ambiguous":
			if err := func() error {
				s.Ambiguous.Reset()
				if err := s.Ambiguous.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ambiguous\"")
			}
		case "relationType":
			if err := func() error {
				s.RelationType.Reset()
				if err := s.RelationType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"relationType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzRelatedEntity")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzRelatedEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzRelatedEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SzRelatedEntityFeatures) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SzRelatedEntityFeatures) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.ArrStart()
		for _, elem := range elem {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

// Decode decodes SzRelatedEntityFeatures from json.
func (s *SzRelatedEntityFeatures) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzRelatedEntityFeatures to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem []SzEntityFeature
		if err := func() error {
			elem = make([]SzEntityFeature, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elemElem SzEntityFeature
				if err := elemElem.Decode(d); err != nil {
					return err
				}
				elem = append(elem, elemElem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzRelatedEntityFeatures")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SzRelatedEntityFeatures) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzRelatedEntityFeatures) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzRelatedFeatures) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzRelatedFeatures) encodeFields(e *jx.Encoder) {
	{
		if s.Feature1.Set {
			e.FieldStart("feature1")
			s.Feature1.Encode(e)
		}
	}
	{
		if s.Feature2.Set {
			e.FieldStart("feature2")
			s.Feature2.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzRelatedFeatures = [2]string{
	0: "feature1",
	1: "feature2",
}

// Decode decodes SzRelatedFeatures from json.
func (s *SzRelatedFeatures) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzRelatedFeatures to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "feature1":
			if err := func() error {
				s.Feature1.Reset()
				if err := s.Feature1.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"feature1\"")
			}
		case "feature2":
			if err := func() error {
				s.Feature2.Reset()
				if err := s.Feature2.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"feature2\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzRelatedFeatures")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzRelatedFeatures) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzRelatedFeatures) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzRelationDirection as json.
func (s SzRelationDirection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SzRelationDirection from json.
func (s *SzRelationDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzRelationDirection to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SzRelationDirection(v) {
	case SzRelationDirectionINBOUND:
		*s = SzRelationDirectionINBOUND
	case SzRelationDirectionOUTBOUND:
		*s = SzRelationDirectionOUTBOUND
	case SzRelationDirectionBIDIRECTIONAL:
		*s = SzRelationDirectionBIDIRECTIONAL
	default:
		*s = SzRelationDirection(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SzRelationDirection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzRelationDirection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzRelationshipType as json.
func (s SzRelationshipType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SzRelationshipType from json.
func (s *SzRelationshipType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzRelationshipType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SzRelationshipType(v) {
	case SzRelationshipTypePOSSIBLEMATCH:
		*s = SzRelationshipTypePOSSIBLEMATCH
	case SzRelationshipTypePOSSIBLERELATION:
		*s = SzRelationshipTypePOSSIBLERELATION
	case SzRelationshipTypeDISCLOSEDRELATION:
		*s = SzRelationshipTypeDISCLOSEDRELATION
	default:
		*s = SzRelationshipType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SzRelationshipType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzRelationshipType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzResolutionInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzResolutionInfo) encodeFields(e *jx.Encoder) {
	{
		if s.DataSource.Set {
			e.FieldStart("dataSource")
			s.DataSource.Encode(e)
		}
	}
	{
		if s.RecordId.Set {
			e.FieldStart("recordId")
			s.RecordId.Encode(e)
		}
	}
	{
		if s.AffectedEntities != nil {
			e.FieldStart("affectedEntities")
			e.ArrStart()
			for _, elem := range s.AffectedEntities {
				e.Int64(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.FlaggedEntities != nil {
			e.FieldStart("flaggedEntities")
			e.ArrStart()
			for _, elem := range s.FlaggedEntities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSzResolutionInfo = [4]string{
	0: "dataSource",
	1: "recordId",
	2: "affectedEntities",
	3: "flaggedEntities",
}

// Decode decodes SzResolutionInfo from json.
func (s *SzResolutionInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzResolutionInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dataSource":
			if err := func() error {
				s.DataSource.Reset()
				if err := s.DataSource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataSource\"")
			}
		case "recordId":
			if err := func() error {
				s.RecordId.Reset()
				if err := s.RecordId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recordId\"")
			}
		case "affectedEntities":
			if err := func() error {
				s.AffectedEntities = make([]int64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int64
					v, err := d.Int64()
					elem = int64(v)
					if err != nil {
						return err
					}
					s.AffectedEntities = append(s.AffectedEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"affectedEntities\"")
			}
		case "flaggedEntities":
			if err := func() error {
				s.FlaggedEntities = make([]SzFlaggedEntity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SzFlaggedEntity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.FlaggedEntities = append(s.FlaggedEntities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"flaggedEntities\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzResolutionInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzResolutionInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzResolutionInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzResolutionStep) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzResolutionStep) encodeFields(e *jx.Encoder) {
	{
		if s.StepNumber.Set {
			e.FieldStart("stepNumber")
			s.StepNumber.Encode(e)
		}
	}
	{
		if s.InboundVirtualEntity.Set {
			e.FieldStart("inboundVirtualEntity")
			s.InboundVirtualEntity.Encode(e)
		}
	}
	{
		if s.CandidateVirtualEntity.Set {
			e.FieldStart("candidateVirtualEntity")
			s.CandidateVirtualEntity.Encode(e)
		}
	}
	{
		if s.MatchInfo.Set {
			e.FieldStart("matchInfo")
			s.MatchInfo.Encode(e)
		}
	}
	{
		if s.ResolvedVirtualEntityId.Set {
			e.FieldStart("resolvedVirtualEntityId")
			s.ResolvedVirtualEntityId.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzResolutionStep = [5]string{
	0: "stepNumber",
	1: "inboundVirtualEntity",
	2: "candidateVirtualEntity",
	3: "matchInfo",
	4: "resolvedVirtualEntityId",
}

// Decode decodes SzResolutionStep from json.
func (s *SzResolutionStep) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzResolutionStep to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "stepNumber":
			if err := func() error {
				s.StepNumber.Reset()
				if err := s.StepNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stepNumber\"")
			}
		case "inboundVirtualEntity":
			if err := func() error {
				s.InboundVirtualEntity.Reset()
				if err := s.InboundVirtualEntity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inboundVirtualEntity\"")
			}
		case "candidateVirtualEntity":
			if err := func() error {
				s.CandidateVirtualEntity.Reset()
				if err := s.CandidateVirtualEntity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"candidateVirtualEntity\"")
			}
		case "matchInfo":
			if err := func() error {
				s.MatchInfo.Reset()
				if err := s.MatchInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchInfo\"")
			}
		case "resolvedVirtualEntityId":
			if err := func() error {
				s.ResolvedVirtualEntityId.Reset()
				if err := s.ResolvedVirtualEntityId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resolvedVirtualEntityId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzResolutionStep")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzResolutionStep) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzResolutionStep) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzResolvedEntity) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzResolvedEntity) encodeFields(e *jx.Encoder) {
	{
		if s.EntityId.Set {
			e.FieldStart("entityId")
			s.EntityId.Encode(e)
		}
	}
	{
		if s.EntityName.Set {
			e.FieldStart("entityName")
			s.EntityName.Encode(e)
		}
	}
	{
		if s.BestName.Set {
			e.FieldStart("bestName")
			s.BestName.Encode(e)
		}
	}
	{
		if s.RecordSummaries != nil {
			e.FieldStart("recordSummaries")
			e.ArrStart()
			for _, elem := range s.RecordSummaries {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NameData != nil {
			e.FieldStart("nameData")
			e.ArrStart()
			for _, elem := range s.NameData {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CharacteristicData != nil {
			e.FieldStart("characteristicData")
			e.ArrStart()
			for _, elem := range s.CharacteristicData {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AddressData != nil {
			e.FieldStart("addressData")
			e.ArrStart()
			for _, elem := range s.AddressData {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PhoneData != nil {
			e.FieldStart("phoneData")
			e.ArrStart()
			for _, elem := range s.PhoneData {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.IdentifierData != nil {
			e.FieldStart("identifierData")
			e.ArrStart()
			for _, elem := range s.IdentifierData {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RelationshipData != nil {
			e.FieldStart("relationshipData")
			e.ArrStart()
			for _, elem := range s.RelationshipData {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.OtherData != nil {
			e.FieldStart("otherData")
			e.ArrStart()
			for _, elem := range s.OtherData {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Records != nil {
			e.FieldStart("records")
			e.ArrStart()
			for _, elem := range s.Records {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Features.Set {
			e.FieldStart("features")
			s.Features.Encode(e)
		}
	}
	{
		if s.Partial.Set {
			e.FieldStart("partial")
			s.Partial.Encode(e)
		}
	}
	{
		if s.LastSeenTimestamp.Set {
			e.FieldStart("lastSeenTimestamp")
			s.LastSeenTimestamp.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfSzResolvedEntity = [15]string{
	0:  "entityId",
	1:  "entityName",
	2:  "bestName",
	3:  "recordSummaries",
	4:  "nameData",
	5:  "characteristicData",
	6:  "addressData",
	7:  "phoneData",
	8:  "identifierData",
	9:  "relationshipData",
	10: "otherData",
	11: "records",
	12: "features",
	13: "partial",
	14: "lastSeenTimestamp",
}

// Decode decodes SzResolvedEntity from json.
func (s *SzResolvedEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzResolvedEntity to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "entityId":
			if err := func() error {
				s.EntityId.Reset()
				if err := s.EntityId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entityId\"")
			}
		case "entityName":
			if err := func() error {
				s.EntityName.Reset()
				if err := s.EntityName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entityName\"")
			}
		case "bestName":
			if err := func() error {
				s.BestName.Reset()
				if err := s.BestName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bestName\"")
			}
		case "recordSummaries":
			if err := func() error {
				s.RecordSummaries = make([]SzDataSourceRecordSummary, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SzDataSourceRecordSummary
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RecordSummaries = append(s.RecordSummaries, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recordSummaries\"")
			}
		case "nameData":
			if err := func() error {
				s.NameData = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.NameData = append(s.NameData, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nameData\"")
			}
		case "characteristicData":
			if err := func() error {
				s.CharacteristicData = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.CharacteristicData = append(s.CharacteristicData, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"characteristicData\"")
			}
		case "addressData":
			if err := func() error {
				s.AddressData = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AddressData = append(s.AddressData, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"addressData\"")
			}
		case "phoneData":
			if err := func() error {
				s.PhoneData = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.PhoneData = append(s.PhoneData, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phoneData\"")
			}
		case "identifierData":
			if err := func() error {
				s.IdentifierData = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.IdentifierData = append(s.IdentifierData, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"identifierData\"")
			}
		case "relationshipData":
			if err := func() error {
				s.RelationshipData = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.RelationshipData = append(s.RelationshipData, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"relationshipData\"")
			}
		case "otherData":
			if err := func() error {
				s.OtherData = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.OtherData = append(s.OtherData, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"otherData\"")
			}
		case "records":
			if err := func() error {
				s.Records = make([]SzMatchedRecord, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SzMatchedRecord
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Records = append(s.Records, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"records\"")
			}
		case "features":
			if err := func() error {
				s.Features.Reset()
				if err := s.Features.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"features\"")
			}
		case "partial":
			if err := func() error {
				s.Partial.Reset()
				if err := s.Partial.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"partial\"")
			}
		case "lastSeenTimestamp":
			if err := func() error {
				s.LastSeenTimestamp.Reset()
				if err := s.LastSeenTimestamp.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastSeenTimestamp\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzResolvedEntity")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzResolvedEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzResolvedEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SzResolvedEntityFeatures) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SzResolvedEntityFeatures) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.ArrStart()
		for _, elem := range elem {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

// Decode decodes SzResolvedEntityFeatures from json.
func (s *SzResolvedEntityFeatures) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzResolvedEntityFeatures to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem []SzEntityFeature
		if err := func() error {
			elem = make([]SzEntityFeature, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elemElem SzEntityFeature
				if err := elemElem.Decode(d); err != nil {
					return err
				}
				elem = append(elem, elemElem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzResolvedEntityFeatures")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SzResolvedEntityFeatures) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzResolvedEntityFeatures) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzScoredFeature) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzScoredFeature) encodeFields(e *jx.Encoder) {
	{
		if s.FeatureId.Set {
			e.FieldStart("featureId")
			s.FeatureId.Encode(e)
		}
	}
	{
		if s.FeatureType.Set {
			e.FieldStart("featureType")
			s.FeatureType.Encode(e)
		}
	}
	{
		if s.FeatureValue.Set {
			e.FieldStart("featureValue")
			s.FeatureValue.Encode(e)
		}
	}
	{
		if s.UsageType.Set {
			e.FieldStart("usageType")
			s.UsageType.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzScoredFeature = [4]string{
	0: "featureId",
	1: "featureType",
	2: "featureValue",
	3: "usageType",
}

// Decode decodes SzScoredFeature from json.
func (s *SzScoredFeature) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzScoredFeature to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "featureId":
			if err := func() error {
				s.FeatureId.Reset()
				if err := s.FeatureId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"featureId\"")
			}
		case "featureType":
			if err := func() error {
				s.FeatureType.Reset()
				if err := s.FeatureType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"featureType\"")
			}
		case "featureValue":
			if err := func() error {
				s.FeatureValue.Reset()
				if err := s.FeatureValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"featureValue\"")
			}
		case "usageType":
			if err := func() error {
				s.UsageType.Reset()
				if err := s.UsageType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usageType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzScoredFeature")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzScoredFeature) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzScoredFeature) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzScoringBehavior) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzScoringBehavior) encodeFields(e *jx.Encoder) {
	{
		if s.Code.Set {
			e.FieldStart("code")
			s.Code.Encode(e)
		}
	}
	{
		if s.Frequency.Set {
			e.FieldStart("frequency")
			s.Frequency.Encode(e)
		}
	}
	{
		if s.Exclusive.Set {
			e.FieldStart("exclusive")
			s.Exclusive.Encode(e)
		}
	}
	{
		if s.Stable.Set {
			e.FieldStart("stable")
			s.Stable.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzScoringBehavior = [4]string{
	0: "code",
	1: "frequency",
	2: "exclusive",
	3: "stable",
}

// Decode decodes SzScoringBehavior from json.
func (s *SzScoringBehavior) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzScoringBehavior to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			if err := func() error {
				s.Code.Reset()
				if err := s.Code.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "frequency":
			if err := func() error {
				s.Frequency.Reset()
				if err := s.Frequency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"frequency\"")
			}
		case "exclusive":
			if err := func() error {
				s.Exclusive.Reset()
				if err := s.Exclusive.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclusive\"")
			}
		case "stable":
			if err := func() error {
				s.Stable.Reset()
				if err := s.Stable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stable\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzScoringBehavior")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzScoringBehavior) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzScoringBehavior) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzScoringBucket as json.
func (s SzScoringBucket) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SzScoringBucket from json.
func (s *SzScoringBucket) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzScoringBucket to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SzScoringBucket(v) {
	case SzScoringBucketNOTSCORED:
		*s = SzScoringBucketNOTSCORED
	case SzScoringBucketSAME:
		*s = SzScoringBucketSAME
	case SzScoringBucketCLOSE:
		*s = SzScoringBucketCLOSE
	case SzScoringBucketLIKELY:
		*s = SzScoringBucketLIKELY
	case SzScoringBucketPLAUSIBLE:
		*s = SzScoringBucketPLAUSIBLE
	case SzScoringBucketUNLIKELY:
		*s = SzScoringBucketUNLIKELY
	case SzScoringBucketNOCHANCE:
		*s = SzScoringBucketNOCHANCE
	default:
		*s = SzScoringBucket(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SzScoringBucket) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzScoringBucket) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzScoringFrequency as json.
func (s SzScoringFrequency) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SzScoringFrequency from json.
func (s *SzScoringFrequency) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzScoringFrequency to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SzScoringFrequency(v) {
	case SzScoringFrequencyALWAYSONE:
		*s = SzScoringFrequencyALWAYSONE
	case SzScoringFrequencyONE:
		*s = SzScoringFrequencyONE
	case SzScoringFrequencyFEW:
		*s = SzScoringFrequencyFEW
	case SzScoringFrequencyMANY:
		*s = SzScoringFrequencyMANY
	case SzScoringFrequencyVERYMANY:
		*s = SzScoringFrequencyVERYMANY
	case SzScoringFrequencyNAME:
		*s = SzScoringFrequencyNAME
	default:
		*s = SzScoringFrequency(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SzScoringFrequency) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzScoringFrequency) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzSearchFeatureScore) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzSearchFeatureScore) encodeFields(e *jx.Encoder) {
	{
		if s.FeatureType.Set {
			e.FieldStart("featureType")
			s.FeatureType.Encode(e)
		}
	}
	{
		if s.InboundFeature.Set {
			e.FieldStart("inboundFeature")
			s.InboundFeature.Encode(e)
		}
	}
	{
		if s.CandidateFeature.Set {
			e.FieldStart("candidateFeature")
			s.CandidateFeature.Encode(e)
		}
	}
	{
		if s.Score.Set {
			e.FieldStart("score")
			s.Score.Encode(e)
		}
	}
	{
		if s.NameScoringDetails.Set {
			e.FieldStart("nameScoringDetails")
			s.NameScoringDetails.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzSearchFeatureScore = [5]string{
	0: "featureType",
	1: "inboundFeature",
	2: "candidateFeature",
	3: "score",
	4: "nameScoringDetails",
}

// Decode decodes SzSearchFeatureScore from json.
func (s *SzSearchFeatureScore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzSearchFeatureScore to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "featureType":
			if err := func() error {
				s.FeatureType.Reset()
				if err := s.FeatureType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"featureType\"")
			}
		case "inboundFeature":
			if err := func() error {
				s.InboundFeature.Reset()
				if err := s.InboundFeature.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inboundFeature\"")
			}
		case "candidateFeature":
			if err := func() error {
				s.CandidateFeature.Reset()
				if err := s.CandidateFeature.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"candidateFeature\"")
			}
		case "score":
			if err := func() error {
				s.Score.Reset()
				if err := s.Score.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		case "nameScoringDetails":
			if err := func() error {
				s.NameScoringDetails.Reset()
				if err := s.NameScoringDetails.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nameScoringDetails\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzSearchFeatureScore")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzSearchFeatureScore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzSearchFeatureScore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzServerInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzServerInfo) encodeFields(e *jx.Encoder) {
	{
		if s.Concurrency.Set {
			e.FieldStart("concurrency")
			s.Concurrency.Encode(e)
		}
	}
	{
		if s.ActiveConfigId.Set {
			e.FieldStart("activeConfigId")
			s.ActiveConfigId.Encode(e)
		}
	}
	{
		if s.DynamicConfig.Set {
			e.FieldStart("dynamicConfig")
			s.DynamicConfig.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.FieldStart("readOnly")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.AdminEnabled.Set {
			e.FieldStart("adminEnabled")
			s.AdminEnabled.Encode(e)
		}
	}
	{
		if s.WebSocketsMessageMaxSize.Set {
			e.FieldStart("webSocketsMessageMaxSize")
			s.WebSocketsMessageMaxSize.Encode(e)
		}
	}
	{
		if s.InfoQueueConfigured.Set {
			e.FieldStart("infoQueueConfigured")
			s.InfoQueueConfigured.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzServerInfo = [7]string{
	0: "concurrency",
	1: "activeConfigId",
	2: "dynamicConfig",
	3: "readOnly",
	4: "adminEnabled",
	5: "webSocketsMessageMaxSize",
	6: "infoQueueConfigured",
}

// Decode decodes SzServerInfo from json.
func (s *SzServerInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzServerInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "concurrency":
			if err := func() error {
				s.Concurrency.Reset()
				if err := s.Concurrency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"concurrency\"")
			}
		case "activeConfigId":
			if err := func() error {
				s.ActiveConfigId.Reset()
				if err := s.ActiveConfigId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeConfigId\"")
			}
		case "dynamicConfig":
			if err := func() error {
				s.DynamicConfig.Reset()
				if err := s.DynamicConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dynamicConfig\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "adminEnabled":
			if err := func() error {
				s.AdminEnabled.Reset()
				if err := s.AdminEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"adminEnabled\"")
			}
		case "webSocketsMessageMaxSize":
			if err := func() error {
				s.WebSocketsMessageMaxSize.Reset()
				if err := s.WebSocketsMessageMaxSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webSocketsMessageMaxSize\"")
			}
		case "infoQueueConfigured":
			if err := func() error {
				s.InfoQueueConfigured.Reset()
				if err := s.InfoQueueConfigured.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"infoQueueConfigured\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzServerInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzServerInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzServerInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzServerInfoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzServerInfoResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
	{
		if s.Links.Set {
			e.FieldStart("links")
			s.Links.Encode(e)
		}
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzServerInfoResponse = [3]string{
	0: "meta",
	1: "links",
	2: "data",
}

// Decode decodes SzServerInfoResponse from json.
func (s *SzServerInfoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzServerInfoResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		case "links":
			if err := func() error {
				s.Links.Reset()
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzServerInfoResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzServerInfoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzServerInfoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzVersionInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzVersionInfo) encodeFields(e *jx.Encoder) {
	{
		if s.ApiServerVersion.Set {
			e.FieldStart("apiServerVersion")
			s.ApiServerVersion.Encode(e)
		}
	}
	{
		if s.RestApiVersion.Set {
			e.FieldStart("restApiVersion")
			s.RestApiVersion.Encode(e)
		}
	}
	{
		if s.NativeApiVersion.Set {
			e.FieldStart("nativeApiVersion")
			s.NativeApiVersion.Encode(e)
		}
	}
	{
		if s.NativeApiBuildVersion.Set {
			e.FieldStart("nativeApiBuildVersion")
			s.NativeApiBuildVersion.Encode(e)
		}
	}
	{
		if s.NativeApiBuildNumber.Set {
			e.FieldStart("nativeApiBuildNumber")
			s.NativeApiBuildNumber.Encode(e)
		}
	}
	{
		if s.NativeApiBuildDate.Set {
			e.FieldStart("nativeApiBuildDate")
			s.NativeApiBuildDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ConfigCompatibilityVersion.Set {
			e.FieldStart("configCompatibilityVersion")
			s.ConfigCompatibilityVersion.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzVersionInfo = [7]string{
	0: "apiServerVersion",
	1: "restApiVersion",
	2: "nativeApiVersion",
	3: "nativeApiBuildVersion",
	4: "nativeApiBuildNumber",
	5: "nativeApiBuildDate",
	6: "configCompatibilityVersion",
}

// Decode decodes SzVersionInfo from json.
func (s *SzVersionInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzVersionInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiServerVersion":
			if err := func() error {
				s.ApiServerVersion.Reset()
				if err := s.ApiServerVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiServerVersion\"")
			}
		case "restApiVersion":
			if err := func() error {
				s.RestApiVersion.Reset()
				if err := s.RestApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"restApiVersion\"")
			}
		case "nativeApiVersion":
			if err := func() error {
				s.NativeApiVersion.Reset()
				if err := s.NativeApiVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nativeApiVersion\"")
			}
		case "nativeApiBuildVersion":
			if err := func() error {
				s.NativeApiBuildVersion.Reset()
				if err := s.NativeApiBuildVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nativeApiBuildVersion\"")
			}
		case "nativeApiBuildNumber":
			if err := func() error {
				s.NativeApiBuildNumber.Reset()
				if err := s.NativeApiBuildNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nativeApiBuildNumber\"")
			}
		case "nativeApiBuildDate":
			if err := func() error {
				s.NativeApiBuildDate.Reset()
				if err := s.NativeApiBuildDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nativeApiBuildDate\"")
			}
		case "configCompatibilityVersion":
			if err := func() error {
				s.ConfigCompatibilityVersion.Reset()
				if err := s.ConfigCompatibilityVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configCompatibilityVersion\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzVersionInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzVersionInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzVersionInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzVersionResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzVersionResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
	{
		if s.Links.Set {
			e.FieldStart("links")
			s.Links.Encode(e)
		}
	}
	{
		if s.RawData.Set {
			e.FieldStart("rawData")
			s.RawData.Encode(e)
		}
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzVersionResponse = [4]string{
	0: "meta",
	1: "links",
	2: "rawData",
	3: "data",
}

// Decode decodes SzVersionResponse from json.
func (s *SzVersionResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzVersionResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		case "links":
			if err := func() error {
				s.Links.Reset()
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		case "rawData":
			if err := func() error {
				s.RawData.Reset()
				if err := s.RawData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawData\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzVersionResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzVersionResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzVersionResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SzVersionResponseRawData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SzVersionResponseRawData) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SzVersionResponseRawData from json.
func (s *SzVersionResponseRawData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzVersionResponseRawData to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzVersionResponseRawData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SzVersionResponseRawData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzVersionResponseRawData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzVirtualEntity) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzVirtualEntity) encodeFields(e *jx.Encoder) {
	{
		if s.VirtualEntityId.Set {
			e.FieldStart("virtualEntityId")
			s.VirtualEntityId.Encode(e)
		}
	}
	{
		if s.Singleton.Set {
			e.FieldStart("singleton")
			s.Singleton.Encode(e)
		}
	}
	{
		if s.Records != nil {
			e.FieldStart("records")
			e.ArrStart()
			for _, elem := range s.Records {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSzVirtualEntity = [3]string{
	0: "virtualEntityId",
	1: "singleton",
	2: "records",
}

// Decode decodes SzVirtualEntity from json.
func (s *SzVirtualEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzVirtualEntity to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "virtualEntityId":
			if err := func() error {
				s.VirtualEntityId.Reset()
				if err := s.VirtualEntityId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"virtualEntityId\"")
			}
		case "singleton":
			if err := func() error {
				s.Singleton.Reset()
				if err := s.Singleton.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"singleton\"")
			}
		case "records":
			if err := func() error {
				s.Records = make([]SzVirtualEntityRecord, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SzVirtualEntityRecord
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Records = append(s.Records, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"records\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzVirtualEntity")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzVirtualEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzVirtualEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzVirtualEntityData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzVirtualEntityData) encodeFields(e *jx.Encoder) {
	{
		if s.ResolvedEntity.Set {
			e.FieldStart("resolvedEntity")
			s.ResolvedEntity.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzVirtualEntityData = [1]string{
	0: "resolvedEntity",
}

// Decode decodes SzVirtualEntityData from json.
func (s *SzVirtualEntityData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzVirtualEntityData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resolvedEntity":
			if err := func() error {
				s.ResolvedEntity.Reset()
				if err := s.ResolvedEntity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resolvedEntity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzVirtualEntityData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzVirtualEntityData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzVirtualEntityData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzVirtualEntityRecord) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzVirtualEntityRecord) encodeFields(e *jx.Encoder) {
	{
		if s.DataSource.Set {
			e.FieldStart("dataSource")
			s.DataSource.Encode(e)
		}
	}
	{
		if s.RecordId.Set {
			e.FieldStart("recordId")
			s.RecordId.Encode(e)
		}
	}
	{
		if s.InternalId.Set {
			e.FieldStart("internalId")
			s.InternalId.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzVirtualEntityRecord = [3]string{
	0: "dataSource",
	1: "recordId",
	2: "internalId",
}

// Decode decodes SzVirtualEntityRecord from json.
func (s *SzVirtualEntityRecord) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzVirtualEntityRecord to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dataSource":
			if err := func() error {
				s.DataSource.Reset()
				if err := s.DataSource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataSource\"")
			}
		case "recordId":
			if err := func() error {
				s.RecordId.Reset()
				if err := s.RecordId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recordId\"")
			}
		case "internalId":
			if err := func() error {
				s.InternalId.Reset()
				if err := s.InternalId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"internalId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzVirtualEntityRecord")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzVirtualEntityRecord) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzVirtualEntityRecord) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzVirtualEntityResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzVirtualEntityResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
	{
		if s.Links.Set {
			e.FieldStart("links")
			s.Links.Encode(e)
		}
	}
	{
		if s.RawData.Set {
			e.FieldStart("rawData")
			s.RawData.Encode(e)
		}
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzVirtualEntityResponse = [4]string{
	0: "meta",
	1: "links",
	2: "rawData",
	3: "data",
}

// Decode decodes SzVirtualEntityResponse from json.
func (s *SzVirtualEntityResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzVirtualEntityResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		case "links":
			if err := func() error {
				s.Links.Reset()
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		case "rawData":
			if err := func() error {
				s.RawData.Reset()
				if err := s.RawData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawData\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzVirtualEntityResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzVirtualEntityResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzVirtualEntityResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SzVirtualEntityResponseRawData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SzVirtualEntityResponseRawData) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SzVirtualEntityResponseRawData from json.
func (s *SzVirtualEntityResponseRawData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzVirtualEntityResponseRawData to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzVirtualEntityResponseRawData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SzVirtualEntityResponseRawData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzVirtualEntityResponseRawData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzWhyEntitiesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzWhyEntitiesResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
	{
		if s.Links.Set {
			e.FieldStart("links")
			s.Links.Encode(e)
		}
	}
	{
		if s.RawData.Set {
			e.FieldStart("rawData")
			s.RawData.Encode(e)
		}
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzWhyEntitiesResponse = [4]string{
	0: "meta",
	1: "links",
	2: "rawData",
	3: "data",
}

// Decode decodes SzWhyEntitiesResponse from json.
func (s *SzWhyEntitiesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzWhyEntitiesResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		case "links":
			if err := func() error {
				s.Links.Reset()
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		case "rawData":
			if err := func() error {
				s.RawData.Reset()
				if err := s.RawData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawData\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzWhyEntitiesResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzWhyEntitiesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzWhyEntitiesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzWhyEntitiesResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzWhyEntitiesResponseData) encodeFields(e *jx.Encoder) {
	{
		if s.WhyResult.Set {
			e.FieldStart("whyResult")
			s.WhyResult.Encode(e)
		}
	}
	{
		if s.Entities != nil {
			e.FieldStart("entities")
			e.ArrStart()
			for _, elem := range s.Entities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSzWhyEntitiesResponseData = [2]string{
	0: "whyResult",
	1: "entities",
}

// Decode decodes SzWhyEntitiesResponseData from json.
func (s *SzWhyEntitiesResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzWhyEntitiesResponseData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "whyResult":
			if err := func() error {
				s.WhyResult.Reset()
				if err := s.WhyResult.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"whyResult\"")
			}
		case "entities":
			if err := func() error {
				s.Entities = make([]SzEntityData, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SzEntityData
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Entities = append(s.Entities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entities\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzWhyEntitiesResponseData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzWhyEntitiesResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzWhyEntitiesResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SzWhyEntitiesResponseRawData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SzWhyEntitiesResponseRawData) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SzWhyEntitiesResponseRawData from json.
func (s *SzWhyEntitiesResponseRawData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzWhyEntitiesResponseRawData to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzWhyEntitiesResponseRawData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SzWhyEntitiesResponseRawData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzWhyEntitiesResponseRawData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzWhyEntitiesResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzWhyEntitiesResult) encodeFields(e *jx.Encoder) {
	{
		if s.EntityId1.Set {
			e.FieldStart("entityId1")
			s.EntityId1.Encode(e)
		}
	}
	{
		if s.EntityId2.Set {
			e.FieldStart("entityId2")
			s.EntityId2.Encode(e)
		}
	}
	{
		if s.MatchInfo.Set {
			e.FieldStart("matchInfo")
			s.MatchInfo.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzWhyEntitiesResult = [3]string{
	0: "entityId1",
	1: "entityId2",
	2: "matchInfo",
}

// Decode decodes SzWhyEntitiesResult from json.
func (s *SzWhyEntitiesResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzWhyEntitiesResult to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "entityId1":
			if err := func() error {
				s.EntityId1.Reset()
				if err := s.EntityId1.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entityId1\"")
			}
		case "entityId2":
			if err := func() error {
				s.EntityId2.Reset()
				if err := s.EntityId2.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entityId2\"")
			}
		case "matchInfo":
			if err := func() error {
				s.MatchInfo.Reset()
				if err := s.MatchInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchInfo\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzWhyEntitiesResult")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzWhyEntitiesResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzWhyEntitiesResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzWhyEntityResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzWhyEntityResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
	{
		if s.Links.Set {
			e.FieldStart("links")
			s.Links.Encode(e)
		}
	}
	{
		if s.RawData.Set {
			e.FieldStart("rawData")
			s.RawData.Encode(e)
		}
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzWhyEntityResponse = [4]string{
	0: "meta",
	1: "links",
	2: "rawData",
	3: "data",
}

// Decode decodes SzWhyEntityResponse from json.
func (s *SzWhyEntityResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzWhyEntityResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		case "links":
			if err := func() error {
				s.Links.Reset()
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		case "rawData":
			if err := func() error {
				s.RawData.Reset()
				if err := s.RawData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawData\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzWhyEntityResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzWhyEntityResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzWhyEntityResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzWhyEntityResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzWhyEntityResponseData) encodeFields(e *jx.Encoder) {
	{
		if s.WhyResults != nil {
			e.FieldStart("whyResults")
			e.ArrStart()
			for _, elem := range s.WhyResults {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Entities != nil {
			e.FieldStart("entities")
			e.ArrStart()
			for _, elem := range s.Entities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSzWhyEntityResponseData = [2]string{
	0: "whyResults",
	1: "entities",
}

// Decode decodes SzWhyEntityResponseData from json.
func (s *SzWhyEntityResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzWhyEntityResponseData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "whyResults":
			if err := func() error {
				s.WhyResults = make([]SzWhyEntityResult, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SzWhyEntityResult
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.WhyResults = append(s.WhyResults, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"whyResults\"")
			}
		case "entities":
			if err := func() error {
				s.Entities = make([]SzEntityData, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SzEntityData
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Entities = append(s.Entities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entities\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzWhyEntityResponseData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzWhyEntityResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzWhyEntityResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SzWhyEntityResponseRawData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SzWhyEntityResponseRawData) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SzWhyEntityResponseRawData from json.
func (s *SzWhyEntityResponseRawData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzWhyEntityResponseRawData to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzWhyEntityResponseRawData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SzWhyEntityResponseRawData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzWhyEntityResponseRawData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzWhyEntityResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzWhyEntityResult) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("perspective")
		s.Perspective.Encode(e)
	}
	{
		if s.MatchInfo.Set {
			e.FieldStart("matchInfo")
			s.MatchInfo.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzWhyEntityResult = [2]string{
	0: "perspective",
	1: "matchInfo",
}

// Decode decodes SzWhyEntityResult from json.
func (s *SzWhyEntityResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzWhyEntityResult to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "perspective":
			if err := func() error {
				if err := s.Perspective.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"perspective\"")
			}
		case "matchInfo":
			if err := func() error {
				s.MatchInfo.Reset()
				if err := s.MatchInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchInfo\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzWhyEntityResult")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzWhyEntityResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzWhyEntityResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzWhyMatchInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzWhyMatchInfo) encodeFields(e *jx.Encoder) {
	{
		if s.WhyKey.Set {
			e.FieldStart("whyKey")
			s.WhyKey.Encode(e)
		}
	}
	{
		if s.MatchLevel.Set {
			e.FieldStart("matchLevel")
			s.MatchLevel.Encode(e)
		}
	}
	{
		if s.ResolutionRule.Set {
			e.FieldStart("resolutionRule")
			s.ResolutionRule.Encode(e)
		}
	}
	{
		if s.CandidateKeys.Set {
			e.FieldStart("candidateKeys")
			s.CandidateKeys.Encode(e)
		}
	}
	{
		if s.FeatureScores.Set {
			e.FieldStart("featureScores")
			s.FeatureScores.Encode(e)
		}
	}
	{
		if s.DisclosedRelations.Set {
			e.FieldStart("disclosedRelations")
			s.DisclosedRelations.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzWhyMatchInfo = [6]string{
	0: "whyKey",
	1: "matchLevel",
	2: "resolutionRule",
	3: "candidateKeys",
	4: "featureScores",
	5: "disclosedRelations",
}

// Decode decodes SzWhyMatchInfo from json.
func (s *SzWhyMatchInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzWhyMatchInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "whyKey":
			if err := func() error {
				s.WhyKey.Reset()
				if err := s.WhyKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"whyKey\"")
			}
		case "matchLevel":
			if err := func() error {
				s.MatchLevel.Reset()
				if err := s.MatchLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchLevel\"")
			}
		case "resolutionRule":
			if err := func() error {
				s.ResolutionRule.Reset()
				if err := s.ResolutionRule.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resolutionRule\"")
			}
		case "candidateKeys":
			if err := func() error {
				s.CandidateKeys.Reset()
				if err := s.CandidateKeys.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"candidateKeys\"")
			}
		case "featureScores":
			if err := func() error {
				s.FeatureScores.Reset()
				if err := s.FeatureScores.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"featureScores\"")
			}
		case "disclosedRelations":
			if err := func() error {
				s.DisclosedRelations.Reset()
				if err := s.DisclosedRelations.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disclosedRelations\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzWhyMatchInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzWhyMatchInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzWhyMatchInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SzWhyMatchInfoCandidateKeys) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SzWhyMatchInfoCandidateKeys) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.ArrStart()
		for _, elem := range elem {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

// Decode decodes SzWhyMatchInfoCandidateKeys from json.
func (s *SzWhyMatchInfoCandidateKeys) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzWhyMatchInfoCandidateKeys to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem []SzCandidateKey
		if err := func() error {
			elem = make([]SzCandidateKey, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elemElem SzCandidateKey
				if err := elemElem.Decode(d); err != nil {
					return err
				}
				elem = append(elem, elemElem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzWhyMatchInfoCandidateKeys")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SzWhyMatchInfoCandidateKeys) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzWhyMatchInfoCandidateKeys) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SzWhyMatchInfoFeatureScores) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SzWhyMatchInfoFeatureScores) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.ArrStart()
		for _, elem := range elem {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

// Decode decodes SzWhyMatchInfoFeatureScores from json.
func (s *SzWhyMatchInfoFeatureScores) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzWhyMatchInfoFeatureScores to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem []SzFeatureScore
		if err := func() error {
			elem = make([]SzFeatureScore, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elemElem SzFeatureScore
				if err := elemElem.Decode(d); err != nil {
					return err
				}
				elem = append(elem, elemElem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzWhyMatchInfoFeatureScores")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SzWhyMatchInfoFeatureScores) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzWhyMatchInfoFeatureScores) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SzWhyPerspective as json.
func (s SzWhyPerspective) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes SzWhyPerspective from json.
func (s *SzWhyPerspective) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzWhyPerspective to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SzWhyPerspective(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SzWhyPerspective) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzWhyPerspective) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzWhyRecordsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzWhyRecordsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
	{
		if s.Links.Set {
			e.FieldStart("links")
			s.Links.Encode(e)
		}
	}
	{
		if s.RawData.Set {
			e.FieldStart("rawData")
			s.RawData.Encode(e)
		}
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzWhyRecordsResponse = [4]string{
	0: "meta",
	1: "links",
	2: "rawData",
	3: "data",
}

// Decode decodes SzWhyRecordsResponse from json.
func (s *SzWhyRecordsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzWhyRecordsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		case "links":
			if err := func() error {
				s.Links.Reset()
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		case "rawData":
			if err := func() error {
				s.RawData.Reset()
				if err := s.RawData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawData\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzWhyRecordsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzWhyRecordsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzWhyRecordsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzWhyRecordsResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzWhyRecordsResponseData) encodeFields(e *jx.Encoder) {
	{
		if s.WhyResult.Set {
			e.FieldStart("whyResult")
			s.WhyResult.Encode(e)
		}
	}
	{
		if s.Entities != nil {
			e.FieldStart("entities")
			e.ArrStart()
			for _, elem := range s.Entities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSzWhyRecordsResponseData = [2]string{
	0: "whyResult",
	1: "entities",
}

// Decode decodes SzWhyRecordsResponseData from json.
func (s *SzWhyRecordsResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzWhyRecordsResponseData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "whyResult":
			if err := func() error {
				s.WhyResult.Reset()
				if err := s.WhyResult.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"whyResult\"")
			}
		case "entities":
			if err := func() error {
				s.Entities = make([]SzEntityData, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SzEntityData
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Entities = append(s.Entities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entities\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzWhyRecordsResponseData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzWhyRecordsResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzWhyRecordsResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SzWhyRecordsResponseRawData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SzWhyRecordsResponseRawData) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SzWhyRecordsResponseRawData from json.
func (s *SzWhyRecordsResponseRawData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzWhyRecordsResponseRawData to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzWhyRecordsResponseRawData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SzWhyRecordsResponseRawData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzWhyRecordsResponseRawData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SzWhyRecordsResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SzWhyRecordsResult) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("perspective1")
		s.Perspective1.Encode(e)
	}
	{
		e.FieldStart("perspective2")
		s.Perspective2.Encode(e)
	}
	{
		if s.MatchInfo.Set {
			e.FieldStart("matchInfo")
			s.MatchInfo.Encode(e)
		}
	}
}

var jsonFieldsNameOfSzWhyRecordsResult = [3]string{
	0: "perspective1",
	1: "perspective2",
	2: "matchInfo",
}

// Decode decodes SzWhyRecordsResult from json.
func (s *SzWhyRecordsResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SzWhyRecordsResult to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "perspective1":
			if err := func() error {
				if err := s.Perspective1.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"perspective1\"")
			}
		case "perspective2":
			if err := func() error {
				if err := s.Perspective2.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"perspective2\"")
			}
		case "matchInfo":
			if err := func() error {
				s.MatchInfo.Reset()
				if err := s.MatchInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchInfo\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SzWhyRecordsResult")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SzWhyRecordsResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SzWhyRecordsResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WhyEntitiesApplicationJSONInternalServerError as json.
func (s *WhyEntitiesApplicationJSONInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes WhyEntitiesApplicationJSONInternalServerError from json.
func (s *WhyEntitiesApplicationJSONInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WhyEntitiesApplicationJSONInternalServerError to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = WhyEntitiesApplicationJSONInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WhyEntitiesApplicationJSONInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WhyEntitiesApplicationJSONInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WhyEntitiesApplicationJSONNotFound as json.
func (s *WhyEntitiesApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes WhyEntitiesApplicationJSONNotFound from json.
func (s *WhyEntitiesApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WhyEntitiesApplicationJSONNotFound to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = WhyEntitiesApplicationJSONNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WhyEntitiesApplicationJSONNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WhyEntitiesApplicationJSONNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WhyEntityByEntityIDApplicationJSONInternalServerError as json.
func (s *WhyEntityByEntityIDApplicationJSONInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes WhyEntityByEntityIDApplicationJSONInternalServerError from json.
func (s *WhyEntityByEntityIDApplicationJSONInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WhyEntityByEntityIDApplicationJSONInternalServerError to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = WhyEntityByEntityIDApplicationJSONInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WhyEntityByEntityIDApplicationJSONInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WhyEntityByEntityIDApplicationJSONInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WhyEntityByEntityIDApplicationJSONNotFound as json.
func (s *WhyEntityByEntityIDApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes WhyEntityByEntityIDApplicationJSONNotFound from json.
func (s *WhyEntityByEntityIDApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WhyEntityByEntityIDApplicationJSONNotFound to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = WhyEntityByEntityIDApplicationJSONNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WhyEntityByEntityIDApplicationJSONNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WhyEntityByEntityIDApplicationJSONNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WhyEntityByRecordIDApplicationJSONInternalServerError as json.
func (s *WhyEntityByRecordIDApplicationJSONInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes WhyEntityByRecordIDApplicationJSONInternalServerError from json.
func (s *WhyEntityByRecordIDApplicationJSONInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WhyEntityByRecordIDApplicationJSONInternalServerError to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = WhyEntityByRecordIDApplicationJSONInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WhyEntityByRecordIDApplicationJSONInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WhyEntityByRecordIDApplicationJSONInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WhyEntityByRecordIDApplicationJSONNotFound as json.
func (s *WhyEntityByRecordIDApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes WhyEntityByRecordIDApplicationJSONNotFound from json.
func (s *WhyEntityByRecordIDApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WhyEntityByRecordIDApplicationJSONNotFound to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = WhyEntityByRecordIDApplicationJSONNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WhyEntityByRecordIDApplicationJSONNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WhyEntityByRecordIDApplicationJSONNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WhyRecordsApplicationJSONInternalServerError as json.
func (s *WhyRecordsApplicationJSONInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes WhyRecordsApplicationJSONInternalServerError from json.
func (s *WhyRecordsApplicationJSONInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WhyRecordsApplicationJSONInternalServerError to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = WhyRecordsApplicationJSONInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WhyRecordsApplicationJSONInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WhyRecordsApplicationJSONInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WhyRecordsApplicationJSONNotFound as json.
func (s *WhyRecordsApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*SzErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes WhyRecordsApplicationJSONNotFound from json.
func (s *WhyRecordsApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WhyRecordsApplicationJSONNotFound to nil")
	}
	var unwrapped SzErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = WhyRecordsApplicationJSONNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WhyRecordsApplicationJSONNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WhyRecordsApplicationJSONNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
