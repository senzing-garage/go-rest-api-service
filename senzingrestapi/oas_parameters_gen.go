// Code generated by ogen, DO NOT EDIT.

package senzingrestapi

import (
	"fmt"
	"net/http"
	"net/url"

	"github.com/go-faster/errors"

	"github.com/ogen-go/ogen/conv"
	"github.com/ogen-go/ogen/middleware"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
)

// AddDataSourcesParams is parameters of addDataSources operation.
type AddDataSourcesParams struct {
	// The multi-valued query parameter where each value is a data source
	// code identifying data sources to be created.  If a data source code
	// is specified only via this parameter then the data source ID is
	// generated by the API server -- which is usually fine.  If you want
	// to specify the data source ID, then use the request body instead.
	DataSource []string
	// Whether or not to include the raw JSON response from the underlying native API.  This raw response
	// may include additional details but lack some of the abstraction the standard response provides.
	// If true, then the 'rawData' field in the response will be a non-null value and contain the
	// additional details.
	WithRaw OptBool
}

func unpackAddDataSourcesParams(packed middleware.Parameters) (params AddDataSourcesParams) {
	{
		key := middleware.ParameterKey{
			Name: "dataSource",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.DataSource = v.([]string)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withRaw",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithRaw = v.(OptBool)
		}
	}
	return params
}

func decodeAddDataSourcesParams(args [0]string, argsEscaped bool, r *http.Request) (params AddDataSourcesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: dataSource.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "dataSource",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotDataSourceVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotDataSourceVal = c
						return nil
					}(); err != nil {
						return err
					}
					params.DataSource = append(params.DataSource, paramsDotDataSourceVal)
					return nil
				})
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "dataSource",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withRaw.
	{
		val := bool(false)
		params.WithRaw.SetTo(val)
	}
	// Decode query: withRaw.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithRawVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithRawVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithRaw.SetTo(paramsDotWithRawVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withRaw",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// AddRecordParams is parameters of addRecord operation.
type AddRecordParams struct {
	// The data source code identifying the data source.
	DataSourceCode string
	// The identifier that uniquely identifies the requested record within a given data source.  This may
	// have been specified when the record was loaded or generated automatically.
	RecordId string
	// The optional load ID to associate with the loaded record.
	LoadId OptString
	// Set to `true` to include resolution information related to loading, and `false` to exclude it.
	// This defaults to `false`.
	WithInfo OptBool
	// Whether or not to include the raw JSON response from the underlying native API.  This raw response
	// may include additional details but lack some of the abstraction the standard response provides.
	// If true, then the 'rawData' field in the response will be a non-null value and contain the
	// additional details.
	WithRaw OptBool
}

func unpackAddRecordParams(packed middleware.Parameters) (params AddRecordParams) {
	{
		key := middleware.ParameterKey{
			Name: "dataSourceCode",
			In:   "path",
		}
		params.DataSourceCode = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "recordId",
			In:   "path",
		}
		params.RecordId = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "loadId",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.LoadId = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withInfo",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithInfo = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withRaw",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithRaw = v.(OptBool)
		}
	}
	return params
}

func decodeAddRecordParams(args [2]string, argsEscaped bool, r *http.Request) (params AddRecordParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: dataSourceCode.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "dataSourceCode",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DataSourceCode = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "dataSourceCode",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: recordId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "recordId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.RecordId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "recordId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: loadId.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "loadId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLoadIdVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLoadIdVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LoadId.SetTo(paramsDotLoadIdVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "loadId",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withInfo.
	{
		val := bool(false)
		params.WithInfo.SetTo(val)
	}
	// Decode query: withInfo.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withInfo",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithInfoVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithInfoVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithInfo.SetTo(paramsDotWithInfoVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withInfo",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withRaw.
	{
		val := bool(false)
		params.WithRaw.SetTo(val)
	}
	// Decode query: withRaw.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithRawVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithRawVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithRaw.SetTo(paramsDotWithRawVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withRaw",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// AddRecordWithReturnedRecordIdParams is parameters of addRecordWithReturnedRecordId operation.
type AddRecordWithReturnedRecordIdParams struct {
	// The data source code identifying the data source.
	DataSourceCode string
	// The optional load ID to associate with the loaded record.
	LoadId OptString
	// Set to `true` to include resolution information related to loading, and `false` to exclude it.
	// This defaults to `false`.
	WithInfo OptBool
	// Whether or not to include the raw JSON response from the underlying native API.  This raw response
	// may include additional details but lack some of the abstraction the standard response provides.
	// If true, then the 'rawData' field in the response will be a non-null value and contain the
	// additional details.
	WithRaw OptBool
}

func unpackAddRecordWithReturnedRecordIdParams(packed middleware.Parameters) (params AddRecordWithReturnedRecordIdParams) {
	{
		key := middleware.ParameterKey{
			Name: "dataSourceCode",
			In:   "path",
		}
		params.DataSourceCode = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "loadId",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.LoadId = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withInfo",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithInfo = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withRaw",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithRaw = v.(OptBool)
		}
	}
	return params
}

func decodeAddRecordWithReturnedRecordIdParams(args [1]string, argsEscaped bool, r *http.Request) (params AddRecordWithReturnedRecordIdParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: dataSourceCode.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "dataSourceCode",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DataSourceCode = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "dataSourceCode",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: loadId.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "loadId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLoadIdVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLoadIdVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LoadId.SetTo(paramsDotLoadIdVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "loadId",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withInfo.
	{
		val := bool(false)
		params.WithInfo.SetTo(val)
	}
	// Decode query: withInfo.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withInfo",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithInfoVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithInfoVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithInfo.SetTo(paramsDotWithInfoVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withInfo",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withRaw.
	{
		val := bool(false)
		params.WithRaw.SetTo(val)
	}
	// Decode query: withRaw.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithRawVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithRawVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithRaw.SetTo(paramsDotWithRawVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withRaw",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// AnalyzeBulkRecordsParams is parameters of analyzeBulkRecords operation.
type AnalyzeBulkRecordsParams struct {
	// The suggested maximum time between SSE `progress` events specified in milliseconds.  If not
	// specified then the default of `3000` milliseconds (i.e.: 3 seconds) is used.  This parameter is
	// NOT used if the operation is not producing an SSE response (i.e.: `text/event-stream` media type
	// was not requested via the `Accept` header).
	ProgressPeriod OptInt64
	// The number of seconds to wait for an additional Web Sockets message before assuming end-of-file
	// (EOF) when using this end-point via Web Sockets protocol.  If this number of seconds elapses with
	// no additional incoming data then the server assumes that there are no more file chunks forthcoming.
	//   If not specified then the default of `3` seconds is used. This parameter is NOT used if the
	// operation is not invoked via the Web Sockets (`ws://`) protocol.  **NOTE**: This is specified in
	// seconds, **not** milliseconds.
	EofSendTimeout OptInt32
}

func unpackAnalyzeBulkRecordsParams(packed middleware.Parameters) (params AnalyzeBulkRecordsParams) {
	{
		key := middleware.ParameterKey{
			Name: "progressPeriod",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ProgressPeriod = v.(OptInt64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "eofSendTimeout",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.EofSendTimeout = v.(OptInt32)
		}
	}
	return params
}

func decodeAnalyzeBulkRecordsParams(args [0]string, argsEscaped bool, r *http.Request) (params AnalyzeBulkRecordsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: progressPeriod.
	{
		val := int64(3000)
		params.ProgressPeriod.SetTo(val)
	}
	// Decode query: progressPeriod.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "progressPeriod",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotProgressPeriodVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotProgressPeriodVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ProgressPeriod.SetTo(paramsDotProgressPeriodVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "progressPeriod",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: eofSendTimeout.
	{
		val := int32(3)
		params.EofSendTimeout.SetTo(val)
	}
	// Decode query: eofSendTimeout.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "eofSendTimeout",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEofSendTimeoutVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotEofSendTimeoutVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.EofSendTimeout.SetTo(paramsDotEofSendTimeoutVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "eofSendTimeout",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteRecordParams is parameters of deleteRecord operation.
type DeleteRecordParams struct {
	// The data source code identifying the data source.
	DataSourceCode string
	// The identifier that uniquely identifies the requested record within a given data source.  This may
	// have been specified when the record was loaded or generated automatically.
	RecordId string
	// The optional load ID to associate with the loaded record.
	LoadId OptString
	// Set to `true` to include resolution information related to loading, and `false` to exclude it.
	// This defaults to `false`.
	WithInfo OptBool
	// Whether or not to include the raw JSON response from the underlying native API.  This raw response
	// may include additional details but lack some of the abstraction the standard response provides.
	// If true, then the 'rawData' field in the response will be a non-null value and contain the
	// additional details.
	WithRaw OptBool
}

func unpackDeleteRecordParams(packed middleware.Parameters) (params DeleteRecordParams) {
	{
		key := middleware.ParameterKey{
			Name: "dataSourceCode",
			In:   "path",
		}
		params.DataSourceCode = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "recordId",
			In:   "path",
		}
		params.RecordId = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "loadId",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.LoadId = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withInfo",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithInfo = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withRaw",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithRaw = v.(OptBool)
		}
	}
	return params
}

func decodeDeleteRecordParams(args [2]string, argsEscaped bool, r *http.Request) (params DeleteRecordParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: dataSourceCode.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "dataSourceCode",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DataSourceCode = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "dataSourceCode",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: recordId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "recordId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.RecordId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "recordId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: loadId.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "loadId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLoadIdVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLoadIdVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LoadId.SetTo(paramsDotLoadIdVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "loadId",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withInfo.
	{
		val := bool(false)
		params.WithInfo.SetTo(val)
	}
	// Decode query: withInfo.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withInfo",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithInfoVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithInfoVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithInfo.SetTo(paramsDotWithInfoVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withInfo",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withRaw.
	{
		val := bool(false)
		params.WithRaw.SetTo(val)
	}
	// Decode query: withRaw.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithRawVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithRawVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithRaw.SetTo(paramsDotWithRawVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withRaw",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// FindEntityNetworkParams is parameters of findEntityNetwork operation.
type FindEntityNetworkParams struct {
	// The maximum number of degrees to look for a path between the specified entities.  If not specified,
	//  this defaults to `3`. Unlike `GET /entity-paths/` the value here may be zero (0) which allows the
	// caller to specify a list of entities and simply "build out" the network around each to a maximum
	// number of degrees and up to a maximum number of entities.
	MaxDegrees OptInt
	// The maximum number of degrees to build out around each of the specified entities regardless of
	// those entities being on the path between entities.  The number of entities built out is limited by
	// the `maxEntities` parameter.  This defaults to `1` degree if not specified.
	BuildOut OptInt
	// The maximum number of entities to build out when the `buildOut` is greater than zero (0).  This
	// defaults to `1000` if not specified.
	MaxEntities OptInt32
	// Specifies the level of detail desired for the entity data.  Details for features of entities as
	// well as the related entities of entities are controlled by `featureMode`, `withInternalFeatures`,
	// and `withFeatureStats`.  If not specified the value defaults to `VERBOSE`. Possible values are:
	// * `BARE_MINIMAL` - The entities returned will include only their
	// entity ID's.  No record information is returned
	// and if related entities are included, they too will
	// only be described by their entity ID's and will
	// **not** include any matching info.
	// * `NETWORK_MINIMAL` - Identical to `BARE_MINIMAL` except in the case
	// of related entities being included they will
	// also include related matching info.
	// * `MINIMAL` - The entities returned will include at most their
	// entity ID's as well as identifiers for their
	// constituent records (i.e.: data source code and record
	// ID for each record).  This detail level is optimized for
	// the fastest possible processing time.
	// * `BRIEF` - Builds upon `MINIMAL` to add the entity name and related
	// entity match info when related entity match info when
	// related entities are included.  This detail level aims to
	// maintain as much speed as possible while providing names
	// and relationship information for rendering a graph.
	// * `SUMMARY` - Identical to `BRIEF` except that individual record
	// identifier information is excluded, leaving only the
	// record summary (i.e.: a record count by data source
	// code).  This reduces the size of the JSON document for
	// large entities with thousands of records.  It may take
	// longer to process than `BRIEF` but less data is
	// returned as well, speeding up network transfer times.
	// * `VERBOSE` - Combines `BRIEF` and `SUMMARY` and then adds the
	// original JSON data for each record, the record-level
	// matching info, as well as formatted record data.  NOTE:
	// the record-level matching info returned via "how" and
	// "why" is often more useful than that embedded in the
	// entity.  Further, the formatted record data, while
	// readable, is not formatted according to locale (i.e.:
	// address, name and date formatting may not appear as
	// expected to a user).
	DetailLevel OptSzDetailLevel
	// The method by which feature values should be included for entities returned in the response.  The
	// possible values are:
	// * `NONE` - Do not include any feature values -- this is the fastest
	// option from a performance perspective because feature
	// values do not have to be retrieved.
	// * `REPRESENTATIVE` - Include only a single representative value per
	// "unique" value of a feature.  If there are
	// multiple values that are near duplicates then
	// only one value is included and the others are
	// suppressed.
	// * `WITH_DUPLICATES` - ** (default value) ** Group near-duplicate
	// feature values and return a representative value
	// along with its near duplicate values.
	// * `ATTRIBUTED` - Same as `WITH_DUPLICATES` but with record-level
	// references attributing each feature to the record(s)
	// that provided it for the entity along with any
	// usage type that might have been associated with the
	// feature at the record level.
	FeatureMode OptSzFeatureMode
	// Set to `true` to include resolution statistics for features.  This defaults to `false`.
	WithFeatureStats OptBool
	// Set to `true` to include "expressed" features that are derived composite keys such as name + date
	// of birth keys.  This defaults to `false`.
	WithInternalFeatures OptBool
	// Whether (or not) to force the minimum entity detail in the response which will consist of nothing
	// more than an entity ID and record identifying information (i.e.: data source code and record ID)
	// for each constituent record of an entity.  Unlike `detailLevel=MINIMAL` setting this to `true`
	// precludes the addition of feature information via other parameters.  Setting this to `true`
	// provides the fastest response to an entity query operation because no additional data needs to be
	// retrieved other than what is directly accessible.  Setting this parameter to `true` overrules
	// other parameters governing the retrieval of features or related entities.
	ForceMinimal OptBool
	// Whether or not to include the raw JSON response from the underlying native API.  This raw response
	// may include additional details but lack some of the abstraction the standard response provides.
	// If true, then the 'rawData' field in the response will be a non-null value and contain the
	// additional details.
	WithRaw OptBool
}

func unpackFindEntityNetworkParams(packed middleware.Parameters) (params FindEntityNetworkParams) {
	{
		key := middleware.ParameterKey{
			Name: "maxDegrees",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.MaxDegrees = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "buildOut",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.BuildOut = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "maxEntities",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.MaxEntities = v.(OptInt32)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "detailLevel",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.DetailLevel = v.(OptSzDetailLevel)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "featureMode",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.FeatureMode = v.(OptSzFeatureMode)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withFeatureStats",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithFeatureStats = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withInternalFeatures",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithInternalFeatures = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "forceMinimal",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ForceMinimal = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withRaw",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithRaw = v.(OptBool)
		}
	}
	return params
}

func decodeFindEntityNetworkParams(args [0]string, argsEscaped bool, r *http.Request) (params FindEntityNetworkParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: maxDegrees.
	{
		val := int(3)
		params.MaxDegrees.SetTo(val)
	}
	// Decode query: maxDegrees.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "maxDegrees",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotMaxDegreesVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotMaxDegreesVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.MaxDegrees.SetTo(paramsDotMaxDegreesVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if params.MaxDegrees.Set {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           0,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(params.MaxDegrees.Value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "maxDegrees",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: buildOut.
	{
		val := int(1)
		params.BuildOut.SetTo(val)
	}
	// Decode query: buildOut.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "buildOut",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBuildOutVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotBuildOutVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.BuildOut.SetTo(paramsDotBuildOutVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if params.BuildOut.Set {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           0,
							MaxSet:        true,
							Max:           100,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(params.BuildOut.Value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "buildOut",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: maxEntities.
	{
		val := int32(1000)
		params.MaxEntities.SetTo(val)
	}
	// Decode query: maxEntities.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "maxEntities",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotMaxEntitiesVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotMaxEntitiesVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.MaxEntities.SetTo(paramsDotMaxEntitiesVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if params.MaxEntities.Set {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           0,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(params.MaxEntities.Value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "maxEntities",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: detailLevel.
	{
		val := SzDetailLevel("VERBOSE")
		params.DetailLevel.SetTo(val)
	}
	// Decode query: detailLevel.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "detailLevel",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDetailLevelVal SzDetailLevel
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDetailLevelVal = SzDetailLevel(c)
					return nil
				}(); err != nil {
					return err
				}
				params.DetailLevel.SetTo(paramsDotDetailLevelVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if params.DetailLevel.Set {
					if err := func() error {
						if err := params.DetailLevel.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "detailLevel",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: featureMode.
	{
		val := SzFeatureMode("WITH_DUPLICATES")
		params.FeatureMode.SetTo(val)
	}
	// Decode query: featureMode.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "featureMode",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFeatureModeVal SzFeatureMode
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFeatureModeVal = SzFeatureMode(c)
					return nil
				}(); err != nil {
					return err
				}
				params.FeatureMode.SetTo(paramsDotFeatureModeVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if params.FeatureMode.Set {
					if err := func() error {
						if err := params.FeatureMode.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "featureMode",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withFeatureStats.
	{
		val := bool(false)
		params.WithFeatureStats.SetTo(val)
	}
	// Decode query: withFeatureStats.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withFeatureStats",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithFeatureStatsVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithFeatureStatsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithFeatureStats.SetTo(paramsDotWithFeatureStatsVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withFeatureStats",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withInternalFeatures.
	{
		val := bool(false)
		params.WithInternalFeatures.SetTo(val)
	}
	// Decode query: withInternalFeatures.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withInternalFeatures",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithInternalFeaturesVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithInternalFeaturesVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithInternalFeatures.SetTo(paramsDotWithInternalFeaturesVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withInternalFeatures",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: forceMinimal.
	{
		val := bool(false)
		params.ForceMinimal.SetTo(val)
	}
	// Decode query: forceMinimal.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "forceMinimal",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotForceMinimalVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotForceMinimalVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ForceMinimal.SetTo(paramsDotForceMinimalVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "forceMinimal",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withRaw.
	{
		val := bool(false)
		params.WithRaw.SetTo(val)
	}
	// Decode query: withRaw.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithRawVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithRawVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithRaw.SetTo(paramsDotWithRawVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withRaw",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// FindEntityPathParams is parameters of findEntityPath operation.
type FindEntityPathParams struct {
	// The maximum number of degrees to look for a path from the first entity to the last entity.  This
	// defaults to `3` if not specified. If specified, the value must be greater-than zero (0) since a
	// path cannot exist at zero degrees of separation.
	MaxDegrees OptInt
	// If the avoidEntities parameter is provided then this flag is used to control whether or not to
	// forbid the avoided entities rather than include them in the path as a "last resort".
	ForbidAvoided OptBool
	// The multi-valued query parameter where each value is a data source code identifying data sources
	// for which one must be included in the entities for the path.  If not provided, then the default is
	// to NOT require any specific data sources.
	S []string
	// Specifies the level of detail desired for the entity data.  Details for features of entities as
	// well as the related entities of entities are controlled by `featureMode`, `withInternalFeatures`,
	// and `withFeatureStats`.  If not specified the value defaults to `VERBOSE`. Possible values are:
	// * `BARE_MINIMAL` - The entities returned will include only their
	// entity ID's.  No record information is returned
	// and if related entities are included, they too will
	// only be described by their entity ID's and will
	// **not** include any matching info.
	// * `NETWORK_MINIMAL` - Identical to `BARE_MINIMAL` except in the case
	// of related entities being included they will
	// also include related matching info.
	// * `MINIMAL` - The entities returned will include at most their
	// entity ID's as well as identifiers for their
	// constituent records (i.e.: data source code and record
	// ID for each record).  This detail level is optimized for
	// the fastest possible processing time.
	// * `BRIEF` - Builds upon `MINIMAL` to add the entity name and related
	// entity match info when related entity match info when
	// related entities are included.  This detail level aims to
	// maintain as much speed as possible while providing names
	// and relationship information for rendering a graph.
	// * `SUMMARY` - Identical to `BRIEF` except that individual record
	// identifier information is excluded, leaving only the
	// record summary (i.e.: a record count by data source
	// code).  This reduces the size of the JSON document for
	// large entities with thousands of records.  It may take
	// longer to process than `BRIEF` but less data is
	// returned as well, speeding up network transfer times.
	// * `VERBOSE` - Combines `BRIEF` and `SUMMARY` and then adds the
	// original JSON data for each record, the record-level
	// matching info, as well as formatted record data.  NOTE:
	// the record-level matching info returned via "how" and
	// "why" is often more useful than that embedded in the
	// entity.  Further, the formatted record data, while
	// readable, is not formatted according to locale (i.e.:
	// address, name and date formatting may not appear as
	// expected to a user).
	DetailLevel OptSzDetailLevel
	// The method by which feature values should be included for entities returned in the response.  The
	// possible values are:
	// * `NONE` - Do not include any feature values -- this is the fastest
	// option from a performance perspective because feature
	// values do not have to be retrieved.
	// * `REPRESENTATIVE` - Include only a single representative value per
	// "unique" value of a feature.  If there are
	// multiple values that are near duplicates then
	// only one value is included and the others are
	// suppressed.
	// * `WITH_DUPLICATES` - ** (default value) ** Group near-duplicate
	// feature values and return a representative value
	// along with its near duplicate values.
	// * `ATTRIBUTED` - Same as `WITH_DUPLICATES` but with record-level
	// references attributing each feature to the record(s)
	// that provided it for the entity along with any
	// usage type that might have been associated with the
	// feature at the record level.
	FeatureMode OptSzFeatureMode
	// Set to `true` to include resolution statistics for features.  This defaults to `false`.
	WithFeatureStats OptBool
	// Set to `true` to include "expressed" features that are derived composite keys such as name + date
	// of birth keys.  This defaults to `false`.
	WithInternalFeatures OptBool
	// Whether (or not) to force the minimum entity detail in the response which will consist of nothing
	// more than an entity ID and record identifying information (i.e.: data source code and record ID)
	// for each constituent record of an entity.  Unlike `detailLevel=MINIMAL` setting this to `true`
	// precludes the addition of feature information via other parameters.  Setting this to `true`
	// provides the fastest response to an entity query operation because no additional data needs to be
	// retrieved other than what is directly accessible.  Setting this parameter to `true` overrules
	// other parameters governing the retrieval of features or related entities.
	ForceMinimal OptBool
	// Whether or not to include the raw JSON response from the underlying native API.  This raw response
	// may include additional details but lack some of the abstraction the standard response provides.
	// If true, then the 'rawData' field in the response will be a non-null value and contain the
	// additional details.
	WithRaw OptBool
}

func unpackFindEntityPathParams(packed middleware.Parameters) (params FindEntityPathParams) {
	{
		key := middleware.ParameterKey{
			Name: "maxDegrees",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.MaxDegrees = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "forbidAvoided",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ForbidAvoided = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "s",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.S = v.([]string)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "detailLevel",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.DetailLevel = v.(OptSzDetailLevel)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "featureMode",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.FeatureMode = v.(OptSzFeatureMode)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withFeatureStats",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithFeatureStats = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withInternalFeatures",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithInternalFeatures = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "forceMinimal",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ForceMinimal = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withRaw",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithRaw = v.(OptBool)
		}
	}
	return params
}

func decodeFindEntityPathParams(args [0]string, argsEscaped bool, r *http.Request) (params FindEntityPathParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: maxDegrees.
	{
		val := int(3)
		params.MaxDegrees.SetTo(val)
	}
	// Decode query: maxDegrees.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "maxDegrees",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotMaxDegreesVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotMaxDegreesVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.MaxDegrees.SetTo(paramsDotMaxDegreesVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if params.MaxDegrees.Set {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           1,
							MaxSet:        false,
							Max:           0,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(params.MaxDegrees.Value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "maxDegrees",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: forbidAvoided.
	{
		val := bool(false)
		params.ForbidAvoided.SetTo(val)
	}
	// Decode query: forbidAvoided.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "forbidAvoided",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotForbidAvoidedVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotForbidAvoidedVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ForbidAvoided.SetTo(paramsDotForbidAvoidedVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "forbidAvoided",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: s.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "s",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotSVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotSVal = c
						return nil
					}(); err != nil {
						return err
					}
					params.S = append(params.S, paramsDotSVal)
					return nil
				})
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "s",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: detailLevel.
	{
		val := SzDetailLevel("VERBOSE")
		params.DetailLevel.SetTo(val)
	}
	// Decode query: detailLevel.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "detailLevel",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDetailLevelVal SzDetailLevel
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDetailLevelVal = SzDetailLevel(c)
					return nil
				}(); err != nil {
					return err
				}
				params.DetailLevel.SetTo(paramsDotDetailLevelVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if params.DetailLevel.Set {
					if err := func() error {
						if err := params.DetailLevel.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "detailLevel",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: featureMode.
	{
		val := SzFeatureMode("WITH_DUPLICATES")
		params.FeatureMode.SetTo(val)
	}
	// Decode query: featureMode.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "featureMode",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFeatureModeVal SzFeatureMode
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFeatureModeVal = SzFeatureMode(c)
					return nil
				}(); err != nil {
					return err
				}
				params.FeatureMode.SetTo(paramsDotFeatureModeVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if params.FeatureMode.Set {
					if err := func() error {
						if err := params.FeatureMode.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "featureMode",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withFeatureStats.
	{
		val := bool(false)
		params.WithFeatureStats.SetTo(val)
	}
	// Decode query: withFeatureStats.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withFeatureStats",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithFeatureStatsVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithFeatureStatsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithFeatureStats.SetTo(paramsDotWithFeatureStatsVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withFeatureStats",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withInternalFeatures.
	{
		val := bool(false)
		params.WithInternalFeatures.SetTo(val)
	}
	// Decode query: withInternalFeatures.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withInternalFeatures",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithInternalFeaturesVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithInternalFeaturesVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithInternalFeatures.SetTo(paramsDotWithInternalFeaturesVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withInternalFeatures",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: forceMinimal.
	{
		val := bool(false)
		params.ForceMinimal.SetTo(val)
	}
	// Decode query: forceMinimal.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "forceMinimal",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotForceMinimalVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotForceMinimalVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ForceMinimal.SetTo(paramsDotForceMinimalVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "forceMinimal",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withRaw.
	{
		val := bool(false)
		params.WithRaw.SetTo(val)
	}
	// Decode query: withRaw.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithRawVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithRawVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithRaw.SetTo(paramsDotWithRawVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withRaw",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetAttributeTypeParams is parameters of getAttributeType operation.
type GetAttributeTypeParams struct {
	// The attribute code that uniquely identifies the attribute type.
	AttributeCode string
	// Whether or not to include the raw JSON response from the underlying native API.  This raw response
	// may include additional details but lack some of the abstraction the standard response provides.
	// If true, then the 'rawData' field in the response will be a non-null value and contain the
	// additional details.
	WithRaw OptBool
}

func unpackGetAttributeTypeParams(packed middleware.Parameters) (params GetAttributeTypeParams) {
	{
		key := middleware.ParameterKey{
			Name: "attributeCode",
			In:   "path",
		}
		params.AttributeCode = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "withRaw",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithRaw = v.(OptBool)
		}
	}
	return params
}

func decodeGetAttributeTypeParams(args [1]string, argsEscaped bool, r *http.Request) (params GetAttributeTypeParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: attributeCode.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "attributeCode",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AttributeCode = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "attributeCode",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for query: withRaw.
	{
		val := bool(false)
		params.WithRaw.SetTo(val)
	}
	// Decode query: withRaw.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithRawVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithRawVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithRaw.SetTo(paramsDotWithRawVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withRaw",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetAttributeTypesParams is parameters of getAttributeTypes operation.
type GetAttributeTypesParams struct {
	// Set to `true` to include internal attribute types that are generally not mapped by users.  This
	// defaults to false.
	WithInternal OptBool
	// If specified, this filters the list of returned attribute types to those of a specific attribute
	// class.  If not specified then no filtering on attribute class is performed and all are returned.
	AttributeClass OptSzAttributeClass
	// If specified, this filters the list of returned attribute types to those belonging to a specific
	// feature type.  If not specified then no filtering on feature type is performed and all are
	// returned.
	FeatureType OptString
	// Whether or not to include the raw JSON response from the underlying native API.  This raw response
	// may include additional details but lack some of the abstraction the standard response provides.
	// If true, then the 'rawData' field in the response will be a non-null value and contain the
	// additional details.
	WithRaw OptBool
}

func unpackGetAttributeTypesParams(packed middleware.Parameters) (params GetAttributeTypesParams) {
	{
		key := middleware.ParameterKey{
			Name: "withInternal",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithInternal = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "attributeClass",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.AttributeClass = v.(OptSzAttributeClass)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "featureType",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.FeatureType = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withRaw",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithRaw = v.(OptBool)
		}
	}
	return params
}

func decodeGetAttributeTypesParams(args [0]string, argsEscaped bool, r *http.Request) (params GetAttributeTypesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: withInternal.
	{
		val := bool(false)
		params.WithInternal.SetTo(val)
	}
	// Decode query: withInternal.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withInternal",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithInternalVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithInternalVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithInternal.SetTo(paramsDotWithInternalVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withInternal",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: attributeClass.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "attributeClass",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAttributeClassVal SzAttributeClass
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAttributeClassVal = SzAttributeClass(c)
					return nil
				}(); err != nil {
					return err
				}
				params.AttributeClass.SetTo(paramsDotAttributeClassVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if params.AttributeClass.Set {
					if err := func() error {
						if err := params.AttributeClass.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "attributeClass",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: featureType.
	{
		val := string("nil")
		params.FeatureType.SetTo(val)
	}
	// Decode query: featureType.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "featureType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFeatureTypeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFeatureTypeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.FeatureType.SetTo(paramsDotFeatureTypeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "featureType",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withRaw.
	{
		val := bool(false)
		params.WithRaw.SetTo(val)
	}
	// Decode query: withRaw.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithRawVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithRawVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithRaw.SetTo(paramsDotWithRawVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withRaw",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetDataSourceParams is parameters of getDataSource operation.
type GetDataSourceParams struct {
	// The data source code identifying the data source.
	DataSourceCode string
	// Whether or not to include the raw JSON response from the underlying native API.  This raw response
	// may include additional details but lack some of the abstraction the standard response provides.
	// If true, then the 'rawData' field in the response will be a non-null value and contain the
	// additional details.
	WithRaw OptBool
}

func unpackGetDataSourceParams(packed middleware.Parameters) (params GetDataSourceParams) {
	{
		key := middleware.ParameterKey{
			Name: "dataSourceCode",
			In:   "path",
		}
		params.DataSourceCode = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "withRaw",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithRaw = v.(OptBool)
		}
	}
	return params
}

func decodeGetDataSourceParams(args [1]string, argsEscaped bool, r *http.Request) (params GetDataSourceParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: dataSourceCode.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "dataSourceCode",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DataSourceCode = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "dataSourceCode",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for query: withRaw.
	{
		val := bool(false)
		params.WithRaw.SetTo(val)
	}
	// Decode query: withRaw.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithRawVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithRawVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithRaw.SetTo(paramsDotWithRawVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withRaw",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetDataSourcesParams is parameters of getDataSources operation.
type GetDataSourcesParams struct {
	// Whether or not to include the raw JSON response from the underlying native API.  This raw response
	// may include additional details but lack some of the abstraction the standard response provides.
	// If true, then the 'rawData' field in the response will be a non-null value and contain the
	// additional details.
	WithRaw OptBool
}

func unpackGetDataSourcesParams(packed middleware.Parameters) (params GetDataSourcesParams) {
	{
		key := middleware.ParameterKey{
			Name: "withRaw",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithRaw = v.(OptBool)
		}
	}
	return params
}

func decodeGetDataSourcesParams(args [0]string, argsEscaped bool, r *http.Request) (params GetDataSourcesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: withRaw.
	{
		val := bool(false)
		params.WithRaw.SetTo(val)
	}
	// Decode query: withRaw.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithRawVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithRawVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithRaw.SetTo(paramsDotWithRawVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withRaw",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetEntityByEntityIdParams is parameters of getEntityByEntityId operation.
type GetEntityByEntityIdParams struct {
	// The unique numeric ID that identifies that entity being requested.
	EntityId int64
	// Specifies the level of detail desired for the entity data.  Details for features of entities as
	// well as the related entities of entities are controlled by `featureMode`, `withInternalFeatures`,
	// and `withFeatureStats`.  If not specified the value defaults to `VERBOSE`. Possible values are:
	// * `BARE_MINIMAL` - The entities returned will include only their
	// entity ID's.  No record information is returned
	// and if related entities are included, they too will
	// only be described by their entity ID's and will
	// **not** include any matching info.
	// * `NETWORK_MINIMAL` - Identical to `BARE_MINIMAL` except in the case
	// of related entities being included they will
	// also include related matching info.
	// * `MINIMAL` - The entities returned will include at most their
	// entity ID's as well as identifiers for their
	// constituent records (i.e.: data source code and record
	// ID for each record).  This detail level is optimized for
	// the fastest possible processing time.
	// * `BRIEF` - Builds upon `MINIMAL` to add the entity name and related
	// entity match info when related entity match info when
	// related entities are included.  This detail level aims to
	// maintain as much speed as possible while providing names
	// and relationship information for rendering a graph.
	// * `SUMMARY` - Identical to `BRIEF` except that individual record
	// identifier information is excluded, leaving only the
	// record summary (i.e.: a record count by data source
	// code).  This reduces the size of the JSON document for
	// large entities with thousands of records.  It may take
	// longer to process than `BRIEF` but less data is
	// returned as well, speeding up network transfer times.
	// * `VERBOSE` - Combines `BRIEF` and `SUMMARY` and then adds the
	// original JSON data for each record, the record-level
	// matching info, as well as formatted record data.  NOTE:
	// the record-level matching info returned via "how" and
	// "why" is often more useful than that embedded in the
	// entity.  Further, the formatted record data, while
	// readable, is not formatted according to locale (i.e.:
	// address, name and date formatting may not appear as
	// expected to a user).
	DetailLevel OptSzDetailLevel
	// The method by which feature values should be included for entities returned in the response.  The
	// possible values are:
	// * `NONE` - Do not include any feature values -- this is the fastest
	// option from a performance perspective because feature
	// values do not have to be retrieved.
	// * `REPRESENTATIVE` - Include only a single representative value per
	// "unique" value of a feature.  If there are
	// multiple values that are near duplicates then
	// only one value is included and the others are
	// suppressed.
	// * `WITH_DUPLICATES` - ** (default value) ** Group near-duplicate
	// feature values and return a representative value
	// along with its near duplicate values.
	// * `ATTRIBUTED` - Same as `WITH_DUPLICATES` but with record-level
	// references attributing each feature to the record(s)
	// that provided it for the entity along with any
	// usage type that might have been associated with the
	// feature at the record level.
	FeatureMode OptSzFeatureMode
	// Set to `true` to include resolution statistics for features.  This defaults to `false`.
	WithFeatureStats OptBool
	// Set to `true` to include "expressed" features that are derived composite keys such as name + date
	// of birth keys.  This defaults to `false`.
	WithInternalFeatures OptBool
	// Whether (or not) to force the minimum entity detail in the response which will consist of nothing
	// more than an entity ID and record identifying information (i.e.: data source code and record ID)
	// for each constituent record of an entity.  Unlike `detailLevel=MINIMAL` setting this to `true`
	// precludes the addition of feature information via other parameters.  Setting this to `true`
	// provides the fastest response to an entity query operation because no additional data needs to be
	// retrieved other than what is directly accessible.  Setting this parameter to `true` overrules
	// other parameters governing the retrieval of features or related entities.
	ForceMinimal OptBool
	// Controls how to handle the first-degree related entities.  The possible values are:
	// * `NONE` - Do not include any data on first-degree related entities --
	// this is the fastest option from a performance perspective because
	// related entities do not have to be retrieved.
	// * `PARTIAL` - **(default value)** Include only partial stub
	// information for related entities with the `partial` property of the
	// `SzRelatedEntity` instances set to `true`.  Obtaining additional
	// information requires subsequent API calls.
	// * `FULL` - Include full data on the first-degree related entities
	// according to the `featureMode` and `detailLevel` **unless**
	// `forceMinimal` is `true`.  This option obtains the entity network
	// at one degree for the requested entity and will populate up to 1000
	// related entities as much as possible with respect to the
	// `featureMode` and `detailLevel`.  Related entities beyond the first
	// 1000 will be left incomplete and have their `partial` property set
	// to `true` regardless of the `detailLevel` and `featureMode`.  If
	// this value is specified along with `forceMinimal=true` then
	// `PARTIAL` is used instead.
	WithRelated OptSzRelationshipMode
	// Whether or not to include the raw JSON response from the underlying native API.  This raw response
	// may include additional details but lack some of the abstraction the standard response provides.
	// If true, then the 'rawData' field in the response will be a non-null value and contain the
	// additional details.
	WithRaw OptBool
}

func unpackGetEntityByEntityIdParams(packed middleware.Parameters) (params GetEntityByEntityIdParams) {
	{
		key := middleware.ParameterKey{
			Name: "entityId",
			In:   "path",
		}
		params.EntityId = packed[key].(int64)
	}
	{
		key := middleware.ParameterKey{
			Name: "detailLevel",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.DetailLevel = v.(OptSzDetailLevel)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "featureMode",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.FeatureMode = v.(OptSzFeatureMode)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withFeatureStats",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithFeatureStats = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withInternalFeatures",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithInternalFeatures = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "forceMinimal",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ForceMinimal = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withRelated",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithRelated = v.(OptSzRelationshipMode)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withRaw",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithRaw = v.(OptBool)
		}
	}
	return params
}

func decodeGetEntityByEntityIdParams(args [1]string, argsEscaped bool, r *http.Request) (params GetEntityByEntityIdParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: entityId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "entityId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt64(val)
				if err != nil {
					return err
				}

				params.EntityId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "entityId",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for query: detailLevel.
	{
		val := SzDetailLevel("VERBOSE")
		params.DetailLevel.SetTo(val)
	}
	// Decode query: detailLevel.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "detailLevel",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDetailLevelVal SzDetailLevel
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDetailLevelVal = SzDetailLevel(c)
					return nil
				}(); err != nil {
					return err
				}
				params.DetailLevel.SetTo(paramsDotDetailLevelVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if params.DetailLevel.Set {
					if err := func() error {
						if err := params.DetailLevel.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "detailLevel",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: featureMode.
	{
		val := SzFeatureMode("WITH_DUPLICATES")
		params.FeatureMode.SetTo(val)
	}
	// Decode query: featureMode.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "featureMode",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFeatureModeVal SzFeatureMode
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFeatureModeVal = SzFeatureMode(c)
					return nil
				}(); err != nil {
					return err
				}
				params.FeatureMode.SetTo(paramsDotFeatureModeVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if params.FeatureMode.Set {
					if err := func() error {
						if err := params.FeatureMode.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "featureMode",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withFeatureStats.
	{
		val := bool(false)
		params.WithFeatureStats.SetTo(val)
	}
	// Decode query: withFeatureStats.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withFeatureStats",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithFeatureStatsVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithFeatureStatsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithFeatureStats.SetTo(paramsDotWithFeatureStatsVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withFeatureStats",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withInternalFeatures.
	{
		val := bool(false)
		params.WithInternalFeatures.SetTo(val)
	}
	// Decode query: withInternalFeatures.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withInternalFeatures",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithInternalFeaturesVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithInternalFeaturesVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithInternalFeatures.SetTo(paramsDotWithInternalFeaturesVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withInternalFeatures",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: forceMinimal.
	{
		val := bool(false)
		params.ForceMinimal.SetTo(val)
	}
	// Decode query: forceMinimal.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "forceMinimal",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotForceMinimalVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotForceMinimalVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ForceMinimal.SetTo(paramsDotForceMinimalVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "forceMinimal",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withRelated.
	{
		val := SzRelationshipMode("PARTIAL")
		params.WithRelated.SetTo(val)
	}
	// Decode query: withRelated.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withRelated",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithRelatedVal SzRelationshipMode
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotWithRelatedVal = SzRelationshipMode(c)
					return nil
				}(); err != nil {
					return err
				}
				params.WithRelated.SetTo(paramsDotWithRelatedVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if params.WithRelated.Set {
					if err := func() error {
						if err := params.WithRelated.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withRelated",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withRaw.
	{
		val := bool(false)
		params.WithRaw.SetTo(val)
	}
	// Decode query: withRaw.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithRawVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithRawVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithRaw.SetTo(paramsDotWithRawVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withRaw",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetEntityByRecordIdParams is parameters of getEntityByRecordId operation.
type GetEntityByRecordIdParams struct {
	// The data source code identifying the data source.
	DataSourceCode string
	// The identifier that uniquely identifies the requested record within a given data source.  This may
	// have been specified when the record was loaded or generated automatically.
	RecordId string
	// Specifies the level of detail desired for the entity data.  Details for features of entities as
	// well as the related entities of entities are controlled by `featureMode`, `withInternalFeatures`,
	// and `withFeatureStats`.  If not specified the value defaults to `VERBOSE`. Possible values are:
	// * `BARE_MINIMAL` - The entities returned will include only their
	// entity ID's.  No record information is returned
	// and if related entities are included, they too will
	// only be described by their entity ID's and will
	// **not** include any matching info.
	// * `NETWORK_MINIMAL` - Identical to `BARE_MINIMAL` except in the case
	// of related entities being included they will
	// also include related matching info.
	// * `MINIMAL` - The entities returned will include at most their
	// entity ID's as well as identifiers for their
	// constituent records (i.e.: data source code and record
	// ID for each record).  This detail level is optimized for
	// the fastest possible processing time.
	// * `BRIEF` - Builds upon `MINIMAL` to add the entity name and related
	// entity match info when related entity match info when
	// related entities are included.  This detail level aims to
	// maintain as much speed as possible while providing names
	// and relationship information for rendering a graph.
	// * `SUMMARY` - Identical to `BRIEF` except that individual record
	// identifier information is excluded, leaving only the
	// record summary (i.e.: a record count by data source
	// code).  This reduces the size of the JSON document for
	// large entities with thousands of records.  It may take
	// longer to process than `BRIEF` but less data is
	// returned as well, speeding up network transfer times.
	// * `VERBOSE` - Combines `BRIEF` and `SUMMARY` and then adds the
	// original JSON data for each record, the record-level
	// matching info, as well as formatted record data.  NOTE:
	// the record-level matching info returned via "how" and
	// "why" is often more useful than that embedded in the
	// entity.  Further, the formatted record data, while
	// readable, is not formatted according to locale (i.e.:
	// address, name and date formatting may not appear as
	// expected to a user).
	DetailLevel OptSzDetailLevel
	// The method by which feature values should be included for entities returned in the response.  The
	// possible values are:
	// * `NONE` - Do not include any feature values -- this is the fastest
	// option from a performance perspective because feature
	// values do not have to be retrieved.
	// * `REPRESENTATIVE` - Include only a single representative value per
	// "unique" value of a feature.  If there are
	// multiple values that are near duplicates then
	// only one value is included and the others are
	// suppressed.
	// * `WITH_DUPLICATES` - ** (default value) ** Group near-duplicate
	// feature values and return a representative value
	// along with its near duplicate values.
	// * `ATTRIBUTED` - Same as `WITH_DUPLICATES` but with record-level
	// references attributing each feature to the record(s)
	// that provided it for the entity along with any
	// usage type that might have been associated with the
	// feature at the record level.
	FeatureMode OptSzFeatureMode
	// Set to `true` to include resolution statistics for features.  This defaults to `false`.
	WithFeatureStats OptBool
	// Set to `true` to include "expressed" features that are derived composite keys such as name + date
	// of birth keys.  This defaults to `false`.
	WithInternalFeatures OptBool
	// Whether (or not) to force the minimum entity detail in the response which will consist of nothing
	// more than an entity ID and record identifying information (i.e.: data source code and record ID)
	// for each constituent record of an entity.  Unlike `detailLevel=MINIMAL` setting this to `true`
	// precludes the addition of feature information via other parameters.  Setting this to `true`
	// provides the fastest response to an entity query operation because no additional data needs to be
	// retrieved other than what is directly accessible.  Setting this parameter to `true` overrules
	// other parameters governing the retrieval of features or related entities.
	ForceMinimal OptBool
	// Controls how to handle the first-degree related entities.  The possible values are:
	// * `NONE` - Do not include any data on first-degree related entities --
	// this is the fastest option from a performance perspective because
	// related entities do not have to be retrieved.
	// * `PARTIAL` - **(default value)** Include only partial stub
	// information for related entities with the `partial` property of the
	// `SzRelatedEntity` instances set to `true`.  Obtaining additional
	// information requires subsequent API calls.
	// * `FULL` - Include full data on the first-degree related entities
	// according to the `featureMode` and `detailLevel` **unless**
	// `forceMinimal` is `true`.  This option obtains the entity network
	// at one degree for the requested entity and will populate up to 1000
	// related entities as much as possible with respect to the
	// `featureMode` and `detailLevel`.  Related entities beyond the first
	// 1000 will be left incomplete and have their `partial` property set
	// to `true` regardless of the `detailLevel` and `featureMode`.  If
	// this value is specified along with `forceMinimal=true` then
	// `PARTIAL` is used instead.
	WithRelated OptSzRelationshipMode
	// Whether or not to include the raw JSON response from the underlying native API.  This raw response
	// may include additional details but lack some of the abstraction the standard response provides.
	// If true, then the 'rawData' field in the response will be a non-null value and contain the
	// additional details.
	WithRaw OptBool
}

func unpackGetEntityByRecordIdParams(packed middleware.Parameters) (params GetEntityByRecordIdParams) {
	{
		key := middleware.ParameterKey{
			Name: "dataSourceCode",
			In:   "path",
		}
		params.DataSourceCode = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "recordId",
			In:   "path",
		}
		params.RecordId = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "detailLevel",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.DetailLevel = v.(OptSzDetailLevel)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "featureMode",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.FeatureMode = v.(OptSzFeatureMode)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withFeatureStats",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithFeatureStats = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withInternalFeatures",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithInternalFeatures = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "forceMinimal",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ForceMinimal = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withRelated",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithRelated = v.(OptSzRelationshipMode)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withRaw",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithRaw = v.(OptBool)
		}
	}
	return params
}

func decodeGetEntityByRecordIdParams(args [2]string, argsEscaped bool, r *http.Request) (params GetEntityByRecordIdParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: dataSourceCode.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "dataSourceCode",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DataSourceCode = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "dataSourceCode",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: recordId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "recordId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.RecordId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "recordId",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for query: detailLevel.
	{
		val := SzDetailLevel("VERBOSE")
		params.DetailLevel.SetTo(val)
	}
	// Decode query: detailLevel.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "detailLevel",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDetailLevelVal SzDetailLevel
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDetailLevelVal = SzDetailLevel(c)
					return nil
				}(); err != nil {
					return err
				}
				params.DetailLevel.SetTo(paramsDotDetailLevelVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if params.DetailLevel.Set {
					if err := func() error {
						if err := params.DetailLevel.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "detailLevel",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: featureMode.
	{
		val := SzFeatureMode("WITH_DUPLICATES")
		params.FeatureMode.SetTo(val)
	}
	// Decode query: featureMode.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "featureMode",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFeatureModeVal SzFeatureMode
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFeatureModeVal = SzFeatureMode(c)
					return nil
				}(); err != nil {
					return err
				}
				params.FeatureMode.SetTo(paramsDotFeatureModeVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if params.FeatureMode.Set {
					if err := func() error {
						if err := params.FeatureMode.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "featureMode",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withFeatureStats.
	{
		val := bool(false)
		params.WithFeatureStats.SetTo(val)
	}
	// Decode query: withFeatureStats.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withFeatureStats",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithFeatureStatsVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithFeatureStatsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithFeatureStats.SetTo(paramsDotWithFeatureStatsVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withFeatureStats",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withInternalFeatures.
	{
		val := bool(false)
		params.WithInternalFeatures.SetTo(val)
	}
	// Decode query: withInternalFeatures.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withInternalFeatures",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithInternalFeaturesVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithInternalFeaturesVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithInternalFeatures.SetTo(paramsDotWithInternalFeaturesVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withInternalFeatures",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: forceMinimal.
	{
		val := bool(false)
		params.ForceMinimal.SetTo(val)
	}
	// Decode query: forceMinimal.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "forceMinimal",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotForceMinimalVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotForceMinimalVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ForceMinimal.SetTo(paramsDotForceMinimalVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "forceMinimal",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withRelated.
	{
		val := SzRelationshipMode("PARTIAL")
		params.WithRelated.SetTo(val)
	}
	// Decode query: withRelated.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withRelated",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithRelatedVal SzRelationshipMode
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotWithRelatedVal = SzRelationshipMode(c)
					return nil
				}(); err != nil {
					return err
				}
				params.WithRelated.SetTo(paramsDotWithRelatedVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if params.WithRelated.Set {
					if err := func() error {
						if err := params.WithRelated.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withRelated",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withRaw.
	{
		val := bool(false)
		params.WithRaw.SetTo(val)
	}
	// Decode query: withRaw.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithRawVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithRawVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithRaw.SetTo(paramsDotWithRawVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withRaw",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetRecordParams is parameters of getRecord operation.
type GetRecordParams struct {
	// The data source code identifying the data source.
	DataSourceCode string
	// The identifier that uniquely identifies the requested record within a given data source.  This may
	// have been specified when the record was loaded or generated automatically.
	RecordId string
	// Whether or not to include the raw JSON response from the underlying native API.  This raw response
	// may include additional details but lack some of the abstraction the standard response provides.
	// If true, then the 'rawData' field in the response will be a non-null value and contain the
	// additional details.
	WithRaw OptBool
}

func unpackGetRecordParams(packed middleware.Parameters) (params GetRecordParams) {
	{
		key := middleware.ParameterKey{
			Name: "dataSourceCode",
			In:   "path",
		}
		params.DataSourceCode = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "recordId",
			In:   "path",
		}
		params.RecordId = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "withRaw",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithRaw = v.(OptBool)
		}
	}
	return params
}

func decodeGetRecordParams(args [2]string, argsEscaped bool, r *http.Request) (params GetRecordParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: dataSourceCode.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "dataSourceCode",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DataSourceCode = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "dataSourceCode",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: recordId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "recordId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.RecordId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "recordId",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for query: withRaw.
	{
		val := bool(false)
		params.WithRaw.SetTo(val)
	}
	// Decode query: withRaw.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithRawVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithRawVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithRaw.SetTo(paramsDotWithRawVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withRaw",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetVirtualEntityByRecordIdsParams is parameters of getVirtualEntityByRecordIds operation.
type GetVirtualEntityByRecordIdsParams struct {
	// Specifies the level of detail desired for the entity data.  Details for features of entities as
	// well as the related entities of entities are controlled by `featureMode`, `withInternalFeatures`,
	// and `withFeatureStats`.  If not specified the value defaults to `VERBOSE`. Possible values are:
	// * `BARE_MINIMAL` - The entities returned will include only their
	// entity ID's.  No record information is returned
	// and if related entities are included, they too will
	// only be described by their entity ID's and will
	// **not** include any matching info.
	// * `NETWORK_MINIMAL` - Identical to `BARE_MINIMAL` except in the case
	// of related entities being included they will
	// also include related matching info.
	// * `MINIMAL` - The entities returned will include at most their
	// entity ID's as well as identifiers for their
	// constituent records (i.e.: data source code and record
	// ID for each record).  This detail level is optimized for
	// the fastest possible processing time.
	// * `BRIEF` - Builds upon `MINIMAL` to add the entity name and related
	// entity match info when related entity match info when
	// related entities are included.  This detail level aims to
	// maintain as much speed as possible while providing names
	// and relationship information for rendering a graph.
	// * `SUMMARY` - Identical to `BRIEF` except that individual record
	// identifier information is excluded, leaving only the
	// record summary (i.e.: a record count by data source
	// code).  This reduces the size of the JSON document for
	// large entities with thousands of records.  It may take
	// longer to process than `BRIEF` but less data is
	// returned as well, speeding up network transfer times.
	// * `VERBOSE` - Combines `BRIEF` and `SUMMARY` and then adds the
	// original JSON data for each record, the record-level
	// matching info, as well as formatted record data.  NOTE:
	// the record-level matching info returned via "how" and
	// "why" is often more useful than that embedded in the
	// entity.  Further, the formatted record data, while
	// readable, is not formatted according to locale (i.e.:
	// address, name and date formatting may not appear as
	// expected to a user).
	DetailLevel OptSzDetailLevel
	// The method by which feature values should be included for entities returned in the response.  The
	// possible values are:
	// * `NONE` - Do not include any feature values -- this is the fastest
	// option from a performance perspective because feature
	// values do not have to be retrieved.
	// * `REPRESENTATIVE` - Include only a single representative value per
	// "unique" value of a feature.  If there are
	// multiple values that are near duplicates then
	// only one value is included and the others are
	// suppressed.
	// * `WITH_DUPLICATES` - ** (default value) ** Group near-duplicate
	// feature values and return a representative value
	// along with its near duplicate values.
	// * `ATTRIBUTED` - Same as `WITH_DUPLICATES` but with record-level
	// references attributing each feature to the record(s)
	// that provided it for the entity along with any
	// usage type that might have been associated with the
	// feature at the record level.
	FeatureMode OptSzFeatureMode
	// Set to `true` to include resolution statistics for features.  This defaults to `false`.
	WithFeatureStats OptBool
	// Set to `true` to include "expressed" features that are derived composite keys such as name + date
	// of birth keys.  This defaults to `false`.
	WithInternalFeatures OptBool
	// Whether (or not) to force the minimum entity detail in the response which will consist of nothing
	// more than an entity ID and record identifying information (i.e.: data source code and record ID)
	// for each constituent record of an entity.  Unlike `detailLevel=MINIMAL` setting this to `true`
	// precludes the addition of feature information via other parameters.  Setting this to `true`
	// provides the fastest response to an entity query operation because no additional data needs to be
	// retrieved other than what is directly accessible.  Setting this parameter to `true` overrules
	// other parameters governing the retrieval of features or related entities.
	ForceMinimal OptBool
	// Whether or not to include the raw JSON response from the underlying native API.  This raw response
	// may include additional details but lack some of the abstraction the standard response provides.
	// If true, then the 'rawData' field in the response will be a non-null value and contain the
	// additional details.
	WithRaw OptBool
}

func unpackGetVirtualEntityByRecordIdsParams(packed middleware.Parameters) (params GetVirtualEntityByRecordIdsParams) {
	{
		key := middleware.ParameterKey{
			Name: "detailLevel",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.DetailLevel = v.(OptSzDetailLevel)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "featureMode",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.FeatureMode = v.(OptSzFeatureMode)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withFeatureStats",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithFeatureStats = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withInternalFeatures",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithInternalFeatures = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "forceMinimal",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ForceMinimal = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withRaw",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithRaw = v.(OptBool)
		}
	}
	return params
}

func decodeGetVirtualEntityByRecordIdsParams(args [0]string, argsEscaped bool, r *http.Request) (params GetVirtualEntityByRecordIdsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: detailLevel.
	{
		val := SzDetailLevel("VERBOSE")
		params.DetailLevel.SetTo(val)
	}
	// Decode query: detailLevel.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "detailLevel",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDetailLevelVal SzDetailLevel
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDetailLevelVal = SzDetailLevel(c)
					return nil
				}(); err != nil {
					return err
				}
				params.DetailLevel.SetTo(paramsDotDetailLevelVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if params.DetailLevel.Set {
					if err := func() error {
						if err := params.DetailLevel.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "detailLevel",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: featureMode.
	{
		val := SzFeatureMode("WITH_DUPLICATES")
		params.FeatureMode.SetTo(val)
	}
	// Decode query: featureMode.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "featureMode",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFeatureModeVal SzFeatureMode
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFeatureModeVal = SzFeatureMode(c)
					return nil
				}(); err != nil {
					return err
				}
				params.FeatureMode.SetTo(paramsDotFeatureModeVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if params.FeatureMode.Set {
					if err := func() error {
						if err := params.FeatureMode.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "featureMode",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withFeatureStats.
	{
		val := bool(false)
		params.WithFeatureStats.SetTo(val)
	}
	// Decode query: withFeatureStats.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withFeatureStats",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithFeatureStatsVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithFeatureStatsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithFeatureStats.SetTo(paramsDotWithFeatureStatsVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withFeatureStats",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withInternalFeatures.
	{
		val := bool(false)
		params.WithInternalFeatures.SetTo(val)
	}
	// Decode query: withInternalFeatures.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withInternalFeatures",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithInternalFeaturesVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithInternalFeaturesVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithInternalFeatures.SetTo(paramsDotWithInternalFeaturesVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withInternalFeatures",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: forceMinimal.
	{
		val := bool(false)
		params.ForceMinimal.SetTo(val)
	}
	// Decode query: forceMinimal.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "forceMinimal",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotForceMinimalVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotForceMinimalVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ForceMinimal.SetTo(paramsDotForceMinimalVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "forceMinimal",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withRaw.
	{
		val := bool(false)
		params.WithRaw.SetTo(val)
	}
	// Decode query: withRaw.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithRawVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithRawVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithRaw.SetTo(paramsDotWithRawVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withRaw",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// HowEntityByEntityIDParams is parameters of howEntityByEntityID operation.
type HowEntityByEntityIDParams struct {
	// The unique numeric ID that identifies the entity for which to perform the analysis.
	EntityId int64
	// Whether or not to include the raw JSON response from the underlying native API.  This raw response
	// may include additional details but lack some of the abstraction the standard response provides.
	// If true, then the 'rawData' field in the response will be a non-null value and contain the
	// additional details.
	WithRaw OptBool
}

func unpackHowEntityByEntityIDParams(packed middleware.Parameters) (params HowEntityByEntityIDParams) {
	{
		key := middleware.ParameterKey{
			Name: "entityId",
			In:   "path",
		}
		params.EntityId = packed[key].(int64)
	}
	{
		key := middleware.ParameterKey{
			Name: "withRaw",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithRaw = v.(OptBool)
		}
	}
	return params
}

func decodeHowEntityByEntityIDParams(args [1]string, argsEscaped bool, r *http.Request) (params HowEntityByEntityIDParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: entityId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "entityId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt64(val)
				if err != nil {
					return err
				}

				params.EntityId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "entityId",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for query: withRaw.
	{
		val := bool(false)
		params.WithRaw.SetTo(val)
	}
	// Decode query: withRaw.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithRawVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithRawVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithRaw.SetTo(paramsDotWithRawVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withRaw",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// HowEntityByRecordIDParams is parameters of howEntityByRecordID operation.
type HowEntityByRecordIDParams struct {
	// The data source code identifying the data source.
	DataSourceCode string
	// The identifier that uniquely identifies the requested record within a given data source.  This may
	// have been specified when the record was loaded or generated automatically.
	RecordId string
	// Whether or not to include the raw JSON response from the underlying native API.  This raw response
	// may include additional details but lack some of the abstraction the standard response provides.
	// If true, then the 'rawData' field in the response will be a non-null value and contain the
	// additional details.
	WithRaw OptBool
}

func unpackHowEntityByRecordIDParams(packed middleware.Parameters) (params HowEntityByRecordIDParams) {
	{
		key := middleware.ParameterKey{
			Name: "dataSourceCode",
			In:   "path",
		}
		params.DataSourceCode = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "recordId",
			In:   "path",
		}
		params.RecordId = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "withRaw",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithRaw = v.(OptBool)
		}
	}
	return params
}

func decodeHowEntityByRecordIDParams(args [2]string, argsEscaped bool, r *http.Request) (params HowEntityByRecordIDParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: dataSourceCode.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "dataSourceCode",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DataSourceCode = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "dataSourceCode",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: recordId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "recordId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.RecordId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "recordId",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for query: withRaw.
	{
		val := bool(false)
		params.WithRaw.SetTo(val)
	}
	// Decode query: withRaw.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithRawVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithRawVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithRaw.SetTo(paramsDotWithRawVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withRaw",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// LicenseParams is parameters of license operation.
type LicenseParams struct {
	// Whether or not to include the raw JSON response from the underlying native API.  This raw response
	// may include additional details but lack some of the abstraction the standard response provides.
	// If true, then the 'rawData' field in the response will be a non-null value and contain the
	// additional details.
	WithRaw OptBool
}

func unpackLicenseParams(packed middleware.Parameters) (params LicenseParams) {
	{
		key := middleware.ParameterKey{
			Name: "withRaw",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithRaw = v.(OptBool)
		}
	}
	return params
}

func decodeLicenseParams(args [0]string, argsEscaped bool, r *http.Request) (params LicenseParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: withRaw.
	{
		val := bool(false)
		params.WithRaw.SetTo(val)
	}
	// Decode query: withRaw.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithRawVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithRawVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithRaw.SetTo(paramsDotWithRawVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withRaw",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// LoadBulkRecordsParams is parameters of loadBulkRecords operation.
type LoadBulkRecordsParams struct {
	// Used to set the overriding data source for the records.  This data
	// source will be assigned to every record **unless** the record's
	// data source (including blank data source) has a specific mapping
	// specified by a `mapDataSources` or `mapDataSource` parameters.  If
	// this parameter is **not** provided and no specific overrides are
	// provided for a record then the data source specified in the inbound
	// record is used directly.  If the record has no data source and no
	// override is provided then it will fail to load.
	DataSource OptString
	// A URL-encoded JSON object whose properties are interpreted as
	// data source codes to map from and whose corresponding values are
	// interpretted as data source codes to map to.  For example,
	// `{"EMPL": "EMPLOYEES"}` (url-encoded of course) would map all
	// records with inbound data source `EMPL` to `EMPLOYEES`.  To map
	// only inbound records with no data source to a specific data source
	// you would use an empty JSON property (e.g.: `{"": "CUSTOMERS"}`).
	// If the `dataSource` parameter is **not** provided and no specific
	// overrides are provided for a record with this parameter or via
	// `mapDataSource` then the data source specified in the inbound
	// record is used directly.  If the record has no data source and no
	// overriding or mapped data source is provided for an empty data
	// source then the record will fail to load.
	// **NOTE**: If both this parameter and the `mapDataSource` parameter
	// is provided then the mappings are merged with the more ad-hoc
	// `mapDataSource` parameter taking precedence since it is likely being
	// used for debugging and diagnostic purposes to avoid the URL
	// encoding.
	// Here are some examples of encoding this parameter:
	// - **JavaScript Example**
	// ```javascript
	// var dataSourceMap = {
	// "": "CUSTOMERS",
	// "EMPL": "EMPLOYEES",
	// "VEND": "VENDORS"
	// };
	// var mapDataSources = JSON.stringify(dataSourceMap);
	// var urlPath = "/bulk-data/load?mapDataSources="
	// + encodeURIComponent(mapDataSources);
	// ```
	// - **Java Example**
	// ```java
	// JsonObjectBuilder builder = Json.createObjectBuilder();
	// builder.add("", "CUSTOMERS");
	// builder.add("EMPL", "EMPLOYEES");
	// builder.add("VEND", "VENDORS");
	// JsonObject dataSourceMap = builder.build();
	// String mapDataSources = dataSourceMap.toString();
	// String encodedMap     = URLEncoder.encode(mapDataSources, "UTF-8");
	// String urlPath = "/bulk-data/load?mapDataSources=" + encodedMap;
	// ```
	// In both of the above examples the `urlPath` variable is set to:
	// ```json
	// /bulk-data/load?mapDataSources=%7B%22%22%3A%22CUSTOMERS%22%2C%22EMPL%22%3A%22EMPLOYEES%22%2C%22VEND%22%3A%22VENDORS%22%7D
	// ```.
	MapDataSources OptString
	// As an alternative to the `mapDataSources` parameter you may specify
	// the `mapDataSource` parameter zero or more times to add additional
	// data source mappings or **override** data source mappings from
	// `mapDataSources`.  If you are using this API programmatically
	// then you should typically use the `mapDataSources` parameter
	// instead of this one.  But when manually constructing a URL in the
	// browser address bar, in a command-line tool like `curl` or in a REST
	// client browser extension for debugging or testing purposes, encoding
	// the JSON value for `mapDataSources` can be unwieldy.  This parameter
	// (which is multi-valued) lets you specify delimited strings that
	// begin with the delimiter character, followed by the original
	// data source name, then the delimiter character and the new data
	// source name.  You should only have to URL-encode the delimiter you
	// choose and maybe spaces.  For example, `:EMPL:EMPLOYEES` or
	// `|EMPL|EMPLOYEES` (url-encoded of course) would map all records with
	// inbound data source `EMPL` to `EMPLOYEES`.  To map only inbound
	// records with no data source to a specific data source you would
	// begin the value with two repeated delimiter characters followed by
	// the new data source value (e.g.: `||CUSTOMERS` or `::CUSTOMERS`).
	// If the `dataSource` parameter is **not** provided and no specific
	// overrides are provided for a record with this parameter or the
	// `mapDataSources` parameter then the data source specified in the
	// inbound record is used directly.  If the record has no data source
	// and no overriding or mapped data source is provided for an empty
	// data source then the record will fail to load.
	MapDataSource []string
	// The maximum number of failures that can occur before the bulk
	// load operation is aborted.  If the value is less-than or equal-to
	// zero (0) then the operation will continue regardless of the number
	// of errors that occur.
	MaxFailures OptInt32
	// The suggested maximum time between SSE `progress` events specified in milliseconds.  If not
	// specified then the default of `3000` milliseconds (i.e.: 3 seconds) is used.  This parameter is
	// NOT used if the operation is not producing an SSE response (i.e.: `text/event-stream` media type
	// was not requested via the `Accept` header).
	ProgressPeriod OptInt64
	// The number of seconds to wait for an additional Web Sockets message before assuming end-of-file
	// (EOF) when using this end-point via Web Sockets protocol.  If this number of seconds elapses with
	// no additional incoming data then the server assumes that there are no more file chunks forthcoming.
	//   If not specified then the default of `3` seconds is used. This parameter is NOT used if the
	// operation is not invoked via the Web Sockets (`ws://`) protocol.  **NOTE**: This is specified in
	// seconds, **not** milliseconds.
	EofSendTimeout OptInt32
}

func unpackLoadBulkRecordsParams(packed middleware.Parameters) (params LoadBulkRecordsParams) {
	{
		key := middleware.ParameterKey{
			Name: "dataSource",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.DataSource = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "mapDataSources",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.MapDataSources = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "mapDataSource",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.MapDataSource = v.([]string)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "maxFailures",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.MaxFailures = v.(OptInt32)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "progressPeriod",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ProgressPeriod = v.(OptInt64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "eofSendTimeout",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.EofSendTimeout = v.(OptInt32)
		}
	}
	return params
}

func decodeLoadBulkRecordsParams(args [0]string, argsEscaped bool, r *http.Request) (params LoadBulkRecordsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: dataSource.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "dataSource",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDataSourceVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDataSourceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.DataSource.SetTo(paramsDotDataSourceVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "dataSource",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: mapDataSources.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "mapDataSources",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotMapDataSourcesVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotMapDataSourcesVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.MapDataSources.SetTo(paramsDotMapDataSourcesVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "mapDataSources",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: mapDataSource.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "mapDataSource",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotMapDataSourceVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotMapDataSourceVal = c
						return nil
					}(); err != nil {
						return err
					}
					params.MapDataSource = append(params.MapDataSource, paramsDotMapDataSourceVal)
					return nil
				})
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "mapDataSource",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: maxFailures.
	{
		val := int32(0)
		params.MaxFailures.SetTo(val)
	}
	// Decode query: maxFailures.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "maxFailures",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotMaxFailuresVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotMaxFailuresVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.MaxFailures.SetTo(paramsDotMaxFailuresVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "maxFailures",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: progressPeriod.
	{
		val := int64(3000)
		params.ProgressPeriod.SetTo(val)
	}
	// Decode query: progressPeriod.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "progressPeriod",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotProgressPeriodVal int64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt64(val)
					if err != nil {
						return err
					}

					paramsDotProgressPeriodVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ProgressPeriod.SetTo(paramsDotProgressPeriodVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "progressPeriod",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: eofSendTimeout.
	{
		val := int32(3)
		params.EofSendTimeout.SetTo(val)
	}
	// Decode query: eofSendTimeout.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "eofSendTimeout",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEofSendTimeoutVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotEofSendTimeoutVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.EofSendTimeout.SetTo(paramsDotEofSendTimeoutVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "eofSendTimeout",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ReevaluateEntityParams is parameters of reevaluateEntity operation.
type ReevaluateEntityParams struct {
	// The entity ID of the entity to reevaluate.
	EntityId int64
	// Set to `true` to include resolution information related to loading, and `false` to exclude it.
	// This defaults to `false`.
	WithInfo OptBool
	// Whether or not to include the raw JSON response from the underlying native API.  This raw response
	// may include additional details but lack some of the abstraction the standard response provides.
	// If true, then the 'rawData' field in the response will be a non-null value and contain the
	// additional details.
	WithRaw OptBool
}

func unpackReevaluateEntityParams(packed middleware.Parameters) (params ReevaluateEntityParams) {
	{
		key := middleware.ParameterKey{
			Name: "entityId",
			In:   "query",
		}
		params.EntityId = packed[key].(int64)
	}
	{
		key := middleware.ParameterKey{
			Name: "withInfo",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithInfo = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withRaw",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithRaw = v.(OptBool)
		}
	}
	return params
}

func decodeReevaluateEntityParams(args [0]string, argsEscaped bool, r *http.Request) (params ReevaluateEntityParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: entityId.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "entityId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt64(val)
				if err != nil {
					return err
				}

				params.EntityId = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "entityId",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withInfo.
	{
		val := bool(false)
		params.WithInfo.SetTo(val)
	}
	// Decode query: withInfo.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withInfo",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithInfoVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithInfoVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithInfo.SetTo(paramsDotWithInfoVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withInfo",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withRaw.
	{
		val := bool(false)
		params.WithRaw.SetTo(val)
	}
	// Decode query: withRaw.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithRawVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithRawVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithRaw.SetTo(paramsDotWithRawVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withRaw",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ReevaluateRecordParams is parameters of reevaluateRecord operation.
type ReevaluateRecordParams struct {
	// The data source code identifying the data source.
	DataSourceCode string
	// The identifier that uniquely identifies the requested record within a given data source.  This may
	// have been specified when the record was loaded or generated automatically.
	RecordId string
	// Set to `true` to include resolution information related to loading, and `false` to exclude it.
	// This defaults to `false`.
	WithInfo OptBool
	// Whether or not to include the raw JSON response from the underlying native API.  This raw response
	// may include additional details but lack some of the abstraction the standard response provides.
	// If true, then the 'rawData' field in the response will be a non-null value and contain the
	// additional details.
	WithRaw OptBool
}

func unpackReevaluateRecordParams(packed middleware.Parameters) (params ReevaluateRecordParams) {
	{
		key := middleware.ParameterKey{
			Name: "dataSourceCode",
			In:   "path",
		}
		params.DataSourceCode = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "recordId",
			In:   "path",
		}
		params.RecordId = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "withInfo",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithInfo = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withRaw",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithRaw = v.(OptBool)
		}
	}
	return params
}

func decodeReevaluateRecordParams(args [2]string, argsEscaped bool, r *http.Request) (params ReevaluateRecordParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: dataSourceCode.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "dataSourceCode",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DataSourceCode = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "dataSourceCode",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: recordId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "recordId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.RecordId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "recordId",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for query: withInfo.
	{
		val := bool(false)
		params.WithInfo.SetTo(val)
	}
	// Decode query: withInfo.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withInfo",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithInfoVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithInfoVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithInfo.SetTo(paramsDotWithInfoVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withInfo",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withRaw.
	{
		val := bool(false)
		params.WithRaw.SetTo(val)
	}
	// Decode query: withRaw.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithRawVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithRawVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithRaw.SetTo(paramsDotWithRawVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withRaw",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// SearchEntitiesByGetParams is parameters of searchEntitiesByGet operation.
type SearchEntitiesByGetParams struct {
	// The JSON record describing the entity attributes in the same
	// format as how an entity record is loaded.  The specified
	// attributes are treated as a hypothetical record being loaded,
	// and the result is anything that would have matched or related
	// to it.  Here are some examples of encoding this parameter:
	// - **JavaScript Example**
	// ```javascript
	// var searchCriteria = {
	// "NAME_FULL": "Joe Schmoe",
	// "DATE_OF_BIRTH": "03-SEP-1987"
	// };
	// var searchAttrs = JSON.stringify(searchCriteria);
	// var urlPath = "/entities?attrs=" + encodeURIComponent(searchAttrs);
	// ```
	// - **Java Example**
	// ```java
	// JsonObjectBuilder builder = Json.createObjectBuilder();
	// builder.add("NAME_FULL", "Joe Schmoe");
	// builder.add("DATE_OF_BIRTH", "03-SEP-1987");
	// JsonObject searchCriteria = builder.build();
	// String searchAttrs = searchCriteria.toString();
	// String encodedAttrs = URLEncoder.encode(searchAttrs, "UTF-8");
	// String urlPath = "/entities?attrs=" + encodedAttrs;
	// ```
	// In both of the above examples the `urlPath` variable is set to:
	// ```json
	// /entities?attrs=%7B%22NAME_FULL%22%3A%22Joe%20Schmoe%22%2C%22DATE_OF_BIRTH%22%3A%2203-SEP-1987%22%7D
	// ```.
	Attrs OptString
	// Either the `attrs` or `attr` parameter is required, **however** if the `attrs` parameter is
	// provided it takes precedence and the `attr` parameter will be ignored.  If you are using this API
	// programmatically then you should typically use the `attrs` parameter.  But when manually
	// constructing a URL in the browser address bar, in a command-line tool like `curl` or in a REST
	// client browser extension for debugging or testing purposes, encoding that JSON value can be
	// unwieldy.  This parameter (which is multi-valued) lets you specify colon-delimited strings that
	// are prefixed with the JSON property name and suffixed with the value.  For example,
	// `NAME_FIRST:Joe` (url encoded of course).  This side-steps the need to URL-encode the structural
	// JSON characters and usually means you need only URL-encode basic characters like colons (`%3A`)
	// and spaces (`%20`).  The JSON constructed using this parameter is obviously flat.  If you want to
	// group properties together by their "usage type" (e.g.: `NAME_TYPE`, `PHONE_TYPE` or
	// `ADDRESS_TYPE`) then you would **also** prefix with the type (e.g.:
	// `HOME_PHONE_NUMBER:702-555-1212`).
	Attr []string
	// Optional parameter that can be specified zero or more times to indicate which
	// `SzAttributeSearchResultType`'s should be included in the search results.  If not specified then
	// all match types are included.  *NOTE*: This parameter is ignored unless the underlying native
	// Senzing API is version 2.4.1 or later.
	IncludeOnly []SzAttributeSearchResultType
	// Specifies the level of detail desired for the entity data.  Details for features of entities as
	// well as the related entities of entities are controlled by `featureMode`, `withInternalFeatures`,
	// and `withFeatureStats`.  If not specified the value defaults to `VERBOSE`. Possible values are:
	// * `BARE_MINIMAL` - The entities returned will include only their
	// entity ID's.  No record information is returned
	// and if related entities are included, they too will
	// only be described by their entity ID's and will
	// **not** include any matching info.
	// * `NETWORK_MINIMAL` - Identical to `BARE_MINIMAL` except in the case
	// of related entities being included they will
	// also include related matching info.
	// * `MINIMAL` - The entities returned will include at most their
	// entity ID's as well as identifiers for their
	// constituent records (i.e.: data source code and record
	// ID for each record).  This detail level is optimized for
	// the fastest possible processing time.
	// * `BRIEF` - Builds upon `MINIMAL` to add the entity name and related
	// entity match info when related entity match info when
	// related entities are included.  This detail level aims to
	// maintain as much speed as possible while providing names
	// and relationship information for rendering a graph.
	// * `SUMMARY` - Identical to `BRIEF` except that individual record
	// identifier information is excluded, leaving only the
	// record summary (i.e.: a record count by data source
	// code).  This reduces the size of the JSON document for
	// large entities with thousands of records.  It may take
	// longer to process than `BRIEF` but less data is
	// returned as well, speeding up network transfer times.
	// * `VERBOSE` - Combines `BRIEF` and `SUMMARY` and then adds the
	// original JSON data for each record, the record-level
	// matching info, as well as formatted record data.  NOTE:
	// the record-level matching info returned via "how" and
	// "why" is often more useful than that embedded in the
	// entity.  Further, the formatted record data, while
	// readable, is not formatted according to locale (i.e.:
	// address, name and date formatting may not appear as
	// expected to a user).
	DetailLevel OptSzDetailLevel
	// The method by which feature values should be included for entities returned in the response.  The
	// possible values are:
	// * `NONE` - Do not include any feature values -- this is the fastest
	// option from a performance perspective because feature
	// values do not have to be retrieved.
	// * `REPRESENTATIVE` - Include only a single representative value per
	// "unique" value of a feature.  If there are
	// multiple values that are near duplicates then
	// only one value is included and the others are
	// suppressed.
	// * `WITH_DUPLICATES` - ** (default value) ** Group near-duplicate
	// feature values and return a representative value
	// along with its near duplicate values.
	// * `ATTRIBUTED` - Same as `WITH_DUPLICATES` but with record-level
	// references attributing each feature to the record(s)
	// that provided it for the entity along with any
	// usage type that might have been associated with the
	// feature at the record level.
	FeatureMode OptSzFeatureMode
	// Set to `true` to include resolution statistics for features.  This defaults to `false`.
	WithFeatureStats OptBool
	// Set to `true` to include "expressed" features that are derived composite keys such as name + date
	// of birth keys.  This defaults to `false`.
	WithInternalFeatures OptBool
	// Whether (or not) to force the minimum entity detail in the response which will consist of nothing
	// more than an entity ID and record identifying information (i.e.: data source code and record ID)
	// for each constituent record of an entity.  Unlike `detailLevel=MINIMAL` setting this to `true`
	// precludes the addition of feature information via other parameters.  Setting this to `true`
	// provides the fastest response to an entity query operation because no additional data needs to be
	// retrieved other than what is directly accessible.  Setting this parameter to `true` overrules
	// other parameters governing the retrieval of features or related entities.
	ForceMinimal OptBool
	// Set to `true` to include partial information of related entities for the returned entities.  This
	// defaults to `false`.
	WithRelationships OptBool
	// Whether or not to include the raw JSON response from the underlying native API.  This raw response
	// may include additional details but lack some of the abstraction the standard response provides.
	// If true, then the 'rawData' field in the response will be a non-null value and contain the
	// additional details.
	WithRaw OptBool
}

func unpackSearchEntitiesByGetParams(packed middleware.Parameters) (params SearchEntitiesByGetParams) {
	{
		key := middleware.ParameterKey{
			Name: "attrs",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Attrs = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "attr",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Attr = v.([]string)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "includeOnly",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.IncludeOnly = v.([]SzAttributeSearchResultType)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "detailLevel",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.DetailLevel = v.(OptSzDetailLevel)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "featureMode",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.FeatureMode = v.(OptSzFeatureMode)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withFeatureStats",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithFeatureStats = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withInternalFeatures",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithInternalFeatures = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "forceMinimal",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ForceMinimal = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withRelationships",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithRelationships = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withRaw",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithRaw = v.(OptBool)
		}
	}
	return params
}

func decodeSearchEntitiesByGetParams(args [0]string, argsEscaped bool, r *http.Request) (params SearchEntitiesByGetParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: attrs.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "attrs",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAttrsVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAttrsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Attrs.SetTo(paramsDotAttrsVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "attrs",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: attr.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "attr",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotAttrVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotAttrVal = c
						return nil
					}(); err != nil {
						return err
					}
					params.Attr = append(params.Attr, paramsDotAttrVal)
					return nil
				})
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "attr",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: includeOnly.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "includeOnly",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotIncludeOnlyVal SzAttributeSearchResultType
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotIncludeOnlyVal = SzAttributeSearchResultType(c)
						return nil
					}(); err != nil {
						return err
					}
					params.IncludeOnly = append(params.IncludeOnly, paramsDotIncludeOnlyVal)
					return nil
				})
			}); err != nil {
				return err
			}
			if err := func() error {
				var failures []validate.FieldError
				for i, elem := range params.IncludeOnly {
					if err := func() error {
						if err := elem.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						failures = append(failures, validate.FieldError{
							Name:  fmt.Sprintf("[%d]", i),
							Error: err,
						})
					}
				}
				if len(failures) > 0 {
					return &validate.Error{Fields: failures}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "includeOnly",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: detailLevel.
	{
		val := SzDetailLevel("VERBOSE")
		params.DetailLevel.SetTo(val)
	}
	// Decode query: detailLevel.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "detailLevel",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDetailLevelVal SzDetailLevel
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDetailLevelVal = SzDetailLevel(c)
					return nil
				}(); err != nil {
					return err
				}
				params.DetailLevel.SetTo(paramsDotDetailLevelVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if params.DetailLevel.Set {
					if err := func() error {
						if err := params.DetailLevel.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "detailLevel",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: featureMode.
	{
		val := SzFeatureMode("WITH_DUPLICATES")
		params.FeatureMode.SetTo(val)
	}
	// Decode query: featureMode.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "featureMode",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFeatureModeVal SzFeatureMode
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFeatureModeVal = SzFeatureMode(c)
					return nil
				}(); err != nil {
					return err
				}
				params.FeatureMode.SetTo(paramsDotFeatureModeVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if params.FeatureMode.Set {
					if err := func() error {
						if err := params.FeatureMode.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "featureMode",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withFeatureStats.
	{
		val := bool(false)
		params.WithFeatureStats.SetTo(val)
	}
	// Decode query: withFeatureStats.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withFeatureStats",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithFeatureStatsVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithFeatureStatsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithFeatureStats.SetTo(paramsDotWithFeatureStatsVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withFeatureStats",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withInternalFeatures.
	{
		val := bool(false)
		params.WithInternalFeatures.SetTo(val)
	}
	// Decode query: withInternalFeatures.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withInternalFeatures",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithInternalFeaturesVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithInternalFeaturesVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithInternalFeatures.SetTo(paramsDotWithInternalFeaturesVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withInternalFeatures",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: forceMinimal.
	{
		val := bool(false)
		params.ForceMinimal.SetTo(val)
	}
	// Decode query: forceMinimal.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "forceMinimal",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotForceMinimalVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotForceMinimalVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ForceMinimal.SetTo(paramsDotForceMinimalVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "forceMinimal",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withRelationships.
	{
		val := bool(false)
		params.WithRelationships.SetTo(val)
	}
	// Decode query: withRelationships.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withRelationships",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithRelationshipsVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithRelationshipsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithRelationships.SetTo(paramsDotWithRelationshipsVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withRelationships",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withRaw.
	{
		val := bool(false)
		params.WithRaw.SetTo(val)
	}
	// Decode query: withRaw.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithRawVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithRawVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithRaw.SetTo(paramsDotWithRawVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withRaw",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// SearchEntitiesByPostParams is parameters of searchEntitiesByPost operation.
type SearchEntitiesByPostParams struct {
	// Optional parameter that can be specified zero or more times to indicate which
	// `SzAttributeSearchResultType`'s should be included in the search results.  If not specified then
	// all match types are included.  *NOTE*: This parameter is ignored unless the underlying native
	// Senzing API is version 2.4.1 or later.
	IncludeOnly []SzAttributeSearchResultType
	// Specifies the level of detail desired for the entity data.  Details for features of entities as
	// well as the related entities of entities are controlled by `featureMode`, `withInternalFeatures`,
	// and `withFeatureStats`.  If not specified the value defaults to `VERBOSE`. Possible values are:
	// * `BARE_MINIMAL` - The entities returned will include only their
	// entity ID's.  No record information is returned
	// and if related entities are included, they too will
	// only be described by their entity ID's and will
	// **not** include any matching info.
	// * `NETWORK_MINIMAL` - Identical to `BARE_MINIMAL` except in the case
	// of related entities being included they will
	// also include related matching info.
	// * `MINIMAL` - The entities returned will include at most their
	// entity ID's as well as identifiers for their
	// constituent records (i.e.: data source code and record
	// ID for each record).  This detail level is optimized for
	// the fastest possible processing time.
	// * `BRIEF` - Builds upon `MINIMAL` to add the entity name and related
	// entity match info when related entity match info when
	// related entities are included.  This detail level aims to
	// maintain as much speed as possible while providing names
	// and relationship information for rendering a graph.
	// * `SUMMARY` - Identical to `BRIEF` except that individual record
	// identifier information is excluded, leaving only the
	// record summary (i.e.: a record count by data source
	// code).  This reduces the size of the JSON document for
	// large entities with thousands of records.  It may take
	// longer to process than `BRIEF` but less data is
	// returned as well, speeding up network transfer times.
	// * `VERBOSE` - Combines `BRIEF` and `SUMMARY` and then adds the
	// original JSON data for each record, the record-level
	// matching info, as well as formatted record data.  NOTE:
	// the record-level matching info returned via "how" and
	// "why" is often more useful than that embedded in the
	// entity.  Further, the formatted record data, while
	// readable, is not formatted according to locale (i.e.:
	// address, name and date formatting may not appear as
	// expected to a user).
	DetailLevel OptSzDetailLevel
	// The method by which feature values should be included for entities returned in the response.  The
	// possible values are:
	// * `NONE` - Do not include any feature values -- this is the fastest
	// option from a performance perspective because feature
	// values do not have to be retrieved.
	// * `REPRESENTATIVE` - Include only a single representative value per
	// "unique" value of a feature.  If there are
	// multiple values that are near duplicates then
	// only one value is included and the others are
	// suppressed.
	// * `WITH_DUPLICATES` - ** (default value) ** Group near-duplicate
	// feature values and return a representative value
	// along with its near duplicate values.
	// * `ATTRIBUTED` - Same as `WITH_DUPLICATES` but with record-level
	// references attributing each feature to the record(s)
	// that provided it for the entity along with any
	// usage type that might have been associated with the
	// feature at the record level.
	FeatureMode OptSzFeatureMode
	// Set to `true` to include resolution statistics for features.  This defaults to `false`.
	WithFeatureStats OptBool
	// Set to `true` to include "expressed" features that are derived composite keys such as name + date
	// of birth keys.  This defaults to `false`.
	WithInternalFeatures OptBool
	// Whether (or not) to force the minimum entity detail in the response which will consist of nothing
	// more than an entity ID and record identifying information (i.e.: data source code and record ID)
	// for each constituent record of an entity.  Unlike `detailLevel=MINIMAL` setting this to `true`
	// precludes the addition of feature information via other parameters.  Setting this to `true`
	// provides the fastest response to an entity query operation because no additional data needs to be
	// retrieved other than what is directly accessible.  Setting this parameter to `true` overrules
	// other parameters governing the retrieval of features or related entities.
	ForceMinimal OptBool
	// Set to `true` to include partial information of related entities for the returned entities.  This
	// defaults to `false`.
	WithRelationships OptBool
	// Whether or not to include the raw JSON response from the underlying native API.  This raw response
	// may include additional details but lack some of the abstraction the standard response provides.
	// If true, then the 'rawData' field in the response will be a non-null value and contain the
	// additional details.
	WithRaw OptBool
}

func unpackSearchEntitiesByPostParams(packed middleware.Parameters) (params SearchEntitiesByPostParams) {
	{
		key := middleware.ParameterKey{
			Name: "includeOnly",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.IncludeOnly = v.([]SzAttributeSearchResultType)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "detailLevel",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.DetailLevel = v.(OptSzDetailLevel)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "featureMode",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.FeatureMode = v.(OptSzFeatureMode)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withFeatureStats",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithFeatureStats = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withInternalFeatures",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithInternalFeatures = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "forceMinimal",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ForceMinimal = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withRelationships",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithRelationships = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withRaw",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithRaw = v.(OptBool)
		}
	}
	return params
}

func decodeSearchEntitiesByPostParams(args [0]string, argsEscaped bool, r *http.Request) (params SearchEntitiesByPostParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: includeOnly.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "includeOnly",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotIncludeOnlyVal SzAttributeSearchResultType
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotIncludeOnlyVal = SzAttributeSearchResultType(c)
						return nil
					}(); err != nil {
						return err
					}
					params.IncludeOnly = append(params.IncludeOnly, paramsDotIncludeOnlyVal)
					return nil
				})
			}); err != nil {
				return err
			}
			if err := func() error {
				var failures []validate.FieldError
				for i, elem := range params.IncludeOnly {
					if err := func() error {
						if err := elem.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						failures = append(failures, validate.FieldError{
							Name:  fmt.Sprintf("[%d]", i),
							Error: err,
						})
					}
				}
				if len(failures) > 0 {
					return &validate.Error{Fields: failures}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "includeOnly",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: detailLevel.
	{
		val := SzDetailLevel("VERBOSE")
		params.DetailLevel.SetTo(val)
	}
	// Decode query: detailLevel.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "detailLevel",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDetailLevelVal SzDetailLevel
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDetailLevelVal = SzDetailLevel(c)
					return nil
				}(); err != nil {
					return err
				}
				params.DetailLevel.SetTo(paramsDotDetailLevelVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if params.DetailLevel.Set {
					if err := func() error {
						if err := params.DetailLevel.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "detailLevel",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: featureMode.
	{
		val := SzFeatureMode("WITH_DUPLICATES")
		params.FeatureMode.SetTo(val)
	}
	// Decode query: featureMode.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "featureMode",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFeatureModeVal SzFeatureMode
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFeatureModeVal = SzFeatureMode(c)
					return nil
				}(); err != nil {
					return err
				}
				params.FeatureMode.SetTo(paramsDotFeatureModeVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if params.FeatureMode.Set {
					if err := func() error {
						if err := params.FeatureMode.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "featureMode",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withFeatureStats.
	{
		val := bool(false)
		params.WithFeatureStats.SetTo(val)
	}
	// Decode query: withFeatureStats.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withFeatureStats",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithFeatureStatsVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithFeatureStatsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithFeatureStats.SetTo(paramsDotWithFeatureStatsVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withFeatureStats",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withInternalFeatures.
	{
		val := bool(false)
		params.WithInternalFeatures.SetTo(val)
	}
	// Decode query: withInternalFeatures.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withInternalFeatures",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithInternalFeaturesVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithInternalFeaturesVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithInternalFeatures.SetTo(paramsDotWithInternalFeaturesVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withInternalFeatures",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: forceMinimal.
	{
		val := bool(false)
		params.ForceMinimal.SetTo(val)
	}
	// Decode query: forceMinimal.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "forceMinimal",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotForceMinimalVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotForceMinimalVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ForceMinimal.SetTo(paramsDotForceMinimalVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "forceMinimal",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withRelationships.
	{
		val := bool(false)
		params.WithRelationships.SetTo(val)
	}
	// Decode query: withRelationships.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withRelationships",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithRelationshipsVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithRelationshipsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithRelationships.SetTo(paramsDotWithRelationshipsVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withRelationships",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withRaw.
	{
		val := bool(false)
		params.WithRaw.SetTo(val)
	}
	// Decode query: withRaw.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithRawVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithRawVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithRaw.SetTo(paramsDotWithRawVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withRaw",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// VersionParams is parameters of version operation.
type VersionParams struct {
	// Whether or not to include the raw JSON response from the underlying native API.  This raw response
	// may include additional details but lack some of the abstraction the standard response provides.
	// If true, then the 'rawData' field in the response will be a non-null value and contain the
	// additional details.
	WithRaw OptBool
}

func unpackVersionParams(packed middleware.Parameters) (params VersionParams) {
	{
		key := middleware.ParameterKey{
			Name: "withRaw",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithRaw = v.(OptBool)
		}
	}
	return params
}

func decodeVersionParams(args [0]string, argsEscaped bool, r *http.Request) (params VersionParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: withRaw.
	{
		val := bool(false)
		params.WithRaw.SetTo(val)
	}
	// Decode query: withRaw.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithRawVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithRawVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithRaw.SetTo(paramsDotWithRawVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withRaw",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// WhyEntitiesParams is parameters of whyEntities operation.
type WhyEntitiesParams struct {
	// The `SzEntityIdentifier` for the first entity as an entity ID or an encoded `SzRecordId` for the
	// constituent record.  Whatever format is used for the "entity1" parameter must match the format of
	// the "entity2" parameter.  NOTE: An encoded `SzRecordId` can EITHER be encoded as JSON or as a
	// delimited string where the first character is the delimiter and the remainder is parsed as a data
	// source prefix (up to the second occurrence of the delimiter) and a record ID suffix (all
	// characters after the second occurrence of the delimiter).  For example: `{"src":"PEOPLE",
	// "id":"12345ABC"}` or `:PEOPLE:12345ABC`.
	Entity1 string
	// The `SzEntityIdentifier` for the second entity as an entity ID or an encoded `SzRecordId` for the
	// constituent record.  Whatever format is used for the "entity2" parameter must match the format of
	// the "entity1" parameter.  NOTE: An encoded `SzRecordId` can EITHER be encoded as JSON or as a
	// delimited string where the first character is the delimiter and the remainder is parsed as a data
	// source prefix (up to the second occurrence of the delimiter) and a record ID suffix (all
	// characters after the second occurrence of the delimiter).  For example: `{"src":"PEOPLE",
	// "id":"12345ABC"}` or `:PEOPLE:12345ABC`.
	Entity2 string
	// Set to `true` to include partial information of related entities for the returned entities.  This
	// defaults to `false`.
	WithRelationships OptBool
	// Set to `false` to suppress resolution statistics for features.  This defaults to `true` for why
	// operations.
	WithFeatureStats OptBool
	// Set to `false` to suppress "expressed" features that are derived composite keys such as
	// `FULL_NAME` + `DATE_OF_BIRTH`.  This defaults to `true` for why operations.
	WithInternalFeatures OptBool
	// Specifies the level of detail desired for the entity data.  Details for features of entities as
	// well as the related entities of entities are controlled by `featureMode`, `withInternalFeatures`,
	// and `withFeatureStats`.  If not specified the value defaults to `VERBOSE`. Possible values are:
	// * `BARE_MINIMAL` - The entities returned will include only their
	// entity ID's.  No record information is returned
	// and if related entities are included, they too will
	// only be described by their entity ID's and will
	// **not** include any matching info.
	// * `NETWORK_MINIMAL` - Identical to `BARE_MINIMAL` except in the case
	// of related entities being included they will
	// also include related matching info.
	// * `MINIMAL` - The entities returned will include at most their
	// entity ID's as well as identifiers for their
	// constituent records (i.e.: data source code and record
	// ID for each record).  This detail level is optimized for
	// the fastest possible processing time.
	// * `BRIEF` - Builds upon `MINIMAL` to add the entity name and related
	// entity match info when related entity match info when
	// related entities are included.  This detail level aims to
	// maintain as much speed as possible while providing names
	// and relationship information for rendering a graph.
	// * `SUMMARY` - Identical to `BRIEF` except that individual record
	// identifier information is excluded, leaving only the
	// record summary (i.e.: a record count by data source
	// code).  This reduces the size of the JSON document for
	// large entities with thousands of records.  It may take
	// longer to process than `BRIEF` but less data is
	// returned as well, speeding up network transfer times.
	// * `VERBOSE` - Combines `BRIEF` and `SUMMARY` and then adds the
	// original JSON data for each record, the record-level
	// matching info, as well as formatted record data.  NOTE:
	// the record-level matching info returned via "how" and
	// "why" is often more useful than that embedded in the
	// entity.  Further, the formatted record data, while
	// readable, is not formatted according to locale (i.e.:
	// address, name and date formatting may not appear as
	// expected to a user).
	DetailLevel OptSzDetailLevel
	// The method by which feature values should be included for entities returned in the response.  The
	// possible values are:
	// * `NONE` - Do not include any feature values -- this is the fastest
	// option from a performance perspective because feature
	// values do not have to be retrieved.
	// * `REPRESENTATIVE` - Include only a single representative value per
	// "unique" value of a feature.  If there are
	// multiple values that are near duplicates then
	// only one value is included and the others are
	// suppressed.
	// * `WITH_DUPLICATES` - ** (default value) ** Group near-duplicate
	// feature values and return a representative value
	// along with its near duplicate values.
	// * `ATTRIBUTED` - Same as `WITH_DUPLICATES` but with record-level
	// references attributing each feature to the record(s)
	// that provided it for the entity along with any
	// usage type that might have been associated with the
	// feature at the record level.
	FeatureMode OptSzFeatureMode
	// Whether (or not) to force the minimum entity detail in the response which will consist of nothing
	// more than an entity ID and record identifying information (i.e.: data source code and record ID)
	// for each constituent record of an entity.  Unlike `detailLevel=MINIMAL` setting this to `true`
	// precludes the addition of feature information via other parameters.  Setting this to `true`
	// provides the fastest response to an entity query operation because no additional data needs to be
	// retrieved other than what is directly accessible.  Setting this parameter to `true` overrules
	// other parameters governing the retrieval of features or related entities.
	ForceMinimal OptBool
	// Whether or not to include the raw JSON response from the underlying native API.  This raw response
	// may include additional details but lack some of the abstraction the standard response provides.
	// If true, then the 'rawData' field in the response will be a non-null value and contain the
	// additional details.
	WithRaw OptBool
}

func unpackWhyEntitiesParams(packed middleware.Parameters) (params WhyEntitiesParams) {
	{
		key := middleware.ParameterKey{
			Name: "entity1",
			In:   "query",
		}
		params.Entity1 = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "entity2",
			In:   "query",
		}
		params.Entity2 = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "withRelationships",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithRelationships = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withFeatureStats",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithFeatureStats = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withInternalFeatures",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithInternalFeatures = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "detailLevel",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.DetailLevel = v.(OptSzDetailLevel)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "featureMode",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.FeatureMode = v.(OptSzFeatureMode)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "forceMinimal",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ForceMinimal = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withRaw",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithRaw = v.(OptBool)
		}
	}
	return params
}

func decodeWhyEntitiesParams(args [0]string, argsEscaped bool, r *http.Request) (params WhyEntitiesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: entity1.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "entity1",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Entity1 = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "entity1",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: entity2.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "entity2",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Entity2 = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "entity2",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withRelationships.
	{
		val := bool(false)
		params.WithRelationships.SetTo(val)
	}
	// Decode query: withRelationships.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withRelationships",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithRelationshipsVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithRelationshipsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithRelationships.SetTo(paramsDotWithRelationshipsVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withRelationships",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withFeatureStats.
	{
		val := bool(true)
		params.WithFeatureStats.SetTo(val)
	}
	// Decode query: withFeatureStats.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withFeatureStats",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithFeatureStatsVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithFeatureStatsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithFeatureStats.SetTo(paramsDotWithFeatureStatsVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withFeatureStats",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withInternalFeatures.
	{
		val := bool(true)
		params.WithInternalFeatures.SetTo(val)
	}
	// Decode query: withInternalFeatures.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withInternalFeatures",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithInternalFeaturesVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithInternalFeaturesVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithInternalFeatures.SetTo(paramsDotWithInternalFeaturesVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withInternalFeatures",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: detailLevel.
	{
		val := SzDetailLevel("VERBOSE")
		params.DetailLevel.SetTo(val)
	}
	// Decode query: detailLevel.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "detailLevel",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDetailLevelVal SzDetailLevel
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDetailLevelVal = SzDetailLevel(c)
					return nil
				}(); err != nil {
					return err
				}
				params.DetailLevel.SetTo(paramsDotDetailLevelVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if params.DetailLevel.Set {
					if err := func() error {
						if err := params.DetailLevel.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "detailLevel",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: featureMode.
	{
		val := SzFeatureMode("WITH_DUPLICATES")
		params.FeatureMode.SetTo(val)
	}
	// Decode query: featureMode.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "featureMode",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFeatureModeVal SzFeatureMode
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFeatureModeVal = SzFeatureMode(c)
					return nil
				}(); err != nil {
					return err
				}
				params.FeatureMode.SetTo(paramsDotFeatureModeVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if params.FeatureMode.Set {
					if err := func() error {
						if err := params.FeatureMode.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "featureMode",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: forceMinimal.
	{
		val := bool(false)
		params.ForceMinimal.SetTo(val)
	}
	// Decode query: forceMinimal.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "forceMinimal",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotForceMinimalVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotForceMinimalVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ForceMinimal.SetTo(paramsDotForceMinimalVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "forceMinimal",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withRaw.
	{
		val := bool(false)
		params.WithRaw.SetTo(val)
	}
	// Decode query: withRaw.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithRawVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithRawVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithRaw.SetTo(paramsDotWithRawVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withRaw",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// WhyEntityByEntityIDParams is parameters of whyEntityByEntityID operation.
type WhyEntityByEntityIDParams struct {
	// The unique numeric ID that identifies that entity being requested.
	EntityId int64
	// Set to `true` to include partial information of related entities for the returned entities.  This
	// defaults to `false`.
	WithRelationships OptBool
	// Set to `false` to suppress resolution statistics for features.  This defaults to `true` for why
	// operations.
	WithFeatureStats OptBool
	// Set to `false` to suppress "expressed" features that are derived composite keys such as
	// `FULL_NAME` + `DATE_OF_BIRTH`.  This defaults to `true` for why operations.
	WithInternalFeatures OptBool
	// Specifies the level of detail desired for the entity data.  Details for features of entities as
	// well as the related entities of entities are controlled by `featureMode`, `withInternalFeatures`,
	// and `withFeatureStats`.  If not specified the value defaults to `VERBOSE`. Possible values are:
	// * `BARE_MINIMAL` - The entities returned will include only their
	// entity ID's.  No record information is returned
	// and if related entities are included, they too will
	// only be described by their entity ID's and will
	// **not** include any matching info.
	// * `NETWORK_MINIMAL` - Identical to `BARE_MINIMAL` except in the case
	// of related entities being included they will
	// also include related matching info.
	// * `MINIMAL` - The entities returned will include at most their
	// entity ID's as well as identifiers for their
	// constituent records (i.e.: data source code and record
	// ID for each record).  This detail level is optimized for
	// the fastest possible processing time.
	// * `BRIEF` - Builds upon `MINIMAL` to add the entity name and related
	// entity match info when related entity match info when
	// related entities are included.  This detail level aims to
	// maintain as much speed as possible while providing names
	// and relationship information for rendering a graph.
	// * `SUMMARY` - Identical to `BRIEF` except that individual record
	// identifier information is excluded, leaving only the
	// record summary (i.e.: a record count by data source
	// code).  This reduces the size of the JSON document for
	// large entities with thousands of records.  It may take
	// longer to process than `BRIEF` but less data is
	// returned as well, speeding up network transfer times.
	// * `VERBOSE` - Combines `BRIEF` and `SUMMARY` and then adds the
	// original JSON data for each record, the record-level
	// matching info, as well as formatted record data.  NOTE:
	// the record-level matching info returned via "how" and
	// "why" is often more useful than that embedded in the
	// entity.  Further, the formatted record data, while
	// readable, is not formatted according to locale (i.e.:
	// address, name and date formatting may not appear as
	// expected to a user).
	DetailLevel OptSzDetailLevel
	// The method by which feature values should be included for entities returned in the response.  The
	// possible values are:
	// * `NONE` - Do not include any feature values -- this is the fastest
	// option from a performance perspective because feature
	// values do not have to be retrieved.
	// * `REPRESENTATIVE` - Include only a single representative value per
	// "unique" value of a feature.  If there are
	// multiple values that are near duplicates then
	// only one value is included and the others are
	// suppressed.
	// * `WITH_DUPLICATES` - ** (default value) ** Group near-duplicate
	// feature values and return a representative value
	// along with its near duplicate values.
	// * `ATTRIBUTED` - Same as `WITH_DUPLICATES` but with record-level
	// references attributing each feature to the record(s)
	// that provided it for the entity along with any
	// usage type that might have been associated with the
	// feature at the record level.
	FeatureMode OptSzFeatureMode
	// Whether (or not) to force the minimum entity detail in the response which will consist of nothing
	// more than an entity ID and record identifying information (i.e.: data source code and record ID)
	// for each constituent record of an entity.  Unlike `detailLevel=MINIMAL` setting this to `true`
	// precludes the addition of feature information via other parameters.  Setting this to `true`
	// provides the fastest response to an entity query operation because no additional data needs to be
	// retrieved other than what is directly accessible.  Setting this parameter to `true` overrules
	// other parameters governing the retrieval of features or related entities.
	ForceMinimal OptBool
	// Whether or not to include the raw JSON response from the underlying native API.  This raw response
	// may include additional details but lack some of the abstraction the standard response provides.
	// If true, then the 'rawData' field in the response will be a non-null value and contain the
	// additional details.
	WithRaw OptBool
}

func unpackWhyEntityByEntityIDParams(packed middleware.Parameters) (params WhyEntityByEntityIDParams) {
	{
		key := middleware.ParameterKey{
			Name: "entityId",
			In:   "path",
		}
		params.EntityId = packed[key].(int64)
	}
	{
		key := middleware.ParameterKey{
			Name: "withRelationships",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithRelationships = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withFeatureStats",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithFeatureStats = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withInternalFeatures",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithInternalFeatures = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "detailLevel",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.DetailLevel = v.(OptSzDetailLevel)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "featureMode",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.FeatureMode = v.(OptSzFeatureMode)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "forceMinimal",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ForceMinimal = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withRaw",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithRaw = v.(OptBool)
		}
	}
	return params
}

func decodeWhyEntityByEntityIDParams(args [1]string, argsEscaped bool, r *http.Request) (params WhyEntityByEntityIDParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: entityId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "entityId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt64(val)
				if err != nil {
					return err
				}

				params.EntityId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "entityId",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for query: withRelationships.
	{
		val := bool(false)
		params.WithRelationships.SetTo(val)
	}
	// Decode query: withRelationships.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withRelationships",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithRelationshipsVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithRelationshipsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithRelationships.SetTo(paramsDotWithRelationshipsVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withRelationships",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withFeatureStats.
	{
		val := bool(true)
		params.WithFeatureStats.SetTo(val)
	}
	// Decode query: withFeatureStats.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withFeatureStats",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithFeatureStatsVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithFeatureStatsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithFeatureStats.SetTo(paramsDotWithFeatureStatsVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withFeatureStats",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withInternalFeatures.
	{
		val := bool(true)
		params.WithInternalFeatures.SetTo(val)
	}
	// Decode query: withInternalFeatures.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withInternalFeatures",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithInternalFeaturesVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithInternalFeaturesVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithInternalFeatures.SetTo(paramsDotWithInternalFeaturesVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withInternalFeatures",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: detailLevel.
	{
		val := SzDetailLevel("VERBOSE")
		params.DetailLevel.SetTo(val)
	}
	// Decode query: detailLevel.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "detailLevel",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDetailLevelVal SzDetailLevel
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDetailLevelVal = SzDetailLevel(c)
					return nil
				}(); err != nil {
					return err
				}
				params.DetailLevel.SetTo(paramsDotDetailLevelVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if params.DetailLevel.Set {
					if err := func() error {
						if err := params.DetailLevel.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "detailLevel",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: featureMode.
	{
		val := SzFeatureMode("WITH_DUPLICATES")
		params.FeatureMode.SetTo(val)
	}
	// Decode query: featureMode.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "featureMode",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFeatureModeVal SzFeatureMode
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFeatureModeVal = SzFeatureMode(c)
					return nil
				}(); err != nil {
					return err
				}
				params.FeatureMode.SetTo(paramsDotFeatureModeVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if params.FeatureMode.Set {
					if err := func() error {
						if err := params.FeatureMode.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "featureMode",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: forceMinimal.
	{
		val := bool(false)
		params.ForceMinimal.SetTo(val)
	}
	// Decode query: forceMinimal.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "forceMinimal",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotForceMinimalVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotForceMinimalVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ForceMinimal.SetTo(paramsDotForceMinimalVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "forceMinimal",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withRaw.
	{
		val := bool(false)
		params.WithRaw.SetTo(val)
	}
	// Decode query: withRaw.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithRawVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithRawVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithRaw.SetTo(paramsDotWithRawVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withRaw",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// WhyEntityByRecordIDParams is parameters of whyEntityByRecordID operation.
type WhyEntityByRecordIDParams struct {
	// The data source code identifying the data source.
	DataSourceCode string
	// The identifier that uniquely identifies the requested record within a given data source.  This may
	// have been specified when the record was loaded or generated automatically.
	RecordId string
	// Set to `true` to include partial information of related entities for the returned entities.  This
	// defaults to `false`.
	WithRelationships OptBool
	// Set to `false` to suppress resolution statistics for features.  This defaults to `true` for why
	// operations.
	WithFeatureStats OptBool
	// Set to `false` to suppress "expressed" features that are derived composite keys such as
	// `FULL_NAME` + `DATE_OF_BIRTH`.  This defaults to `true` for why operations.
	WithInternalFeatures OptBool
	// Specifies the level of detail desired for the entity data.  Details for features of entities as
	// well as the related entities of entities are controlled by `featureMode`, `withInternalFeatures`,
	// and `withFeatureStats`.  If not specified the value defaults to `VERBOSE`. Possible values are:
	// * `BARE_MINIMAL` - The entities returned will include only their
	// entity ID's.  No record information is returned
	// and if related entities are included, they too will
	// only be described by their entity ID's and will
	// **not** include any matching info.
	// * `NETWORK_MINIMAL` - Identical to `BARE_MINIMAL` except in the case
	// of related entities being included they will
	// also include related matching info.
	// * `MINIMAL` - The entities returned will include at most their
	// entity ID's as well as identifiers for their
	// constituent records (i.e.: data source code and record
	// ID for each record).  This detail level is optimized for
	// the fastest possible processing time.
	// * `BRIEF` - Builds upon `MINIMAL` to add the entity name and related
	// entity match info when related entity match info when
	// related entities are included.  This detail level aims to
	// maintain as much speed as possible while providing names
	// and relationship information for rendering a graph.
	// * `SUMMARY` - Identical to `BRIEF` except that individual record
	// identifier information is excluded, leaving only the
	// record summary (i.e.: a record count by data source
	// code).  This reduces the size of the JSON document for
	// large entities with thousands of records.  It may take
	// longer to process than `BRIEF` but less data is
	// returned as well, speeding up network transfer times.
	// * `VERBOSE` - Combines `BRIEF` and `SUMMARY` and then adds the
	// original JSON data for each record, the record-level
	// matching info, as well as formatted record data.  NOTE:
	// the record-level matching info returned via "how" and
	// "why" is often more useful than that embedded in the
	// entity.  Further, the formatted record data, while
	// readable, is not formatted according to locale (i.e.:
	// address, name and date formatting may not appear as
	// expected to a user).
	DetailLevel OptSzDetailLevel
	// The method by which feature values should be included for entities returned in the response.  The
	// possible values are:
	// * `NONE` - Do not include any feature values -- this is the fastest
	// option from a performance perspective because feature
	// values do not have to be retrieved.
	// * `REPRESENTATIVE` - Include only a single representative value per
	// "unique" value of a feature.  If there are
	// multiple values that are near duplicates then
	// only one value is included and the others are
	// suppressed.
	// * `WITH_DUPLICATES` - ** (default value) ** Group near-duplicate
	// feature values and return a representative value
	// along with its near duplicate values.
	// * `ATTRIBUTED` - Same as `WITH_DUPLICATES` but with record-level
	// references attributing each feature to the record(s)
	// that provided it for the entity along with any
	// usage type that might have been associated with the
	// feature at the record level.
	FeatureMode OptSzFeatureMode
	// Whether (or not) to force the minimum entity detail in the response which will consist of nothing
	// more than an entity ID and record identifying information (i.e.: data source code and record ID)
	// for each constituent record of an entity.  Unlike `detailLevel=MINIMAL` setting this to `true`
	// precludes the addition of feature information via other parameters.  Setting this to `true`
	// provides the fastest response to an entity query operation because no additional data needs to be
	// retrieved other than what is directly accessible.  Setting this parameter to `true` overrules
	// other parameters governing the retrieval of features or related entities.
	ForceMinimal OptBool
	// Whether or not to include the raw JSON response from the underlying native API.  This raw response
	// may include additional details but lack some of the abstraction the standard response provides.
	// If true, then the 'rawData' field in the response will be a non-null value and contain the
	// additional details.
	WithRaw OptBool
}

func unpackWhyEntityByRecordIDParams(packed middleware.Parameters) (params WhyEntityByRecordIDParams) {
	{
		key := middleware.ParameterKey{
			Name: "dataSourceCode",
			In:   "path",
		}
		params.DataSourceCode = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "recordId",
			In:   "path",
		}
		params.RecordId = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "withRelationships",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithRelationships = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withFeatureStats",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithFeatureStats = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withInternalFeatures",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithInternalFeatures = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "detailLevel",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.DetailLevel = v.(OptSzDetailLevel)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "featureMode",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.FeatureMode = v.(OptSzFeatureMode)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "forceMinimal",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ForceMinimal = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withRaw",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithRaw = v.(OptBool)
		}
	}
	return params
}

func decodeWhyEntityByRecordIDParams(args [2]string, argsEscaped bool, r *http.Request) (params WhyEntityByRecordIDParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: dataSourceCode.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "dataSourceCode",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DataSourceCode = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "dataSourceCode",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: recordId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "recordId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.RecordId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "recordId",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for query: withRelationships.
	{
		val := bool(false)
		params.WithRelationships.SetTo(val)
	}
	// Decode query: withRelationships.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withRelationships",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithRelationshipsVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithRelationshipsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithRelationships.SetTo(paramsDotWithRelationshipsVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withRelationships",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withFeatureStats.
	{
		val := bool(true)
		params.WithFeatureStats.SetTo(val)
	}
	// Decode query: withFeatureStats.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withFeatureStats",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithFeatureStatsVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithFeatureStatsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithFeatureStats.SetTo(paramsDotWithFeatureStatsVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withFeatureStats",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withInternalFeatures.
	{
		val := bool(true)
		params.WithInternalFeatures.SetTo(val)
	}
	// Decode query: withInternalFeatures.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withInternalFeatures",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithInternalFeaturesVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithInternalFeaturesVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithInternalFeatures.SetTo(paramsDotWithInternalFeaturesVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withInternalFeatures",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: detailLevel.
	{
		val := SzDetailLevel("VERBOSE")
		params.DetailLevel.SetTo(val)
	}
	// Decode query: detailLevel.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "detailLevel",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDetailLevelVal SzDetailLevel
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDetailLevelVal = SzDetailLevel(c)
					return nil
				}(); err != nil {
					return err
				}
				params.DetailLevel.SetTo(paramsDotDetailLevelVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if params.DetailLevel.Set {
					if err := func() error {
						if err := params.DetailLevel.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "detailLevel",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: featureMode.
	{
		val := SzFeatureMode("WITH_DUPLICATES")
		params.FeatureMode.SetTo(val)
	}
	// Decode query: featureMode.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "featureMode",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFeatureModeVal SzFeatureMode
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFeatureModeVal = SzFeatureMode(c)
					return nil
				}(); err != nil {
					return err
				}
				params.FeatureMode.SetTo(paramsDotFeatureModeVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if params.FeatureMode.Set {
					if err := func() error {
						if err := params.FeatureMode.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "featureMode",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: forceMinimal.
	{
		val := bool(false)
		params.ForceMinimal.SetTo(val)
	}
	// Decode query: forceMinimal.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "forceMinimal",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotForceMinimalVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotForceMinimalVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ForceMinimal.SetTo(paramsDotForceMinimalVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "forceMinimal",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withRaw.
	{
		val := bool(false)
		params.WithRaw.SetTo(val)
	}
	// Decode query: withRaw.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithRawVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithRawVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithRaw.SetTo(paramsDotWithRawVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withRaw",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// WhyRecordsParams is parameters of whyRecords operation.
type WhyRecordsParams struct {
	// The data source for the first record.
	DataSource1 string
	// The record ID for the first record.
	RecordId1 string
	// The data source for the second record.
	DataSource2 string
	// The data source for the second record.
	RecordId2 string
	// Set to `true` to include partial information of related entities for the returned entities.  This
	// defaults to `false`.
	WithRelationships OptBool
	// Set to `false` to suppress resolution statistics for features.  This defaults to `true` for why
	// operations.
	WithFeatureStats OptBool
	// Set to `false` to suppress "expressed" features that are derived composite keys such as
	// `FULL_NAME` + `DATE_OF_BIRTH`.  This defaults to `true` for why operations.
	WithInternalFeatures OptBool
	// Specifies the level of detail desired for the entity data.  Details for features of entities as
	// well as the related entities of entities are controlled by `featureMode`, `withInternalFeatures`,
	// and `withFeatureStats`.  If not specified the value defaults to `VERBOSE`. Possible values are:
	// * `BARE_MINIMAL` - The entities returned will include only their
	// entity ID's.  No record information is returned
	// and if related entities are included, they too will
	// only be described by their entity ID's and will
	// **not** include any matching info.
	// * `NETWORK_MINIMAL` - Identical to `BARE_MINIMAL` except in the case
	// of related entities being included they will
	// also include related matching info.
	// * `MINIMAL` - The entities returned will include at most their
	// entity ID's as well as identifiers for their
	// constituent records (i.e.: data source code and record
	// ID for each record).  This detail level is optimized for
	// the fastest possible processing time.
	// * `BRIEF` - Builds upon `MINIMAL` to add the entity name and related
	// entity match info when related entity match info when
	// related entities are included.  This detail level aims to
	// maintain as much speed as possible while providing names
	// and relationship information for rendering a graph.
	// * `SUMMARY` - Identical to `BRIEF` except that individual record
	// identifier information is excluded, leaving only the
	// record summary (i.e.: a record count by data source
	// code).  This reduces the size of the JSON document for
	// large entities with thousands of records.  It may take
	// longer to process than `BRIEF` but less data is
	// returned as well, speeding up network transfer times.
	// * `VERBOSE` - Combines `BRIEF` and `SUMMARY` and then adds the
	// original JSON data for each record, the record-level
	// matching info, as well as formatted record data.  NOTE:
	// the record-level matching info returned via "how" and
	// "why" is often more useful than that embedded in the
	// entity.  Further, the formatted record data, while
	// readable, is not formatted according to locale (i.e.:
	// address, name and date formatting may not appear as
	// expected to a user).
	DetailLevel OptSzDetailLevel
	// The method by which feature values should be included for entities returned in the response.  The
	// possible values are:
	// * `NONE` - Do not include any feature values -- this is the fastest
	// option from a performance perspective because feature
	// values do not have to be retrieved.
	// * `REPRESENTATIVE` - Include only a single representative value per
	// "unique" value of a feature.  If there are
	// multiple values that are near duplicates then
	// only one value is included and the others are
	// suppressed.
	// * `WITH_DUPLICATES` - ** (default value) ** Group near-duplicate
	// feature values and return a representative value
	// along with its near duplicate values.
	// * `ATTRIBUTED` - Same as `WITH_DUPLICATES` but with record-level
	// references attributing each feature to the record(s)
	// that provided it for the entity along with any
	// usage type that might have been associated with the
	// feature at the record level.
	FeatureMode OptSzFeatureMode
	// Whether (or not) to force the minimum entity detail in the response which will consist of nothing
	// more than an entity ID and record identifying information (i.e.: data source code and record ID)
	// for each constituent record of an entity.  Unlike `detailLevel=MINIMAL` setting this to `true`
	// precludes the addition of feature information via other parameters.  Setting this to `true`
	// provides the fastest response to an entity query operation because no additional data needs to be
	// retrieved other than what is directly accessible.  Setting this parameter to `true` overrules
	// other parameters governing the retrieval of features or related entities.
	ForceMinimal OptBool
	// Whether or not to include the raw JSON response from the underlying native API.  This raw response
	// may include additional details but lack some of the abstraction the standard response provides.
	// If true, then the 'rawData' field in the response will be a non-null value and contain the
	// additional details.
	WithRaw OptBool
}

func unpackWhyRecordsParams(packed middleware.Parameters) (params WhyRecordsParams) {
	{
		key := middleware.ParameterKey{
			Name: "dataSource1",
			In:   "query",
		}
		params.DataSource1 = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "recordId1",
			In:   "query",
		}
		params.RecordId1 = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "dataSource2",
			In:   "query",
		}
		params.DataSource2 = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "recordId2",
			In:   "query",
		}
		params.RecordId2 = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "withRelationships",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithRelationships = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withFeatureStats",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithFeatureStats = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withInternalFeatures",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithInternalFeatures = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "detailLevel",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.DetailLevel = v.(OptSzDetailLevel)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "featureMode",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.FeatureMode = v.(OptSzFeatureMode)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "forceMinimal",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ForceMinimal = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "withRaw",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.WithRaw = v.(OptBool)
		}
	}
	return params
}

func decodeWhyRecordsParams(args [0]string, argsEscaped bool, r *http.Request) (params WhyRecordsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: dataSource1.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "dataSource1",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DataSource1 = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "dataSource1",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: recordId1.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "recordId1",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.RecordId1 = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "recordId1",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: dataSource2.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "dataSource2",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.DataSource2 = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "dataSource2",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: recordId2.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "recordId2",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.RecordId2 = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "recordId2",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withRelationships.
	{
		val := bool(false)
		params.WithRelationships.SetTo(val)
	}
	// Decode query: withRelationships.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withRelationships",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithRelationshipsVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithRelationshipsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithRelationships.SetTo(paramsDotWithRelationshipsVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withRelationships",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withFeatureStats.
	{
		val := bool(true)
		params.WithFeatureStats.SetTo(val)
	}
	// Decode query: withFeatureStats.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withFeatureStats",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithFeatureStatsVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithFeatureStatsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithFeatureStats.SetTo(paramsDotWithFeatureStatsVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withFeatureStats",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withInternalFeatures.
	{
		val := bool(true)
		params.WithInternalFeatures.SetTo(val)
	}
	// Decode query: withInternalFeatures.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withInternalFeatures",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithInternalFeaturesVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithInternalFeaturesVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithInternalFeatures.SetTo(paramsDotWithInternalFeaturesVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withInternalFeatures",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: detailLevel.
	{
		val := SzDetailLevel("VERBOSE")
		params.DetailLevel.SetTo(val)
	}
	// Decode query: detailLevel.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "detailLevel",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDetailLevelVal SzDetailLevel
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDetailLevelVal = SzDetailLevel(c)
					return nil
				}(); err != nil {
					return err
				}
				params.DetailLevel.SetTo(paramsDotDetailLevelVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if params.DetailLevel.Set {
					if err := func() error {
						if err := params.DetailLevel.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "detailLevel",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: featureMode.
	{
		val := SzFeatureMode("WITH_DUPLICATES")
		params.FeatureMode.SetTo(val)
	}
	// Decode query: featureMode.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "featureMode",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFeatureModeVal SzFeatureMode
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFeatureModeVal = SzFeatureMode(c)
					return nil
				}(); err != nil {
					return err
				}
				params.FeatureMode.SetTo(paramsDotFeatureModeVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if params.FeatureMode.Set {
					if err := func() error {
						if err := params.FeatureMode.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "featureMode",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: forceMinimal.
	{
		val := bool(false)
		params.ForceMinimal.SetTo(val)
	}
	// Decode query: forceMinimal.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "forceMinimal",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotForceMinimalVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotForceMinimalVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ForceMinimal.SetTo(paramsDotForceMinimalVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "forceMinimal",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: withRaw.
	{
		val := bool(false)
		params.WithRaw.SetTo(val)
	}
	// Decode query: withRaw.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "withRaw",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotWithRawVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotWithRawVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.WithRaw.SetTo(paramsDotWithRawVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "withRaw",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}
