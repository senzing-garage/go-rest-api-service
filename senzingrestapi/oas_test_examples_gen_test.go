// Code generated by ogen, DO NOT EDIT.

package senzingrestapi

import (
	"fmt"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/validate"

	std "encoding/json"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestAddDataSourcesApplicationJSONForbidden_EncodeDecode(t *testing.T) {
	var typ AddDataSourcesApplicationJSONForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddDataSourcesApplicationJSONForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddDataSourcesApplicationJSONInternalServerError_EncodeDecode(t *testing.T) {
	var typ AddDataSourcesApplicationJSONInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddDataSourcesApplicationJSONInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddDataSourcesReqApplicationJSON_EncodeDecode(t *testing.T) {
	var typ AddDataSourcesReqApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddDataSourcesReqApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestAddDataSourcesReqApplicationJSON_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: `[{"dataSourceCode": "CUSTOMERS"}]`},
		{Input: `["CUSTOMERS", "EMPLOYEES"]`},
		{Input: `["CUSTOMERS"]`},
		{Input: `["CUSTOMERS", { "dataSourceCode": "EMPLOYEES"}, { "dataSourceCode": "VENDOR", "dataSourceId": 1002}]`},
		{Input: `[{"dataSourceCode": "CUSTOMERS", "dataSourceId": 1000}, { "dataSourceCode": "EMPLOYEES", "dataSourceId": 1001}]`},
		{Input: `[{"dataSourceCode": "CUSTOMERS", "dataSourceId": 1000}]`},
		{Input: `"CUSTOMERS"`},
		{Input: `{"dataSourceCode": "CUSTOMERS"}`},
		{Input: `{"dataSourceCode": "CUSTOMERS", "dataSourceId": 1000}`},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ AddDataSourcesReqApplicationJSON

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 AddDataSourcesReqApplicationJSON
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestAddRecordApplicationJSONBadRequest_EncodeDecode(t *testing.T) {
	var typ AddRecordApplicationJSONBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddRecordApplicationJSONBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddRecordApplicationJSONForbidden_EncodeDecode(t *testing.T) {
	var typ AddRecordApplicationJSONForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddRecordApplicationJSONForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddRecordApplicationJSONInternalServerError_EncodeDecode(t *testing.T) {
	var typ AddRecordApplicationJSONInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddRecordApplicationJSONInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddRecordApplicationJSONNotFound_EncodeDecode(t *testing.T) {
	var typ AddRecordApplicationJSONNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddRecordApplicationJSONNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddRecordReq_EncodeDecode(t *testing.T) {
	var typ AddRecordReq
	typ = make(AddRecordReq)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddRecordReq
	typ2 = make(AddRecordReq)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestAddRecordReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: `{"NAMES": [{"NAME_FIRST": "JANE", "NAME_LAST": "SCHMOE" }],"PHONE_NUMBERS": [{"PHONE_NUMBER": "559-555-1212"}],"ADDRESSES": [{"ADDR_LINE1":"653 STATE ROUTE 7","ADDR_CITY":"FRESNO","ADDR_STATE":"CA","ADDR_POSTAL_CODE":"55073-1234"}]}`},
		{Input: `{"NAMES": [{"NAME_TYPE": "PRIMARY", "NAME_FIRST": "JANE", "NAME_LAST": "SCHMOE"}, { "NAME_TYPE": "MAIDEN", "NAME_FIRST": "JANE", "NAME_LAST": "SMITH" } ], "PHONE_NUMBERS": [ { "PHONE_TYPE": "HOME", "PHONE_NUMBER": "559-555-1212" }, { "PHONE_TYPE": "WORK", "PHONE_NUMBER": "559-555-1414" } ], "ADDRESSES": [ { "ADDR_TYPE": "HOME", "ADDR_LINE1": "653 STATE ROUTE 7", "ADDR_CITY": "FRESNO", "ADDR_STATE": "CA", "ADDR_POSTAL_CODE": "55073-1234" }, { "ADDR_TYPE": "WORK", "ADDR_LINE1": "701 E MAIN STREET", "ADDR_CITY": "FOWLER", "ADDR_STATE": "CA", "ADDR_POSTAL_CODE": "93625"}]}`},
		{Input: `{"NAME_FIRST": "JANE", "NAME_LAST": "SCHMOE", "HOME_PHONE_NUMBER": "559-555-1212", "WORK_PHONE_NUMBER": "559-555-1414", "HOME_ADDR_LINE1": "653 STATE ROUTE 7", "HOME_ADDR_CITY": "FRESNO", "HOME_ADDR_STATE": "CA", "HOME_ADDR_POSTAL_CODE": "55073-1234", "WORK_ADDR_LINE1": "701 E MAIN STREET", "WORK_ADDR_CITY": "FOWLER", "WORK_ADDR_STATE": "CA", "WORK_ADDR_POSTAL_CODE": "93625"}`},
		{Input: `{"NAME_FIRST": "JANE", "NAME_LAST": "SCHMOE", "PHONE_NUMBER": "559-555-1212", "ADDR_LINE1": "653 STATE ROUTE 7", "ADDR_CITY": "FRESNO", "ADDR_STATE": "CA", "ADDR_POSTAL_CODE": "55073-1234"}`},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ AddRecordReq
			typ = make(AddRecordReq)

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 AddRecordReq
			typ2 = make(AddRecordReq)
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestAddRecordWithReturnedRecordIdApplicationJSONBadRequest_EncodeDecode(t *testing.T) {
	var typ AddRecordWithReturnedRecordIdApplicationJSONBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddRecordWithReturnedRecordIdApplicationJSONBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddRecordWithReturnedRecordIdApplicationJSONForbidden_EncodeDecode(t *testing.T) {
	var typ AddRecordWithReturnedRecordIdApplicationJSONForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddRecordWithReturnedRecordIdApplicationJSONForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddRecordWithReturnedRecordIdApplicationJSONInternalServerError_EncodeDecode(t *testing.T) {
	var typ AddRecordWithReturnedRecordIdApplicationJSONInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddRecordWithReturnedRecordIdApplicationJSONInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddRecordWithReturnedRecordIdApplicationJSONNotFound_EncodeDecode(t *testing.T) {
	var typ AddRecordWithReturnedRecordIdApplicationJSONNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddRecordWithReturnedRecordIdApplicationJSONNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddRecordWithReturnedRecordIdReq_EncodeDecode(t *testing.T) {
	var typ AddRecordWithReturnedRecordIdReq
	typ = make(AddRecordWithReturnedRecordIdReq)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddRecordWithReturnedRecordIdReq
	typ2 = make(AddRecordWithReturnedRecordIdReq)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestAddRecordWithReturnedRecordIdReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: `{"NAMES": [{"NAME_FIRST": "JANE", "NAME_LAST": "SCHMOE"}], "PHONE_NUMBERS": [{"PHONE_NUMBER": "559-555-1212"}], "ADDRESSES": [{"ADDR_LINE1": "653 STATE ROUTE 7", "ADDR_CITY": "FRESNO", "ADDR_STATE": "CA", "ADDR_POSTAL_CODE": "55073-1234"}]}`},
		{Input: `{"NAMES": [{"NAME_TYPE": "PRIMARY", "NAME_FIRST": "JANE", "NAME_LAST": "SCHMOE"}, {"NAME_TYPE": "MAIDEN", "NAME_FIRST": "JANE", "NAME_LAST": "SMITH"}], "PHONE_NUMBERS": [{"PHONE_TYPE": "HOME", "PHONE_NUMBER": "559-555-1212"}, {"PHONE_TYPE": "WORK", "PHONE_NUMBER": "559-555-1414"}], "ADDRESSES": [{"ADDR_TYPE": "HOME", "ADDR_LINE1": "653 STATE ROUTE 7", "ADDR_CITY": "FRESNO", "ADDR_STATE": "CA", "ADDR_POSTAL_CODE": "55073-1234" }, {"ADDR_TYPE": "WORK", "ADDR_LINE1": "701 E MAIN STREET", "ADDR_CITY": "FOWLER", "ADDR_STATE": "CA", "ADDR_POSTAL_CODE": "93625"}]}`},
		{Input: `{"NAME_FIRST": "JANE", "NAME_LAST": "SCHMOE", "HOME_PHONE_NUMBER": "559-555-1212", "WORK_PHONE_NUMBER": "559-555-1414", "HOME_ADDR_LINE1": "653 STATE ROUTE 7", "HOME_ADDR_CITY": "FRESNO", "HOME_ADDR_STATE": "CA", "HOME_ADDR_POSTAL_CODE": "55073-1234", "WORK_ADDR_LINE1": "701 E MAIN STREET", "WORK_ADDR_CITY": "FOWLER", "WORK_ADDR_STATE": "CA", "WORK_ADDR_POSTAL_CODE": "93625"}`},
		{Input: `{"NAME_FIRST": "JANE", "NAME_LAST": "SCHMOE", "PHONE_NUMBER": "559-555-1212", "ADDR_LINE1": "653 STATE ROUTE 7", "ADDR_CITY": "FRESNO", "ADDR_STATE": "CA", "ADDR_POSTAL_CODE": "55073-1234"}`},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ AddRecordWithReturnedRecordIdReq
			typ = make(AddRecordWithReturnedRecordIdReq)

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 AddRecordWithReturnedRecordIdReq
			typ2 = make(AddRecordWithReturnedRecordIdReq)
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestAnalyzeBulkRecordsReqApplicationJSON_EncodeDecode(t *testing.T) {
	var typ AnalyzeBulkRecordsReqApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AnalyzeBulkRecordsReqApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteRecordApplicationJSONInternalServerError_EncodeDecode(t *testing.T) {
	var typ DeleteRecordApplicationJSONInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteRecordApplicationJSONInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteRecordApplicationJSONNotFound_EncodeDecode(t *testing.T) {
	var typ DeleteRecordApplicationJSONNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteRecordApplicationJSONNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFindEntityNetworkApplicationJSONBadRequest_EncodeDecode(t *testing.T) {
	var typ FindEntityNetworkApplicationJSONBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FindEntityNetworkApplicationJSONBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFindEntityNetworkApplicationJSONInternalServerError_EncodeDecode(t *testing.T) {
	var typ FindEntityNetworkApplicationJSONInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FindEntityNetworkApplicationJSONInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFindEntityPathApplicationJSONBadRequest_EncodeDecode(t *testing.T) {
	var typ FindEntityPathApplicationJSONBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FindEntityPathApplicationJSONBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFindEntityPathApplicationJSONInternalServerError_EncodeDecode(t *testing.T) {
	var typ FindEntityPathApplicationJSONInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FindEntityPathApplicationJSONInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetAttributeTypeApplicationJSONInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetAttributeTypeApplicationJSONInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetAttributeTypeApplicationJSONInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetAttributeTypeApplicationJSONNotFound_EncodeDecode(t *testing.T) {
	var typ GetAttributeTypeApplicationJSONNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetAttributeTypeApplicationJSONNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetEntityByEntityIdApplicationJSONInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetEntityByEntityIdApplicationJSONInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetEntityByEntityIdApplicationJSONInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetEntityByEntityIdApplicationJSONNotFound_EncodeDecode(t *testing.T) {
	var typ GetEntityByEntityIdApplicationJSONNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetEntityByEntityIdApplicationJSONNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetEntityByRecordIdApplicationJSONInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetEntityByRecordIdApplicationJSONInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetEntityByRecordIdApplicationJSONInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetEntityByRecordIdApplicationJSONNotFound_EncodeDecode(t *testing.T) {
	var typ GetEntityByRecordIdApplicationJSONNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetEntityByRecordIdApplicationJSONNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRecordApplicationJSONInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetRecordApplicationJSONInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRecordApplicationJSONInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRecordApplicationJSONNotFound_EncodeDecode(t *testing.T) {
	var typ GetRecordApplicationJSONNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRecordApplicationJSONNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetVirtualEntityByRecordIdsApplicationJSONBadRequest_EncodeDecode(t *testing.T) {
	var typ GetVirtualEntityByRecordIdsApplicationJSONBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetVirtualEntityByRecordIdsApplicationJSONBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetVirtualEntityByRecordIdsApplicationJSONInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetVirtualEntityByRecordIdsApplicationJSONInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetVirtualEntityByRecordIdsApplicationJSONInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHowEntityByEntityIDApplicationJSONInternalServerError_EncodeDecode(t *testing.T) {
	var typ HowEntityByEntityIDApplicationJSONInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HowEntityByEntityIDApplicationJSONInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHowEntityByEntityIDApplicationJSONNotFound_EncodeDecode(t *testing.T) {
	var typ HowEntityByEntityIDApplicationJSONNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HowEntityByEntityIDApplicationJSONNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHowEntityByRecordIDApplicationJSONInternalServerError_EncodeDecode(t *testing.T) {
	var typ HowEntityByRecordIDApplicationJSONInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HowEntityByRecordIDApplicationJSONInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHowEntityByRecordIDApplicationJSONNotFound_EncodeDecode(t *testing.T) {
	var typ HowEntityByRecordIDApplicationJSONNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HowEntityByRecordIDApplicationJSONNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLoadBulkRecordsApplicationJSONForbidden_EncodeDecode(t *testing.T) {
	var typ LoadBulkRecordsApplicationJSONForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LoadBulkRecordsApplicationJSONForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLoadBulkRecordsApplicationJSONInternalServerError_EncodeDecode(t *testing.T) {
	var typ LoadBulkRecordsApplicationJSONInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LoadBulkRecordsApplicationJSONInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLoadBulkRecordsReqApplicationJSON_EncodeDecode(t *testing.T) {
	var typ LoadBulkRecordsReqApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LoadBulkRecordsReqApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReevaluateEntityApplicationJSONInternalServerError_EncodeDecode(t *testing.T) {
	var typ ReevaluateEntityApplicationJSONInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReevaluateEntityApplicationJSONInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReevaluateEntityApplicationJSONNotFound_EncodeDecode(t *testing.T) {
	var typ ReevaluateEntityApplicationJSONNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReevaluateEntityApplicationJSONNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReevaluateRecordApplicationJSONInternalServerError_EncodeDecode(t *testing.T) {
	var typ ReevaluateRecordApplicationJSONInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReevaluateRecordApplicationJSONInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReevaluateRecordApplicationJSONNotFound_EncodeDecode(t *testing.T) {
	var typ ReevaluateRecordApplicationJSONNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReevaluateRecordApplicationJSONNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSearchEntitiesByGetApplicationJSONBadRequest_EncodeDecode(t *testing.T) {
	var typ SearchEntitiesByGetApplicationJSONBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SearchEntitiesByGetApplicationJSONBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSearchEntitiesByGetApplicationJSONInternalServerError_EncodeDecode(t *testing.T) {
	var typ SearchEntitiesByGetApplicationJSONInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SearchEntitiesByGetApplicationJSONInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSearchEntitiesByPostApplicationJSONBadRequest_EncodeDecode(t *testing.T) {
	var typ SearchEntitiesByPostApplicationJSONBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SearchEntitiesByPostApplicationJSONBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSearchEntitiesByPostApplicationJSONInternalServerError_EncodeDecode(t *testing.T) {
	var typ SearchEntitiesByPostApplicationJSONInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SearchEntitiesByPostApplicationJSONInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSearchEntitiesByPostReq_EncodeDecode(t *testing.T) {
	var typ SearchEntitiesByPostReq
	typ = make(SearchEntitiesByPostReq)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SearchEntitiesByPostReq
	typ2 = make(SearchEntitiesByPostReq)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestSearchEntitiesByPostReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: `{"NAME_FULL": "JANE SMITH", "ADDR_LINE1": "653 STATE ROUTE 7", "ADDR_CITY": "FRESNO", "ADDR_STATE": "CA", "ADDR_POSTAL_CODE": "55073-1234"}`},
		{Input: `{"NAME_FULL": "JANE SMITH", "DATE_OF_BIRTH": "03-SEP-1987"}`},
		{Input: `{"SSN_NUMBER": "111-22-3333"}`},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ SearchEntitiesByPostReq
			typ = make(SearchEntitiesByPostReq)

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 SearchEntitiesByPostReq
			typ2 = make(SearchEntitiesByPostReq)
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestSzAttributeClass_EncodeDecode(t *testing.T) {
	var typ SzAttributeClass
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzAttributeClass
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzAttributeNecessity_EncodeDecode(t *testing.T) {
	var typ SzAttributeNecessity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzAttributeNecessity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzAttributeSearchResponse_EncodeDecode(t *testing.T) {
	var typ SzAttributeSearchResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzAttributeSearchResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzAttributeSearchResponseData_EncodeDecode(t *testing.T) {
	var typ SzAttributeSearchResponseData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzAttributeSearchResponseData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzAttributeSearchResponseRawData_EncodeDecode(t *testing.T) {
	var typ SzAttributeSearchResponseRawData
	typ = make(SzAttributeSearchResponseRawData)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzAttributeSearchResponseRawData
	typ2 = make(SzAttributeSearchResponseRawData)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzAttributeSearchResult_EncodeDecode(t *testing.T) {
	var typ SzAttributeSearchResult
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzAttributeSearchResult
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzAttributeSearchResultFeatureScores_EncodeDecode(t *testing.T) {
	var typ SzAttributeSearchResultFeatureScores
	typ = make(SzAttributeSearchResultFeatureScores)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzAttributeSearchResultFeatureScores
	typ2 = make(SzAttributeSearchResultFeatureScores)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzAttributeSearchResultFeatures_EncodeDecode(t *testing.T) {
	var typ SzAttributeSearchResultFeatures
	typ = make(SzAttributeSearchResultFeatures)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzAttributeSearchResultFeatures
	typ2 = make(SzAttributeSearchResultFeatures)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzAttributeSearchResultType_EncodeDecode(t *testing.T) {
	var typ SzAttributeSearchResultType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzAttributeSearchResultType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzAttributeType_EncodeDecode(t *testing.T) {
	var typ SzAttributeType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzAttributeType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzAttributeTypeResponse_EncodeDecode(t *testing.T) {
	var typ SzAttributeTypeResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzAttributeTypeResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzAttributeTypeResponseData_EncodeDecode(t *testing.T) {
	var typ SzAttributeTypeResponseData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzAttributeTypeResponseData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzAttributeTypeResponseRawData_EncodeDecode(t *testing.T) {
	var typ SzAttributeTypeResponseRawData
	typ = make(SzAttributeTypeResponseRawData)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzAttributeTypeResponseRawData
	typ2 = make(SzAttributeTypeResponseRawData)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzAttributeTypesResponse_EncodeDecode(t *testing.T) {
	var typ SzAttributeTypesResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzAttributeTypesResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzAttributeTypesResponseData_EncodeDecode(t *testing.T) {
	var typ SzAttributeTypesResponseData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzAttributeTypesResponseData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzAttributeTypesResponseRawData_EncodeDecode(t *testing.T) {
	var typ SzAttributeTypesResponseRawData
	typ = make(SzAttributeTypesResponseRawData)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzAttributeTypesResponseRawData
	typ2 = make(SzAttributeTypesResponseRawData)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzBaseResponse_EncodeDecode(t *testing.T) {
	var typ SzBaseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzBaseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzBulkDataAnalysis_EncodeDecode(t *testing.T) {
	var typ SzBulkDataAnalysis
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzBulkDataAnalysis
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzBulkDataAnalysisResponse_EncodeDecode(t *testing.T) {
	var typ SzBulkDataAnalysisResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzBulkDataAnalysisResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzBulkDataStatus_EncodeDecode(t *testing.T) {
	var typ SzBulkDataStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzBulkDataStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzBulkLoadError_EncodeDecode(t *testing.T) {
	var typ SzBulkLoadError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzBulkLoadError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzBulkLoadResponse_EncodeDecode(t *testing.T) {
	var typ SzBulkLoadResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzBulkLoadResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzBulkLoadResult_EncodeDecode(t *testing.T) {
	var typ SzBulkLoadResult
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzBulkLoadResult
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzCandidateKey_EncodeDecode(t *testing.T) {
	var typ SzCandidateKey
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzCandidateKey
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzDataSource_EncodeDecode(t *testing.T) {
	var typ SzDataSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzDataSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzDataSourceBulkLoadResult_EncodeDecode(t *testing.T) {
	var typ SzDataSourceBulkLoadResult
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzDataSourceBulkLoadResult
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzDataSourceDescriptor_EncodeDecode(t *testing.T) {
	var typ SzDataSourceDescriptor
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzDataSourceDescriptor
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzDataSourceRecordAnalysis_EncodeDecode(t *testing.T) {
	var typ SzDataSourceRecordAnalysis
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzDataSourceRecordAnalysis
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzDataSourceRecordSummary_EncodeDecode(t *testing.T) {
	var typ SzDataSourceRecordSummary
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzDataSourceRecordSummary
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzDataSourceResponse_EncodeDecode(t *testing.T) {
	var typ SzDataSourceResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzDataSourceResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzDataSourceResponseData_EncodeDecode(t *testing.T) {
	var typ SzDataSourceResponseData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzDataSourceResponseData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzDataSourceResponseRawData_EncodeDecode(t *testing.T) {
	var typ SzDataSourceResponseRawData
	typ = make(SzDataSourceResponseRawData)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzDataSourceResponseRawData
	typ2 = make(SzDataSourceResponseRawData)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzDataSourcesResponse_EncodeDecode(t *testing.T) {
	var typ SzDataSourcesResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzDataSourcesResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzDataSourcesResponseData_EncodeDecode(t *testing.T) {
	var typ SzDataSourcesResponseData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzDataSourcesResponseData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzDataSourcesResponseDataDataSourceDetails_EncodeDecode(t *testing.T) {
	var typ SzDataSourcesResponseDataDataSourceDetails
	typ = make(SzDataSourcesResponseDataDataSourceDetails)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzDataSourcesResponseDataDataSourceDetails
	typ2 = make(SzDataSourcesResponseDataDataSourceDetails)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzDataSourcesResponseRawData_EncodeDecode(t *testing.T) {
	var typ SzDataSourcesResponseRawData
	typ = make(SzDataSourcesResponseRawData)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzDataSourcesResponseRawData
	typ2 = make(SzDataSourcesResponseRawData)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzDeleteRecordResponse_EncodeDecode(t *testing.T) {
	var typ SzDeleteRecordResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzDeleteRecordResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzDeleteRecordResponseData_EncodeDecode(t *testing.T) {
	var typ SzDeleteRecordResponseData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzDeleteRecordResponseData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzDeleteRecordResponseRawData_EncodeDecode(t *testing.T) {
	var typ SzDeleteRecordResponseRawData
	typ = make(SzDeleteRecordResponseRawData)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzDeleteRecordResponseRawData
	typ2 = make(SzDeleteRecordResponseRawData)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzDisclosedRelation_EncodeDecode(t *testing.T) {
	var typ SzDisclosedRelation
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzDisclosedRelation
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzEntityData_EncodeDecode(t *testing.T) {
	var typ SzEntityData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzEntityData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzEntityFeature_EncodeDecode(t *testing.T) {
	var typ SzEntityFeature
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzEntityFeature
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzEntityFeatureDetail_EncodeDecode(t *testing.T) {
	var typ SzEntityFeatureDetail
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzEntityFeatureDetail
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzEntityFeatureStatistics_EncodeDecode(t *testing.T) {
	var typ SzEntityFeatureStatistics
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzEntityFeatureStatistics
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzEntityNetworkData_EncodeDecode(t *testing.T) {
	var typ SzEntityNetworkData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzEntityNetworkData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzEntityNetworkResponse_EncodeDecode(t *testing.T) {
	var typ SzEntityNetworkResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzEntityNetworkResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzEntityNetworkResponseRawData_EncodeDecode(t *testing.T) {
	var typ SzEntityNetworkResponseRawData
	typ = make(SzEntityNetworkResponseRawData)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzEntityNetworkResponseRawData
	typ2 = make(SzEntityNetworkResponseRawData)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzEntityPath_EncodeDecode(t *testing.T) {
	var typ SzEntityPath
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzEntityPath
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzEntityPathData_EncodeDecode(t *testing.T) {
	var typ SzEntityPathData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzEntityPathData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzEntityPathResponse_EncodeDecode(t *testing.T) {
	var typ SzEntityPathResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzEntityPathResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzEntityPathResponseRawData_EncodeDecode(t *testing.T) {
	var typ SzEntityPathResponseRawData
	typ = make(SzEntityPathResponseRawData)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzEntityPathResponseRawData
	typ2 = make(SzEntityPathResponseRawData)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzEntityRecord_EncodeDecode(t *testing.T) {
	var typ SzEntityRecord
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzEntityRecord
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzEntityRecordOriginalSourceData_EncodeDecode(t *testing.T) {
	var typ SzEntityRecordOriginalSourceData
	typ = make(SzEntityRecordOriginalSourceData)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzEntityRecordOriginalSourceData
	typ2 = make(SzEntityRecordOriginalSourceData)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzEntityResponse_EncodeDecode(t *testing.T) {
	var typ SzEntityResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzEntityResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzEntityResponseRawData_EncodeDecode(t *testing.T) {
	var typ SzEntityResponseRawData
	typ = make(SzEntityResponseRawData)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzEntityResponseRawData
	typ2 = make(SzEntityResponseRawData)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzError_EncodeDecode(t *testing.T) {
	var typ SzError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzErrorResponse_EncodeDecode(t *testing.T) {
	var typ SzErrorResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzErrorResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzFeatureReference_EncodeDecode(t *testing.T) {
	var typ SzFeatureReference
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzFeatureReference
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzFeatureScore_EncodeDecode(t *testing.T) {
	var typ SzFeatureScore
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzFeatureScore
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzFlaggedEntity_EncodeDecode(t *testing.T) {
	var typ SzFlaggedEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzFlaggedEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzFlaggedRecord_EncodeDecode(t *testing.T) {
	var typ SzFlaggedRecord
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzFlaggedRecord
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzHowEntityResponse_EncodeDecode(t *testing.T) {
	var typ SzHowEntityResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzHowEntityResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzHowEntityResponseRawData_EncodeDecode(t *testing.T) {
	var typ SzHowEntityResponseRawData
	typ = make(SzHowEntityResponseRawData)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzHowEntityResponseRawData
	typ2 = make(SzHowEntityResponseRawData)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzHowEntityResult_EncodeDecode(t *testing.T) {
	var typ SzHowEntityResult
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzHowEntityResult
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzHowEntityResultResolutionSteps_EncodeDecode(t *testing.T) {
	var typ SzHowEntityResultResolutionSteps
	typ = make(SzHowEntityResultResolutionSteps)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzHowEntityResultResolutionSteps
	typ2 = make(SzHowEntityResultResolutionSteps)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzHowMatchInfo_EncodeDecode(t *testing.T) {
	var typ SzHowMatchInfo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzHowMatchInfo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzHowMatchInfoFeatureScores_EncodeDecode(t *testing.T) {
	var typ SzHowMatchInfoFeatureScores
	typ = make(SzHowMatchInfoFeatureScores)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzHowMatchInfoFeatureScores
	typ2 = make(SzHowMatchInfoFeatureScores)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzHttpMethod_EncodeDecode(t *testing.T) {
	var typ SzHttpMethod
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzHttpMethod
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzLicenseInfo_EncodeDecode(t *testing.T) {
	var typ SzLicenseInfo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzLicenseInfo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzLicenseResponse_EncodeDecode(t *testing.T) {
	var typ SzLicenseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzLicenseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzLicenseResponseData_EncodeDecode(t *testing.T) {
	var typ SzLicenseResponseData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzLicenseResponseData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzLicenseResponseRawData_EncodeDecode(t *testing.T) {
	var typ SzLicenseResponseRawData
	typ = make(SzLicenseResponseRawData)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzLicenseResponseRawData
	typ2 = make(SzLicenseResponseRawData)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzLinks_EncodeDecode(t *testing.T) {
	var typ SzLinks
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzLinks
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzLoadRecordResponse_EncodeDecode(t *testing.T) {
	var typ SzLoadRecordResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzLoadRecordResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzLoadRecordResponseData_EncodeDecode(t *testing.T) {
	var typ SzLoadRecordResponseData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzLoadRecordResponseData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzLoadRecordResponseRawData_EncodeDecode(t *testing.T) {
	var typ SzLoadRecordResponseRawData
	typ = make(SzLoadRecordResponseRawData)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzLoadRecordResponseRawData
	typ2 = make(SzLoadRecordResponseRawData)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzMatchLevel_EncodeDecode(t *testing.T) {
	var typ SzMatchLevel
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzMatchLevel
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzMatchedRecord_EncodeDecode(t *testing.T) {
	var typ SzMatchedRecord
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzMatchedRecord
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzMatchedRecordOriginalSourceData_EncodeDecode(t *testing.T) {
	var typ SzMatchedRecordOriginalSourceData
	typ = make(SzMatchedRecordOriginalSourceData)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzMatchedRecordOriginalSourceData
	typ2 = make(SzMatchedRecordOriginalSourceData)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzMeta_EncodeDecode(t *testing.T) {
	var typ SzMeta
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzMeta
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzMetaTimings_EncodeDecode(t *testing.T) {
	var typ SzMetaTimings
	typ = make(SzMetaTimings)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzMetaTimings
	typ2 = make(SzMetaTimings)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzNameScoring_EncodeDecode(t *testing.T) {
	var typ SzNameScoring
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzNameScoring
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzRecordResponse_EncodeDecode(t *testing.T) {
	var typ SzRecordResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzRecordResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzRecordResponseData_EncodeDecode(t *testing.T) {
	var typ SzRecordResponseData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzRecordResponseData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzRecordResponseRawData_EncodeDecode(t *testing.T) {
	var typ SzRecordResponseRawData
	typ = make(SzRecordResponseRawData)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzRecordResponseRawData
	typ2 = make(SzRecordResponseRawData)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzReevaluateResponse_EncodeDecode(t *testing.T) {
	var typ SzReevaluateResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzReevaluateResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzReevaluateResponseData_EncodeDecode(t *testing.T) {
	var typ SzReevaluateResponseData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzReevaluateResponseData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzReevaluateResponseRawData_EncodeDecode(t *testing.T) {
	var typ SzReevaluateResponseRawData
	typ = make(SzReevaluateResponseRawData)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzReevaluateResponseRawData
	typ2 = make(SzReevaluateResponseRawData)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzRelatedEntity_EncodeDecode(t *testing.T) {
	var typ SzRelatedEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzRelatedEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzRelatedEntityFeatures_EncodeDecode(t *testing.T) {
	var typ SzRelatedEntityFeatures
	typ = make(SzRelatedEntityFeatures)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzRelatedEntityFeatures
	typ2 = make(SzRelatedEntityFeatures)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzRelatedFeatures_EncodeDecode(t *testing.T) {
	var typ SzRelatedFeatures
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzRelatedFeatures
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzRelationDirection_EncodeDecode(t *testing.T) {
	var typ SzRelationDirection
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzRelationDirection
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzRelationshipType_EncodeDecode(t *testing.T) {
	var typ SzRelationshipType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzRelationshipType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzResolutionInfo_EncodeDecode(t *testing.T) {
	var typ SzResolutionInfo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzResolutionInfo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzResolutionStep_EncodeDecode(t *testing.T) {
	var typ SzResolutionStep
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzResolutionStep
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzResolvedEntity_EncodeDecode(t *testing.T) {
	var typ SzResolvedEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzResolvedEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzResolvedEntityFeatures_EncodeDecode(t *testing.T) {
	var typ SzResolvedEntityFeatures
	typ = make(SzResolvedEntityFeatures)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzResolvedEntityFeatures
	typ2 = make(SzResolvedEntityFeatures)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzResponseWithRawData_EncodeDecode(t *testing.T) {
	var typ SzResponseWithRawData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzResponseWithRawData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzResponseWithRawDataRawData_EncodeDecode(t *testing.T) {
	var typ SzResponseWithRawDataRawData
	typ = make(SzResponseWithRawDataRawData)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzResponseWithRawDataRawData
	typ2 = make(SzResponseWithRawDataRawData)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzScoredFeature_EncodeDecode(t *testing.T) {
	var typ SzScoredFeature
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzScoredFeature
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzScoringBehavior_EncodeDecode(t *testing.T) {
	var typ SzScoringBehavior
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzScoringBehavior
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzScoringBucket_EncodeDecode(t *testing.T) {
	var typ SzScoringBucket
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzScoringBucket
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzScoringFrequency_EncodeDecode(t *testing.T) {
	var typ SzScoringFrequency
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzScoringFrequency
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzSearchFeatureScore_EncodeDecode(t *testing.T) {
	var typ SzSearchFeatureScore
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzSearchFeatureScore
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzServerInfo_EncodeDecode(t *testing.T) {
	var typ SzServerInfo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzServerInfo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzServerInfoResponse_EncodeDecode(t *testing.T) {
	var typ SzServerInfoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzServerInfoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzVersionInfo_EncodeDecode(t *testing.T) {
	var typ SzVersionInfo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzVersionInfo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzVersionResponse_EncodeDecode(t *testing.T) {
	var typ SzVersionResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzVersionResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzVersionResponseRawData_EncodeDecode(t *testing.T) {
	var typ SzVersionResponseRawData
	typ = make(SzVersionResponseRawData)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzVersionResponseRawData
	typ2 = make(SzVersionResponseRawData)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzVirtualEntity_EncodeDecode(t *testing.T) {
	var typ SzVirtualEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzVirtualEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzVirtualEntityData_EncodeDecode(t *testing.T) {
	var typ SzVirtualEntityData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzVirtualEntityData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzVirtualEntityRecord_EncodeDecode(t *testing.T) {
	var typ SzVirtualEntityRecord
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzVirtualEntityRecord
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzVirtualEntityResponse_EncodeDecode(t *testing.T) {
	var typ SzVirtualEntityResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzVirtualEntityResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzVirtualEntityResponseRawData_EncodeDecode(t *testing.T) {
	var typ SzVirtualEntityResponseRawData
	typ = make(SzVirtualEntityResponseRawData)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzVirtualEntityResponseRawData
	typ2 = make(SzVirtualEntityResponseRawData)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzWhyEntitiesResponse_EncodeDecode(t *testing.T) {
	var typ SzWhyEntitiesResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzWhyEntitiesResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzWhyEntitiesResponseData_EncodeDecode(t *testing.T) {
	var typ SzWhyEntitiesResponseData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzWhyEntitiesResponseData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzWhyEntitiesResponseRawData_EncodeDecode(t *testing.T) {
	var typ SzWhyEntitiesResponseRawData
	typ = make(SzWhyEntitiesResponseRawData)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzWhyEntitiesResponseRawData
	typ2 = make(SzWhyEntitiesResponseRawData)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzWhyEntitiesResult_EncodeDecode(t *testing.T) {
	var typ SzWhyEntitiesResult
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzWhyEntitiesResult
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzWhyEntityResponse_EncodeDecode(t *testing.T) {
	var typ SzWhyEntityResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzWhyEntityResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzWhyEntityResponseData_EncodeDecode(t *testing.T) {
	var typ SzWhyEntityResponseData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzWhyEntityResponseData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzWhyEntityResponseRawData_EncodeDecode(t *testing.T) {
	var typ SzWhyEntityResponseRawData
	typ = make(SzWhyEntityResponseRawData)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzWhyEntityResponseRawData
	typ2 = make(SzWhyEntityResponseRawData)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzWhyEntityResult_EncodeDecode(t *testing.T) {
	var typ SzWhyEntityResult
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzWhyEntityResult
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzWhyMatchInfo_EncodeDecode(t *testing.T) {
	var typ SzWhyMatchInfo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzWhyMatchInfo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzWhyMatchInfoCandidateKeys_EncodeDecode(t *testing.T) {
	var typ SzWhyMatchInfoCandidateKeys
	typ = make(SzWhyMatchInfoCandidateKeys)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzWhyMatchInfoCandidateKeys
	typ2 = make(SzWhyMatchInfoCandidateKeys)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzWhyMatchInfoFeatureScores_EncodeDecode(t *testing.T) {
	var typ SzWhyMatchInfoFeatureScores
	typ = make(SzWhyMatchInfoFeatureScores)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzWhyMatchInfoFeatureScores
	typ2 = make(SzWhyMatchInfoFeatureScores)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzWhyPerspective_EncodeDecode(t *testing.T) {
	var typ SzWhyPerspective
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzWhyPerspective
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzWhyRecordsResponse_EncodeDecode(t *testing.T) {
	var typ SzWhyRecordsResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzWhyRecordsResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzWhyRecordsResponseData_EncodeDecode(t *testing.T) {
	var typ SzWhyRecordsResponseData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzWhyRecordsResponseData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzWhyRecordsResponseRawData_EncodeDecode(t *testing.T) {
	var typ SzWhyRecordsResponseRawData
	typ = make(SzWhyRecordsResponseRawData)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzWhyRecordsResponseRawData
	typ2 = make(SzWhyRecordsResponseRawData)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSzWhyRecordsResult_EncodeDecode(t *testing.T) {
	var typ SzWhyRecordsResult
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SzWhyRecordsResult
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWhyEntitiesApplicationJSONInternalServerError_EncodeDecode(t *testing.T) {
	var typ WhyEntitiesApplicationJSONInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WhyEntitiesApplicationJSONInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWhyEntitiesApplicationJSONNotFound_EncodeDecode(t *testing.T) {
	var typ WhyEntitiesApplicationJSONNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WhyEntitiesApplicationJSONNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWhyEntityByEntityIDApplicationJSONInternalServerError_EncodeDecode(t *testing.T) {
	var typ WhyEntityByEntityIDApplicationJSONInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WhyEntityByEntityIDApplicationJSONInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWhyEntityByEntityIDApplicationJSONNotFound_EncodeDecode(t *testing.T) {
	var typ WhyEntityByEntityIDApplicationJSONNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WhyEntityByEntityIDApplicationJSONNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWhyEntityByRecordIDApplicationJSONInternalServerError_EncodeDecode(t *testing.T) {
	var typ WhyEntityByRecordIDApplicationJSONInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WhyEntityByRecordIDApplicationJSONInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWhyEntityByRecordIDApplicationJSONNotFound_EncodeDecode(t *testing.T) {
	var typ WhyEntityByRecordIDApplicationJSONNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WhyEntityByRecordIDApplicationJSONNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWhyRecordsApplicationJSONInternalServerError_EncodeDecode(t *testing.T) {
	var typ WhyRecordsApplicationJSONInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WhyRecordsApplicationJSONInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWhyRecordsApplicationJSONNotFound_EncodeDecode(t *testing.T) {
	var typ WhyRecordsApplicationJSONNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WhyRecordsApplicationJSONNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
